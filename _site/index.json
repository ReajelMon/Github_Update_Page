{
  "Algemene-informatie/AddressValidation-API/index.html": {
    "href": "Algemene-informatie/AddressValidation-API/index.html",
    "title": "AddressValidation API",
    "keywords": "AddressValidation API AddressValidation API https://addressvalidation.monta.nl/swagger/index.html 11-01-2023, Erin Algemeen De AddressValidation API is een nieuwe website binnen Monta met als doel het centraliseren en verbeteren van adresvalidatie binnen andere Monta processen. De applicatie staat momenteel live en wordt aangeroepen vanuit de Verify, maar wordt nog niet gebruikt om daadwerkelijk bestellingen te blokkeren als het adres als ongeldig wordt gezien. De applicatie gebruikt adresgegevens (ContactDetails) + extra's om een adres te valideren. Zie de afbeelding hieronder: Gegevens (input) Er zijn drie adresvalidatie endpoints. Gebruik voor nu de validate-complete. Hiervoor is de volgende input nodig: De ShipperID wordt gebruikt om regels per verzender te controleren. De EOrderID wordt gebruikt als het uiteindelijke resultaat wordt opgeslagen. De RelationID wordt gebruikt omdat voor bepaalde klanten bepaalde adresvalidatie stappen aan/uit gezet kunnen worden. UseLibPostalParse wordt gebruikt om de LibPostal library wel/niet te gebruiken. LibPostal staat nog niet live. Zet deze daarom op false. Als SaveToDb op true staat wordt het uiteindelijke resultaat opgeslagen in de Monta_Backend MongoDB. Gegevens (output) Er wordt in hoofdlijnen gevalideerd op drie dingen: de regels van de verzender, de regels per land, en eventueel externe adresvalidatie software. Daarnaast zitten er ook andere checks, wordt geprobeerd gegevens automatisch te verbeteren, et cetera. De stappen zijn onderverdeeld in groepen. Zie de afbeelding hieronder: Adresvalidatie bestaat dus meerdere stappen. Het uiteindelijke resultaat van één adres validatie bevat algemene informatie, of het adres geldig is of niet, en de resultaten per stap. Je kan precies zien waarom een adres ongeldig is en welke stappen doorlopen zijn in het resultaat. Zie de afbeelding hieronder: Hoe wordt de AddressValidation momenteel gebruikt? De AddressValidation API staat live, en wordt aangeroepen door de Verify voor elke bestelling. Het resultaat wordt opgeslagen in de Monta_Backend MongoDB, en de JSON die de API teruggeeft wordt opgeslagen. Het resultaat wordt nog niet gebruikt om daadwerkelijk bestellingen met een (volgens de AddressValidation API) ongeldig adres te blokkeren. Technische uitleg Tijdens het adresvalidatie algoritme worden de stappen van adresvalidatie uitgevoerd, en per stap het resultaat toegevoegd aan een uiteindelijke adresvalidatieresultaat. De Validator loopt continue ActionBlocks door, totdat de adresvalidatie klaar is (het adres is (on)geldig verklaard). ActionsBlocks bevatten acties (IAction implementaties), en één ActionBlockResultChecker implementatie. IAction implementaties bevatten de businesslogica van de adresvalidatie. ActionResults zijn resultaten die vanuit IAction implementaties gegenereerd worden. ValidationResultBuilder bevat alle informatie over de validatie, en staat centraal. Wordt een keer geïnstantieerd en daarna continue aangevuld, tot de adresvalidatie voorbij is. De ActionBlockResultChecker controleerd of de individuele acties (van dat action block) het gewenste resultaat gaven, en maakt het volgende ActionBlock aan. Voor elk land en elke verzender bestaan verschillende regels. Deze worden vanuit een JSON bestand opgeslagen. De regels kunnen daardoor makkelijk aangepast worden. Naast adresvalidatie zelf heeft de AddressValidation API CRUD functionaliteiten voor: De adresvalidatie resultaten; De configuratie van klanten. Externe adresvalidatie In de adresvalidatie zitten enkele stappen die externe software (APIs) aanroepen. Namelijk: PostNL Validation API https://developer.postnl.nl/browse-apis/checkout/postcodecheck/documentation/ AddressValidator NET https://www.address-validator.net/ Voor AddressValidator net gebruik ik (Erin) nu een persoonlijk account (alleen voor testen). Om deze daadwerkelijk te gebruiken zal een algemeen Monta account ingesteld moeten worden inclusief betalingen, et cetera. Deze staan niet standaard aan. Per klant kan bepaald worden of deze aan/uit gaan. Dit wordt ook opgeslagen in de Monta_Backend MongoDB. Deze kunnen uiteindelijk aangezet worden via MontaPortal. Hier is een nieuwe pagina voor gemaakt (die nog niet live staat). In de adresvalidatie wordt via de configuratie gekeken of/welke stap(pen) wel/niet doorlopen moeten worden. Omdat deze externe adresvalidatie stappen geld (kunnen) kosten kan het zijn dat de klant gefactureerd moet worden hiervoor. Dit is ook de reden dat we willen dat klanten dit uit of aan kunnen zetten (willen klanten hier niet voor betalen kunnen ze kiezen externe adresvalidatie stappen uit te zetten ). Verdere stappen De applicatie staat dus nog niet \"echt\" live (as of 11-1-2023). Eventueel volgende stappen zouden kunnen zijn: De adresvalidatieresultaten gebruiken in de Verify om bestellingen te blokkeren (eventueel eerst voor één klant). Alle regels van landen/verzenders te dubbelchecken. Externe adresvalidatie verder implementeren, om eventueel bij één klant te implementeren. Contact opnemen met externe partij(en), financiën regelen (API keys van externe partij regelen indien nodig, inbouwen dat klanten gefactureerd worden). Delen hiervan zijn al deels ingebouwd/geregeld. Uiteindelijke de adresvalidatie voor elke klant aanzetten, en elke klant de mogelijkheid geven externe adresvalidatie te gebruiken. Langzaam meer stappen/bronnen/regels/etc toe voegen aan de AddressValidation API. Eventueel adresvalidatie van andere processen (anders dan Verify) vervangen met de AddressValidation API, en (nu nog bestaande) adresvalidatie verwijderen uit de Verify/ShippingAPI/Etc."
  },
  "Algemene-informatie/Apparaten/Autostore/index.html": {
    "href": "Algemene-informatie/Apparaten/Autostore/index.html",
    "title": "Autostore",
    "keywords": "Autostore Autostore is een ASRS systeem (Automated Storage and Retrieval Systems). Het systeem bestaat uit een grid van maximaal 16 bins hoog. Bovenop dit grid rijden robots. Deze robots kunnen de bins optillen, neerzetten en verplaatsten. Onderstaand een video die de werking van de Autostore laat zien. Werking van de Autostore ::: video ::: Verschillende data stromen bij de Autostore Product synchronisatie De nieuwe en gewijzigde producten zullen iedere vijf minuten naar de Autostore worden gestuurd. Iedere week worden alle producten gesynchroniseerd. Inbound Als een inboundstation is gekoppeld aan de Autostore, dan wordt de optie autostore getoond in de inbound app. Deze staat standaard aangevinkt. Bij het inbounden van het product, zal er een AutoStoreTT01 label uit de printer komen. Ook wordt er ingepland, dat de inbound wordt doorgestuurd naar de autostore om hem daar te kunnen koppelen. Door de barcode te scannen van de AutoStoreTT01 kan de juiste inbound gekozen worden bij het Autostore station. Zodra de producten zijn geplaatst in de Autostore, wordt de koppeling ook uitgevoerd aan de kant van Monta. Aan de Monta kant heeft de Autostore maar één locatie. Dit is een multi product locatie, waarop alle producten die in de Autostore liggen worden geplaatst. Vanuit GoMonta is het niet mogelijk om een inbound te koppelen op deze locatie, dit moet altijd vanuit de Autostore worden gedaan. Als een inbound wordt verwijderd in de Autostore applicatie, dan zal de inbound ook verwijderd worden aan de kant van Monta. Ook is het mogelijk om eerst de inbound te verwijderen in GoMonta. In dit geval met je deze ook handmatig verwijderen in de Autostore applicatie. Bij het verwerken van retouren wordt gekeken of het product in de Autostore ligt. Als dit het geval is, dan komt er een AutoStoreTT01 label uit de printer en wordt de retour doorgezet naar de Autostore. Als dit niet het geval is, dan wordt de vraag gesteld of het product naar de Autostore moet. Outbound De Autostore orders krijgen een aparte ready to pick status genaamd Autostore. Als een order een product heeft dat ligt in de Autostore dan krijgt de order deze status. De orders met deze status zullen niet getoond worden op de handscanner. Hierdoor moet het picken gestart worden via GoMonta. Via de Autostore knop in GoMonta kan er een order batch worden gemaakt. Het is mogelijk om verschillende filters in te stellen. Op basis van deze filters wordt er een selectie orders doorgestuurd naar de Autostore. Ook is het mogelijk om handmatig een selectie orders te selecteren. Er zijn drie soorten pickstromen: S-orders: In deze pickstroom zitten alleen de S-orders uit de Autostore. Deze kunnen naar het picken gelijk worden ingepakt. Het maximaal aantal orders in deze pickstroom is in te stellen in GoMonta bij de magazijn outbound instellingen. Dit is dezelfde instelling, die gebruikt wordt voor de handscanners. Multiline orders volledig in de Autostore: In deze pickstroom zitten de multiline orders die alleen via de Autostore gepickt moeten worden. Deze kunnen naar het picken gelijk worden gesorteed in de Put-To-Light. Het maximaal aantal orders in deze pickstroom is in te stellen in GoMonta bij de magazijn outbound instellingen. Dit is dezelfde instelling, die gebruikt wordt voor de handscanners. Multiline orders gedeeltelijk in de Autostore: In deze pickstroom zitten de multiline orders die gedeeltelijk via de Autostore gepickt moeten worden. Na het picken via de Autostore, moet er nog een pickronde worden gelopen in het magazijn. De pickroute kan op de handscanner geopend worden via krat herstel. Nadat alle pickacties zijn gedaan, kunnen alle orders worden uitgesorteerd in de Put-To-Light. Het maximaal aantal orders in deze pickstroom is in te stellen in GoMonta bij de magazijn outbound instellingen. Dit is dezelfde instelling, die gebruikt wordt voor de handscanners. Als er wordt start met picken bij de Autostore, dan komt er een label uit met het kratnummer en informatie op de bulkpickbon. Als de bulkpickbon is afgerond komt er weer een label uit de printer met het kratnummer en de vervolg stappen. Als een bulkpickbon wordt verwijderd vanuit de Autostore, dan wordt deze direct terug erin gezet door Monta-systeem. Dit wordt gedaan, omdat een bulkpickbon niet gereset mag worden in het Monta-systeem. Voorraadbeheer In GoMonta is het niet mogelijk om voorraad correcties op de Autostore locatie uit te voeren. Dit moet gedaan worden via de Autostore. De Autostore zal vervolgens een correctie boeking doorsturen naar het Monta-systeem, waar deze verwerkt zal worden. Iedere dag wordt er een voorraadlijst vanuit de Autostore naar het Monta-systeem gestuurd. Hierbij zal worden gecontroleerd of de voorraadstanden nog kloppen. Als dit niet het geval is, dan worden deze verschillen getoond op de WCS pagina van de Autostore. Hier kunnen de voorraadverschillen handmatig verwerk worden. De voorraadstand in het Monta-systeem zal dan gelijk worden getrokken met die van de Autostore. Verder is het optioneel om een voorraadtelling taak in de Autostore te schieten voor dit product. Standaard staat deze optie aan. In de Autostore kunnen deze taken geactiveerd worden en zullen alle Autostore locaties met dit product langskomen om geteld te worden. Replenish Er kunnen geen producten direct verplaatst worden naar de Autostore locatie binnen het Monta-systeem. Als producten naar de Autostore geplaatst moeten worden, dan moeten deze eerst op een movebot-locatie geplaatst worden. Als een product op een movebot-locatie wordt geplaatst, dan krijgt de Autostore een vooraanmelding van dit product. Als dit product wordt geplaatst in de Autostore, dan zal de Autostore dit doorzetten naar het Monta-systeem. Hier wordt de verplaatsing vervolgens voltooid. Als producten uit de Autostore moeten worden verplaatst naar het magazijn, dan dient er een order te worden aangemaakt. Vervolgens kunnen de producten geplaatst worden in het magazijn. Pickbon Bij Autostore orders is het niet mogelijk om een pickbon te downloaden. Als een order apart gepickt moet worden, dan kan via de Autostore schermen in GoMonta een handmatige selectie ingeschoten worden. Element Logic https://emanager-integration.elementlogic.net/index.html Mogelijke problemen bij de Autostore Een bulkpickbon kan worden afgerond in de Autostore zonder dat er gepickt wordt. Hierdoor zullen alle niet afgeronde pickacties op joker worden gezet. Om dit te herstellen neem dan contact op. Soms wordt een bepaalde actie niet juist teruggekoppeld aan Monta. De gefaalde acties kunnen opnieuw worden verstuurd vanuit de Autostore software. ********** De informatie hieronder is meer van technische aard ********** Technische informatie bij de Autostore De Autostore service is te benaderen via autostore.monta.nl. Deze webservice draait op de mp-web340.montapacking.nl, mp-web341.montapacking.nl en mp-web342.montapacking.nl. De webservice bevat een backgroundservice. Hierin worden alle Autostore planningitems verwerkt. Op deze servers is de emanager van de gekoppelde klanten ook te bereiken. De gegevens staan in de database in tblAutoStoreElementLogicSettings. Alle tabellen voor de Autostore bevatten de naam Autostore. Outbound De bulkpickbon wordt gesorteerd op productniveau doorgestuurd naar de Autostore. De pickacties worden gebundeld, zodat niet dezelfde Autostore locatie terugkomt. Dit wordt opgeslagen in de database. Als er is gepickt, dan wordt de hoeveelheid verdeeld over de pickacties. Inbound en retouren In de tabel tblInboundStations moet het AutoStoreId worden ingevuld om de Autostore te koppelen aan het Inbound/retouren station. In de tabel tblMagazijnen moet de AutoStoreTT01 locatie worden ingevuld om deze te kunnen gebruiken. Product synchronisatie Voorraadbeheer"
  },
  "Algemene-informatie/Apparaten/BVM/index.html": {
    "href": "Algemene-informatie/Apparaten/BVM/index.html",
    "title": "BVM",
    "keywords": "BVM BVM is de naam van een verpakkingsmachine. Deze verpakkingsmachine kan producten in zakken verpakken. Deze machine draait bij Monta Breda. Er worden voornamelijk S-orders op verwerkt en de machine is aangesloten op de rollenbaan om verpakte zendingen af te voeren. Echeck voor BVM Op de BVM is een computer gemonteerd waarop de Monta Echeck software draait. In de Echeck schermen is duidelijk te herkennen dat het om een Echeckstation bij de BVM machine gaat doordat er een afbeelding van de BVM machine te zien is. Vanuit de Echeck software gezien gedraagt de BVM machine zich als een labelprinter. Drager De zendingen die door de BVM machine verpakt zijn hebben als drager 'BVM Machine verpakkingsmateriaal' Pickstroom Orders die geschikt zijn voor de BVM machine zijn te herkennen via onderstaande pickstroom op de scanner Business Intelligence montaWCS Er wordt bijgehouden hoeveel orders verpakt zijn door de BVM. Deze informatie is in te zien via montaportal, onder het account van de vestiging. Hoe werkt de BVM machine ::: video ::: ********** De informatie hieronder is meer van technische aard ********** Technische informatie bij de Pick To Light Echeckstation gekoppeld aan BVM De tabel waar een echeckstation aan een Monta BVM wordt gekoppeld is in de Monta_Backend database te vinden. De naam van de tabel is tblPackingmachineController. In deze tabel wordt het Echeckstation gekoppeld, wordt het magazijn bepaald en ook staat het IP nummer van een controller van de machine vermeld."
  },
  "Algemene-informatie/Apparaten/Echeck-To-Light/index.html": {
    "href": "Algemene-informatie/Apparaten/Echeck-To-Light/index.html",
    "title": "Echeck To Light",
    "keywords": "Echeck To Light Echecklocaties met producten Binnen Monta bestaat het concept Echecklocaties. Dit zijn gewone magazijnlocaties, maar ze hebben de eigenschap Echecklocatie. Dit concept wordt gebruikt als je bijvoorbeeld bij elke order een flyer moet toevoegen. De flyers worden dan op de Echecklocatie gezet en het orderpicken van de orders wordt gedaan zonder die flyer. Daardoor worden worden sommige orders een S-order terwijl ze met flyer een M-order zouden zijn geworden. Tijdens het verpakken bij het Echeckstation, wordt door de software gevraagd om ook de flyer uit de Echecklocatie te pakken en bij de order te voegen. Per magazijn kan ingesteld worden hoeveel Echecklocaties er zijn en die Echecklocaties zijn dan voor elk Echeckstation beschikbaar. Echeck only order Bij dit concept van Echecklocaties, kan het in uitzonderlijke gevallen voorkomen dat een order alleen maar producten bevat die op Echecklocaties liggen. Zo'n order wordt dan een 'EcheckOnly' order. Van de mogelijkheid EcheckOnly orders kan gebruik worden gemaakt als een klant een heel klein aantal sku's heeft en kleine producten. Er zou den een kleine magazijnstelling geplaatst kunnen worden tegen een Echecktafel aan en in die kleine magazijnstelling kunnen dan alle sku's van zo'n klant liggen. In het volledige EcheckOnly proces van zo'n klant is dan eigenlijk de stap van orderpicken overgeslagen. Het concept van 'EcheckOnly' orders verwerken is verder uitgewerkt op deze pagina; EcheckOnly Echeck to light Voor de klant Oot in Weide 30 is dit concept van EcheckOnly orders toegepast, maar dan met als uitbreiding dat er tijdens het Echecken een lampje gaat branden bij de Echecklocatie waarvanaf het te echecken product gepakt kan worden. Om voor Oot een super snel proces te krijgen zijn een aantal aanpassingen gedaan. Echeckonly orders (alleen oot zichtbaar bij echecktolight station en alle echeckonly orders op andere stations) Volgorde: geplande verzenddatum, daarna magazijnlocatiecode Echeckonly locatie oot001 t/m 00t070 Oot001 t/m oot010 voor dragers. Populairste drager op oot001 Dragers zijn producten die als eorderregel worden doorgegeven door oot en gewoon als producten worden gepickt (atop lampjes boven rolco’s met dragers) Als drager als product (eorderregel) gescand is tijdens echecken, hoeft niet ook nog eens de drager gescand worden. Als het Echeck station een Echecktolight is, wordt volgende order direct geopend (gaan lampjes branden) na afronden vorige order. Dit gedrag is uit te schakelen door scannen van barcode ‘EcheckToLightNextOrderAutoOn’. En daarna weer in te schakelen door scannen van barcode ‘EcheckToLightNextOrderAutoOff’. Filmpje van het EcheckToLight concept in werking filmpje EcheckToLight ********** De informatie hieronder is meer van technische aard ********** Technische informatie bij de Echeckwall Het systeem voor de Echeckwall bestaat uit verschillende onderdelen: Database Gegevens over de EcheckToLight zijn te vinden in de tabel tblEcheckToLightStelling in Monta_Backend Via de tabel tblEcheckToLightLocations in Monta_Backend worden de atop lampjes en magazijnlocaties aan elkaar en aan de EcheckToLight stelling gekoppeld. via de kolom tblEcheckStations.EcheckToLightId kan bij een Echeckstation herkend worden dat het om een EcheckToLight gaat"
  },
  "Algemene-informatie/Apparaten/Echeckwall/Echeckwall-updates/index.html": {
    "href": "Algemene-informatie/Apparaten/Echeckwall/Echeckwall-updates/index.html",
    "title": "Echeckwall updates",
    "keywords": "Echeckwall updates Voor de Echeckwall worden soms updates gedaan. Informatie over updates is hieronder te vinden. 26-9-2022 Echeckwall kar verder verwerken op regulier echeckstation Karren die op een echeckwall geopend zijn, kunnen nu ook verder verwerkt worden op een echeckstation."
  },
  "Algemene-informatie/Apparaten/Echeckwall/index.html": {
    "href": "Algemene-informatie/Apparaten/Echeckwall/index.html",
    "title": "Echeckwall",
    "keywords": "Echeckwall Een Echeckwall wordt gebruikt om producten die in bulk gepickt zijn uit te sorteren tot M-orders die via de Echeck verwerkt kunnen worden. Op deze pagina als eerste een stukje over de werking van een echeckwall en daarnaa een stukje over de techniek achter de echeckwall.. Werking van de echeckwall ::: video ::: Mogelijke problemen bij de echeckwall ::: video ::: Vuistregel, verhouding vakjes echeckwall en aantal orders in pickroute Bij het werken met een echeckwall is het mooiste als er een balans ontstaat tussen picken, sorteren en echecken. Om dit te bereiken zou je vanuit de Echeck gedacht altijd voldoende volledig gesorteerde orders in de echeckwall willen hebben liggen. Maar vanuit het picken en sorteren gedacht zou je het liefst alle vakjes van de echeckwall leeg willen hebben. Om toch een balans tussen deze 2 tegenstrijdige wensen te bereiken, houden we meestal aan dat je als aantal orders in een pickroute de helft van het aantal vakjes van de echeckwall instelt. Heb je bijvoorbeeld 40 vakjes in de echeckwall beschikbaar, is het goed om het aantal M-orders in een bulkpickbak op 20 in te stellen. Hiermee wordt bereikt dat de sorteerder bij de echeckwall zo min mogelijk op de echecker hoeft te wachten en andersom. Instellingen In Gomonta kan ingesteld worden hoeveel orders er in de Echeckwall pickroute kunnen \"Echeckwall Aantal orders\". Meestal houden we hiervoor aan om niet hoger te gaan dan de helft van het aantal beschikbare vakjes in de Echeckwall. Daarnaast kan de vullingsgraad van de Echeckwall ingesteld worden \"Echeckwall Vullingsgraad\". Dit wordt voor zover ik weet niet meer gebruikt, omdat we nu met een stapelalgoritme uitrekenen of producten passen in een vakje of niet. De Echeckwall Vullingsgraad is dan alleen een soort fall-back mechanisme voor als het stapelalgoritme niet zou draaien. Er kan worden ingesteld dat S-orders niet worden meegenomen in een Echeckwall pickroute \"Maximale aantal S-orders in Echeckwall pickrout\". Stel je vult hier het getal 5 in, dan zouden S-orders meegepickt worden in de Echeckwall pickroute als er minder dan 5 S-orders open staan. Zijn er meer dan 5 S-orders, dan komen die S-orders in een aparte S-order pickroute. Het idee hier achter is dat boven een bepaald aantal S-orders het efficiënter is om ze als aparte S-orders te picken en direct naar de Echecktafel te brengen. En ook kan het maximale aantal items in een Echeckwall order worden ingesteld. Stel je hebt orders met meer dan 10 items en je denkt dat het efficiënter is die niet via de Echeckwall te verwerken, dan kun je dat hier instellen. https://gomonta.montapacking.nl/WMS/Shift/WarehouseSettings Een voorbeeld van zulke Put To Light instellingen is onderstaand te zien Klanten toevoegen in de echeckwall pickroute Via de onderstaande switch is het mogelijk of klanten toe te voegen of juist uit te sluiten van de echeckwall. Deze instelling is te vinden in gomonta; Kantoor; Relaties. Business Intelligence montaWCS Er wordt bijgehouden hoeveel orders gesorteerd zijn via een echeckwall en hoeveel jokers er zijn opgetreden. Deze informatie is in te zien via montaportal, onder het account van de vestiging waar de echeckwall staat. ********** De informatie hieronder is meer van technische aard ********** Technische informatie bij de Echeckwall Het systeem voor de Echeckwall bestaat uit verschillende onderdelen: Scanner In de scanner is een nieuwe picksize toegevoegd, namelijk Echeckwall. Deze is aan te zetten op verdieping niveau in de database Monta_Backend. Dit vinkje staat in tblMagazijnLocatieVerdieping kolom 'EcheckwallEnabled' (deze instelling wordt eenmalig als een echeckwall in een vestiging geplaatst wordt, direct in de tabel gedaan). Het maximale aantal orders per ronde is ingesteld op 30 orders. Dit is instelbaar in het outbound settings scherm in gomonta. Ook kan de Echeckwall gepicked worden met Need for Speed. Hierbij wordt de bulkkrat te de max gevuld met orders. Database In de database Monta_Backend zijn een aantal tabellen aangemaakt voor de Echeckwall, deze tabellen bevatten allemaal Echeckwall in de naam. Deze tabellen hebben dezelfde structuur als de Put-to-Light. Check and Sort De Echeckwall heeft een nieuwe UWP app, genaamd Check and Sort. Deze app is te vinden in Devops onder de repo: Echeckwall Check and Sort. In de app moet je een bulkkrat scannen, vervolgens worden de orders verdeeld over de lege locaties en kan er gesorteerd worden. Bij jokers moet iedere order aan een unieke blauwe krat gekoppeld worden. Ook is een mogelijk om een enkele order te sorteren via de Check and Sort. Hierbij wordt er een bulkpickbon gemaakt en vervolgens kunnen de producten in de echeckwalllocatie worden gelegd. De Check and Sort app draait op een NUC op de echeckwall. R-script product / vakjes afmetingen Er draait een taak die van nieuwe orders bekijkt in welk echeckwall vaktype ze passen. Er is een R-script voor die berekening. Heel soms draait dat R-script niet. Dat blijkt dan soms uit belletjes dat er ineens orders zijn die slecht passen in de echeckwall. Met deze query kan gecontroleerd worden welke orders open staan om door het R-script geanalyseerd te worden. select tblEorderPickingInfo.EorderID from tblEorderPickingInfo inner join tblEorder on tblEorderPickingInfo.EorderID = tblEorder.EorderID inner join tblEcheckWallLinkFloor on tblEcheckWallLinkFloor.VerdiepingId = tblEorderPickingInfo.VerdiepingID where EorderShippedDate is null and EcheckwallLocationTypeId is null and EorderSizeOfOrderText IN ('S', 'M', 'HM') and tblEorderPickingInfo.Aanmaakdatum < DateADD(mi, -5, GETDATE()) group by tblEorderPickingInfo.EorderID Bovenstaande query geeft altijd wel wat resultaten, maar als er meer dan 200 records als resultaat uit de query komen, is dat een indicatie dat het R-script niet goed gedraaid heeft. Herstarten van de Echeckwall service op de mp-proc02 is dan meestal de oplossing. Als je vragen vanaf de werkvloer krijgt dat er veel meer uglies zijn dan gebruikelijk, kan dat ook een indicatie zijn dat het R-script niet goed gedraaid heeft. ​​​​​​​ Het herstarten van het R-script is bekend bij David, Ruurd, Kevin en JohanV. Inpakken Aan de inpakkant wordt de normale echeck-app gebruikt. In principe kun je gewoon werken met een echeckwall door vanuit de Echeck-app een vakje van de echeckwall te scannen. De meeste vestigingen gebruiken die methode. Er kan echter ook voor gekozen worden een Echeck-station te verbinden aan een Echeckwall, dan bepaalt de Echeckwall de volgorde van de te echecken orders Om over te schakelen naar de echeckwall-modus. Moet een echeckstation gekoppeld zijn in tblEcheckWallStellingZones. In het hoofdmenu wordt nu een knop getoond 'Zoek order' ipv 'Scan krat'. Als er een order is gepakt vanuit de echeckwall, dan hoeven enkel de dragers gescand te worden en vervolgens kan de order worden afgerond. Hierbij zal worden gevraagd, hoeveel producten de order bevat. Wel is het mogelijk om alle producten te scannen als extra check. Hiervoor moet in tblMagazijnen het vinkje 'EcheckwallScanProducten' worden omgezet. Dan zal de echeck op de normale manier werken met als uitzondering de knop 'Zoek order'. Ledstrips Naast de atop-controllers is de echeckwall ook voorzien van ledstrips om het vak duidelijk te markeren. Hiervoor zijn 3 tabellen gemaakt in de database, namelijk: tblLedstripController tblLedstripMicroController tblLedstripNodes Voor in alle tabellen wordt de kolom Remark gebruikt om de juiste controller, microcontroller of node te vinden. Voor de controller wordt het deviceId gebruikt. Voor de microcontroller een 7-tallig nummer. Dit is te vinden in de logs in de EmbeddedDeviceManager. Voor de nodes moet een getal tussen de 0 en de 5 worden ingevuld. De ledstrips worden aangestuurd via een Pi met de app 'LedstripHandler'. De communicatie gaat via RabbitMQ, via de exchange 'LedStrip-Exchange'. Iedere Pi heeft een unieke queue. Vanuit de Check and Sort en de echeck worden er berichten gestuurd naar de Exchange om het vak te belichten of uit te zetten. Echeckwall supervisor Om de atop-knoppen te bedienen aan de inpakkant wordt er gebruik gemaakt van een Pi die hiermee verbonden is. Via RabbitMQ wordt gecommuniceerd, als een knop aangezet moet worden en wanneer deze wordt ingedrukt. Dit wordt per echeckstation geregistreerd en teruggestuurd. Hiervoor heeft de Echeckwall supervisor een exchange (EcheckWallSupervisor-Exchange). Verder heeft iedere supervisor een unieke queue. Voor de inpakkant is ook een exchange aangemaakt (EcheckWall_PackSide-Exchange). Hierbij heeft ieder station een unieke queue. Dit is zo gedaan, omdat maar één device verbinding kan maken met een atop-controller. Business Intelligence info Om in het montaWCS in montaportal weer te kunnen geven hoeveel orders een echeckwall verwerkt heeft en hoeveel jokers er waren, wordt deze informatie dagelijks geaggregeerd en opgeslagen in de monta_ai database op de MP-SQl06. De tabelnamen zijn: EcheckwallStats en EcheckwallPickroutes. Het script dat deze tabellen vult, draait op de proc02 via de WindowsService 'RScheduler'. De naam van dit script is EcheckwallStatistics. Instellen van nieuwe echeckwall in de database Het instellen van de adressen voor de atop lampjes en de ledstrips in de database is vrij complex. Daarom is er een software tool ontwikkeld om een groot deel van de complexiteit uit handen te nemen. Deze software draait op een laptop van de Technische Dienst. Meestal zal de Technische Dienst ook de afdeling zijn die nieuwe echeckwalls produceert en instelt. Martien Verhaar en Ruurd de Ronde kennen deze echeckwall instel software goed."
  },
  "Algemene-informatie/Apparaten/Goederenheffer/Instructie-en-documentatie-Goederenheffer/index.html": {
    "href": "Algemene-informatie/Apparaten/Goederenheffer/Instructie-en-documentatie-Goederenheffer/index.html",
    "title": "Instructie en documentatie Goederenheffer",
    "keywords": "Instructie en documentatie Goederenheffer De goederenheffers zijn geleverd door Stapro. Onderstaand is de documentatie van Stapro te vinden die ook als hardcopy bij de goederenheffers geleverd is. En naast onderstaande info, kun je via deze link ook de volledige PDF openen. 1. Technische specificaties 2. Gebruiksinstructies 3. Aansprakelijkheid 4. Onderhoudsinstructies 5. Onderdeeltekening 6. Elektrisch schema Documentatie PDF Documentatie Stapro.pdf"
  },
  "Algemene-informatie/Apparaten/Goederenheffer/index.html": {
    "href": "Algemene-informatie/Apparaten/Goederenheffer/index.html",
    "title": "Goederenheffer",
    "keywords": "Goederenheffer Goederenheffers worden gebruikt om goederen verticaal te transporteren tussen verdiepingen. De meeste goederenheffers zijn standalone systemen voor handmatige bediening. In Molenaarsgraaf zijn 2 goederenheffers automatisch en daarmee geschikt voor Montabots. Dit houdt in dat de bewegingen van de goederenheffers en de deuren vanuit de software aangestuurd wordt, waardoor de goederenheffers kunnen samenwerken met de Montabots. Documentatie Goederenheffers Stapro Stapro heeft bij de goederenheffers een map met Instructie en documentatie Goederenheffer geleverd. Deze is hier te vinden ********** De informatie hieronder is meer van technische aard ********** Technische informatie bij de Goederenheffer Het systeem voor de Montabot Goederenheffer bestaat uit verschillende onderdelen. Sigmatek ​​​​​​​PLC De Goederenheffer wordt aangestuurd door een Sigmatek PLC. Deze is ontwikkeld door Eurotec. Deze stuurt opdrachten naar de PLC van de Goederenheffer. MontabotHefferWindowsService De MontabotHefferWindowsService draait op de mp-proc03 (Eindhoven) en mp-app06 (Rotterdam). De service maakt een TCP verbinding met de PLC. De service kan de status van de Goederenheffer uitlezen en kan de Goederenheffer ​​​​​​​een opdracht sturen. Dit zijn de volgende opdrachten: Naar een verdieping gaan, deur openen of deur sluiten. Montabot service De MontabotHefferWindowsService stuurt de status van de Goederenheffer door naar de Montabot service via RabbitMQ. De exchange heet 'Lift-Exchange'. De Montabot service kan de opdrachten verdelen over de Goederenheffers. Ook wordt door de Montabot service de rekken in de Goederenheffer gezet en vervolgens eruit gehaald op een andere verdieping."
  },
  "Algemene-informatie/Apparaten/Kioskmode-op-productie-computers/index.html": {
    "href": "Algemene-informatie/Apparaten/Kioskmode-op-productie-computers/index.html",
    "title": "Kioskmode op productie computers",
    "keywords": "Kioskmode op productie computers Inleiding, Op de computers in de productieomgeving van Monta is een Kioskmode uitgerold om het werken met de computers te beveiligen en te vereenvoudigen. Alle functies die gebruikt kunnen worden zijn vanaf de desktop op te starten. Monta Apps, In het vakje “Monta Apps” vind je de applicaties die gerelateerd zijn aan Monta. Denk hierbij aan: Monta Echeck Monta Inbound Monta Retourverwerken MontaPortal GoMonta Afhankelijk wat de functie van de computer is (Echeck, Inbound of Retour) start de applicatie automatisch op. Diverse Apps, In het vakje “Diverse Apps” vind je de applicaties die verder nog gebruikt kunnen worden op de productie computer. Denk hierbij aan: Bedrijfsportal Rekenmachine Camera, o.a. voor het Inbound-process Office 365, dit is een link naar de webversie van Microsoft Office 365 en is alleen te gebruiken door collega’s die ook een Microsoft account hebben van Monta. Google, Zoekmachine Afdrukbeheer, voor het toevoegen van een lokale printer. Neem voor meer info contact op met de Servicedesk. Internet Browsers, In het vakje “Internet Browsers” vind je de applicaties die gerelateerd zijn aan Monta. Het internet in de Montakiosk heeft restricties. Kun je een website van een klant niet bezoeken geef dit dan per email door aan de Servicedesk."
  },
  "Algemene-informatie/Apparaten/Label-Applicator-(S-Lane)/index.html": {
    "href": "Algemene-informatie/Apparaten/Label-Applicator-(S-Lane)/index.html",
    "title": "Label Applicator (S Lane)",
    "keywords": "Label Applicator (S Lane) S-Lane sticker applicator Als een product in eigen verpakking verzonden mag worden, kan het handig zijn om gebruik te maken van een automatische S-Lane. Bij deze manier van echecken wordt het verzendlabel automatisch op de doos van het product geplakt. Hierdoor zit het label altijd recht, en op de zelfde plek op de doos. Het echeck proces is bijna hetzelfde als S bulk echecken. Zorg ervoor dat je bij het picken sorteert op de juiste klant. Het is namelijk niet handig als je producten in moet pakken in een drager bij dit proces. Bij het verwerken scan je de producten 1 voor 1. Na het scannen plaats je het product op de rollenbaan, en duw je het tegen de achtergeleiding. Vervolgens duw je het product over de rollenbaan, tot deze gaat draaien. Je kunt nu verder met het volgende product. De stickerkop plakt automatisch het label op het product. ********** De informatie hieronder is meer van technische aard ********** Technische informatie bij de Label Applicator De S-Lane is een gewoon echeckstation waar een lokale printer op geïnstalleerd is. Bij het instellen van het station is deze printer gekozen als labelprinter. S-Lane 1 in Breda is uitgevoerd met een Codipack labelapplicator met een Evolabel t43 printer. De driver voor deze printer is lokaal geïnstalleerd. Er is geen koppeling tussen de echeck en de rollenbaan. De baan gaat draaien zodra de sensor een product ziet. De printer zit via een lokaal netwerk verbonden met de MONPC. De printer heeft het vaste ipadress 172.19.7.180. De MONPC heeft een vast ipadress 172.19.7.179. Beide hebben een subnetmask van 255.255.0.0 Het is van belang dat de standaardgateway bij beide devices wordt ingevuld, anders kunnen ze elkaar niet vinden bij het installeren van de drivers. De standaardgateway is 172.19.7.1 Evolabel QuickTamp G2 Applicator (SW G2) Manual 2.5.0 EN.pdf Evolabel User Manual (SW G2) - 2.1.0 - nl.pdf"
  },
  "Algemene-informatie/Apparaten/LedControl-handleiding/index.html": {
    "href": "Algemene-informatie/Apparaten/LedControl-handleiding/index.html",
    "title": "LedControl handleiding",
    "keywords": "LedControl handleiding Dit is de handleiding om een LedControl systeem op te zetten. Benodigde hardware Voeding Ledcontrollers Ledstrips Pc Gebruik een voeding die het wattage van de ledstrip aan kan! (Voor de Havana pixel strip is dit 14,4W per meter) Sluit de voeding als volgt aan op de ledcontroller en de ledstrips om knipperen van de ledstrips te voorkomen: LedController instellingen Showtec SPI-2 Install De instellingen van de ledcontroller kunnen gedaan worden op de controller zelf of via de webpagina van de controller. Neem de volgende instellingen over Vul bij LED Quantity het aantal meter van de ledstrip keer 10 (elke 10 centimeter is apart aanstuurbaar). Let op dat de Universe bij de 2 ports verschillend zijn, DMX Address maakt niet uit. Als er niets is aangesloten op een van de uitgangen vul 1 in bij LED Quantity 0 is niet toegestaan. Volledige handleiding: https://www.highlite.com/en/mwdownloads/download/link/id/17426620/ Showtec NET-2/3 Pocket Ook deze controller heeft een web interface wat het instellen wat makkelijker maakt. De username is Admin en het wachtwoord is Admin. Neem de volgende instellingen over: Let weer goed op bij Network dat deze verschilt bij de 2 uitgangen. Volledige handleiding: https://www.huss-licht-ton.de/images/products_download/Manual_34954_1.pdf Bij het instellen van DMX adressen in de lampen is het belangrijk dat er goed doorgeteld wordt. Bijvoorbeeld 2 lampen met 3 adressen, lamp 1 start op adres 1, lamp 2 start op adres 4, enzovoorts. Belangrijk! bij beide uitgangen wordt er begonnen met tellen vanaf 1. Database instellingen Controllers instellen De tabellen staan in de Monta_Backend database De eerste tabel die ingesteld moet worden is tblDmxController Het LocalIpAddress is niet verplicht om in te vullen Vervolgens kan de tabel tblDmxUniverses ingesteld worden In deze tabel moet voor elke uitgang van de controller een rij toegevoegd worden, voorbeeld: Het ControllerId is het Id uit tabel tblDmxController De waardes Universe en SegmentQty komt overeen met de instelling in de controller. De waarde Order kan gebuikt worden om aan te geven welke uitgang eerst komt zoals bij een trap. Groepen maken In de tabel tblDmxWarehouseGroup kunnen nu groepen gemaakt worden. De Name die hier ingesteld wordt is ook de naam die op MontaPortal getoond wordt. Met IsActive kan een groep aan of uit gezet worden Nu we de groepen hebben kunnen er subgroepen gemaakt worden in de tabel tblDmxGroups. De DisplayName die hier ingesteld wordt is ook de naam die op MontaPortal getoond wordt. Het GroupId is het Id uit de tabel tblDmxWarehouseGroup. Het GroupTypeId kan meerdere waardes hebben hieronder een lijst van de mogelijkheden 1 = controller, de groep bestaat uit een volledige uitgang 2 = segmenten, de groep bestaat uit bepaalde segmenten van controlleruitgangen 3 = sensoren, de groep bestaat uit segmenten en is specifiek bedoeld voor LedSensorControl 4 = dmx kanalen, de groep (of eigenlijk lamp) bestaat uit een aantal kanalen, altijd 3 of 4! Het ControllerId moet altijd ingevuld worden, dit kunnen er ook meerdere zijn. De Segments hoeven alleen bij GroupTypeId 2 en 3 ingevuld worden. Een aantal segmenten kan bij elkaar horen zoals bij een traptrede. Om dit te doen kun je de segmenten zo noteren: Bij elkaar horende segmenten worden doorgeteld met - en gescheiden segmenten door ,. Om segmenten goed aan te sturen moeten de segmenten doorgeteld worden, als er 4 uitgangen gebruikt worden (2 controllers) begin je dus niet overnieuw met tellen bij een volgende uitgang maar wordt er doorgeteld. De Channels wordt alleen ingevuld bij GrouptypeId 4. Kanalen worden alleen gescheiden door , en kunnen alleen bestaan uit 3 of 4 kanalen (RGB en RGBW) Controllers kunnen bij meerdere groepen horen mits die groepen hetzelfde GroupTypeId hebben. Scenes In de tabel tblDmxWarehouseScenes staan de scenes die gemaakt kunnen worden in MontaPortal. Hier is het niet nodig om iets toe te voegen. MontaPortal In MontaPortal moet er een thumbnail worden toegevoegd om duidelijk te maken waar de verlichting zicht bevindt. Deze afbeelding moet dezelfde naam hebben als de Name zoals die in de database in tabel tblDmxWarehouseGroup staat. De afbeelding moet in de map \\\\mp-web320.montapacking.nl\\cdn.montaportal.nl\\PublicFiles\\Images\\Hardware afbeeldingen\\LedControl staan. (Graag zoveel mogelijk in dezelfde stijl als Molenaarsgraaf) Lokale PC Om het LedControl programma te kunnen runnen moet er een pc lokaal in het pand zijn om de ledcontrollers aan te sturen. Het programma LedControl moet met 1 argument aangeroepen worden, dit argument is het WarehouseId waar de pc zich bevindt. Bij het LedSensorControl programma hoeft dat niet omdat dit programma specifiek voor Molenaarsgraaf is en niet op andere locaties wordt gebruikt. De Pc moet toegang hebben tot MontaWebserviceREST en de ledcontrollers."
  },
  "Algemene-informatie/Apparaten/LedControl/index.html": {
    "href": "Algemene-informatie/Apparaten/LedControl/index.html",
    "title": "LedControl",
    "keywords": "LedControl LedControl is een systeem dat gebruikt wordt om alle sfeer / effect verlichting in en rond het pand aan te sturen. Met dit systeem kunnen kleuren, effecten en werk tijden ingesteld worden. Waar kunnen de instellingen gedaan worden? In MontaPortal onder WCS is een apart kopje gemaakt voor LedControl: Op deze pagina zie je alle groepen en welke kleur deze hebben. Ook kunnen er scenes gemaakt en verwijderd worden. Om een nieuwe scene te maken druk je op de knop \"Nieuwe scene\", je ziet dan een pop up venster met de vraag welke naam de scene moet krijgen. Het systeem kopieert de huidige instellingen naar de nieuwe scene. Wanneer er meerdere scenes zijn kan er gewisseld worden tussen scenes. Om instellingen van een groep te veranderen druk je op instellingen, je ziet dan de volgende pagina: Hier kan je de kleur voor de hele groep aanpassen of de kleur per subgroup. Ook kan je effecten kiezen die voor de hele groep gelden, bijvoorbeeld het regenboog effect. Wanneer er meerdere effecten gekozen kunnen worden, kan er maar 1 actief zijn. Als er op het timer symbool wordt gedrukt opent de volgende tabel: Hier kan er per dag aangegeven worden of de verlichting in die groep aan moet staan. (Let wel op dat de eindtijd niet later mag zijn dan de begin tijd). De sluimerschakelaar zorgt ervoor dat de verlichting uit gaat 1 uur na zonsopgang en weer aan 1 uur voor zonsondergang, mist er tijden zijn ingesteld. Als de dag aan is gezet maar er zijn geen tijden ingevuld dan zal de verlichting de hele dag en nacht branden. Als er bij subgroepen verschillende kleuren worden gekozen dan kan je dit ook zien op de hoofdpagina wordt dit ook aangepast op de hoofdpagina: ********** De informatie hieronder is meer van technische aard ********** Technische informatie bij LedControl Tabelstructuur de tabellen voor LedControl staan in Monta_Backend Database Hierin worden scenes, controllers, groepen en subgroepen opgeslagen. Lees de handleiding hoe je dit in moet stellen. Hardware De voorkeur ledstrip gaat naar de Artecta Havana Pixel Strip RGB 24V. De voorkeur ledcontroller om ledstrips aan te sturen gaat naar de Showtec SPI II Install. Deze controller kan 2 keer 17 meter van de pixel ledstrip aansturen. De voorkeur ledcontroller om led lampen (dmx) aan te sturen gaat naar de Showtec NET-2/3 Pocket. Structuur Hieronder is de structuur die LedControl gebruikt aangegeven: De software LedControl en specifiek voor Molenaarsfraaf LedSensorControl moeten lokaal in het pand draaien en toegang hebben tot de LedControllers en indien nodig een PLC. Deze pc moet ook rabbitmq kunnen bereiken. In Molenaarsgraaf staat deze pc in de bioscoop."
  },
  "Algemene-informatie/Apparaten/Machine-Whisperer/index.html": {
    "href": "Algemene-informatie/Apparaten/Machine-Whisperer/index.html",
    "title": "Machine Whisperer",
    "keywords": "Machine Whisperer Wat is de Machine Whisperer? Met de MachineWhisperer is het mogelijk om met PLC's te communiceren en hieruit Notificaties te maken die vervolgens worden opgeslagen en goed beschikbaar zijn via een API. De mobiele applicatie toont vervolgens de data Figuur 1 globaal overzicht Technische hoofdstukken Overzicht van de onderdelen binnen het Machinewhisperer project: De PLCInterpeter interpreteert data uit een de interne database van een PLC naar notificaties die in de PLCInterpreter kunnen worden ingesteld. Backend Machinewhisperer API GraphQL service Frontend Mobile applicatie Instellingen GoMonta Personeelsplanning Taakverdeling voor rollen MontaPortal Instellingen scherm PLCInterpreter In Figuur 1 is het overzicht van de backend en frontend van de applicatie, zonder instellingen om het overzichterlijker te houden. De MachineWhisperer API maakt gebruik van de database MontaMachineWhisperer op de server: mp-dev02.montapacking.nl. De API is vervolgens te vinden op https://machinewhisperer.monta.nl/api/swagger/index.html. De Mobile app maakt, echter geen direct gebruik van de API. De mobile app maakt gebruik van de GraphQL service. Deze service is te vinden op https://machinewhisperer.monta.nl/graphql/. Hierdoor kan data uit meerdere API's gecombineerd worden tot een request. De Mobile app is in Visual Studio te builden via de standaard manier om Xamarin apps te builden. Plek op het net - waar is welk project? De projecten zijn opgeslagen in 4 repositories die op de Azure Devops van Monta zijn opgeslagen. MachineWhispererAndroid https://dev.azure.com/MontaDevelopment/Montapacking/_git/MachineWhispererAndroid (Development branch) MachineWhispererAPI https://dev.azure.com/MontaDevelopment/Montapacking/_git/MachineWhisperer (Development branch) MachineWhispererPLC https://dev.azure.com/MontaDevelopment/Montapacking/_git/MachineWhispererPLC (Development branch) MachineWhispererGraphQL https://dev.azure.com/MontaDevelopment/Montapacking/_git/MachineWhispererGraphQL (Development branch) Daarbuiten zijn er nog drie Monta sites die zijn aangepast voor het instellen van verschillende instellingen. MontaPortal - Site waar binnen het WCS een settings knop is toegevoegd, deze pagina is nog niet afgemaakt en staat nog niet live, de niet afgemaakte versie is vindbaar op: click onder de branchnaam feature/machinewhisperer MontaRestAPI - Backend API, die gebruikt wordt om Personeelsdata uit de personeelsplanning te halen. GoMonta - Site, waar in de personeelsplanning OperatorRole aan een gebruiker kan worden gegeven. Video met instructies hoe een nieuwe operator kan worden toegevoegd is hieronder toegevoegd, het nummer is gelijk aan de UserRoleId uit de MachineWhispererAPI. Hoe werkt het per Project? ###MachineWhispererAPI MachineWhisperAPI is een .NET6 MVC project. de Models zitten in het Data project file, als aparte project file aangezien de models kunnen worden hergebruikt in de andere projecten (Maar dit gebeurt momenteel niet). De database wordt in deze applicatie benaderd en wordt a.d.h.v. Entity Framework met het Code First principe bijgehouden. Al wil je de API testen kun je getters op https://machinewhisperer.monta.nl/api/swagger/index.html testen, of Posts doen. Bij posts moeten alle ID's ingevuld zijn met een bestaand ID, dus daar moet rekening mee worden gehouden voor het testen. In de afbeelding hierboven is te zien welke Controllers er in het project zijn. In de rest van dit hoofdstuk wordt kort per Controller beschreven wat het doel is en wat extra informatie gegeven, als dat relevant is. Employee is de user van de app. Belangrijkste attribuut is de MontaId, wat het Id is waarmee de gebruiker wordt opgezocht in de MontaRestAPI, daarbuiten wordt de naam van de employee opgehaald vanuit de personeelsplanning. Voorderest is de employee nog niet veel gebruikt aangezien er nog niet bij wordt gehouden wie welke notificatie op zich neemt. LinkNotification wordt geset vanuit het MontaPortal instellingenscherm, hierin kan de description of het verantwoordelijke UserRoleId van een notificatie worden veranderd per afdeling. Machine is de algemene data over een specifieke Machine. MachineType is een groep Machines. NotificationAlert is een ALERT, dit is een kort bericht die de noodzakelijkheid van een Notificatie kan aantonen: bijvoorbeeld een alert kan ERROR of WARNING zijn. NotificationType is het type Notification, Het type notificatie wordt samen met de Alert in de PLCInterpreter per Notificatie meegegeven en verteld zo specifiek mogelijk wat de status van een machine is. Notification is de klasse UserRole is de manier hoe Users meestal worden benaderd, notificaties worden naar UserRoles gestuurd en niet naar individuele user bijvoorbeeld. In de bovenstaande afbeelding is te zien welke manier de verbindingen tussen de Settingspage(MontaPortal) en de peroneelsplanning(GoMonta) zich verhouden. De settingspage veranderd de LinkNotification, waar per NotificationId kan worden ingesteld welke UserRoleId bij een NotificationId hoort. Echter is deze functionaliteit nog niet geheel geïmplementeerd, momenteel wordt data uit de LinkNotification nog niet gebruikt in het kiezen van de UserRole, wel wordt de LinkNotification aangemaakt, wanneer een nieuwe notificatie wordt gecreëerd. Deployment De deployment pipeline is op de MontaDevelopment Azure te vinden onder de naam \"MachineWhisperer\". De release pipeline is \"MachineWhisperer_Prod\" en is een gedeelde Release met de GraphQL Release pipeline. De API en GraphQL worden samen gehost onder hetzelfde webadres (https://machinewhisperer.monta.nl) intern worden ze gelijk gehost op het subdirectory /api en /graphql voor de API en GraphQL respectievelijk, hierdoor hoeft dat in de applicatie zelf niet te worden aangegeven, lokaal draaien de services daardoor niet op een subdirectory GraphQL GraphQL service is een query language, waardoor er gemakkelijk nieuwe requests kunnen worden gemaakt. De GraphQL service maakt gebruik van de MachineWhispererAPI en de MontaRestAPI (De API die o.a. de personeelplanning beschikbaar stelt) en combineert dit tot een request voor de client. Er is onderscheid tussen Queries en Mutations, dit is ook zichtbaar in de klasse in de app. In de Queries klasse zitten alle GET request en in de Mutations klasse zitten alle requests die data aanpassen. Android Xamarin app Xamarin Android applicatie is een MVVM project. PLCInterpreter PLC interpreter is een service die naar het IP van een aangesloten PLC kan luisteren en op basis van welke values er in de interne database van de PLC zijn kan worden ingesteld welke Type notificatie wordt verstuurd. MontaPLCControl is een algemene .sln dat het lezen van PLC's wat gemakkelijker maakt. De logica van de applicatie is te vinden in PLCInterpreter .sln. Belangrijk is dat het juiste type PLC wordt geselecteerd, bij het testen is de S7-1200 gebruikt. Standaard kijkt de Interpreter naar de eerste 2 plekjes in de database memory of de value true of false is. Todo lijst ###Mobile app OidcCallbackActivity in het project MachineWhisper.Android en de klasse OidcCallbackActivity wordt gebruik gemaakt van de DataScheme van de medewerkersapp, wat is gekopieerd uit de medewerkersapp. Dit werkt als het de enige app is op een telefoon. Maar is mogelijk niet wenselijk voor de toekomst, in dat geval moet de MachineWhisperer app een eigen Datascheme krijgen. Een ander probleem is dat in de huidige versie als de MedewerkersApp en Machinewhisperer app beide zijn geinstalleerd blijft de telefoon vragen welke OidcCallbackActivity de gebruiker wilt gebruiken, die van de Medewerkersapp of van de Machinewhisperer. Waarschijnlijk kan dit ook opgelost worden door een eigen Datascheme te maken per app. Notificatie Afronden Momenteel is het afronden van een Notificatie gedaan door een button, vervolgens is de Notificatie inactief en dus verwijderd. De uiteindelijke oplossing vereist een oplospagina waar eventueel tekst en foto's kunnen toegevoegd bij het oplossen van een notificatie. ###MontaPortal UI maken In de Montaportal Settings page zijn pagina's en methodes aangemaakt voor het verwijderen en toevoegen van nieuwe machines en notificaties, echter is de UI nog niet aanwezig, buiten wat test UI. Dit moet nog worden geimplementeerd"
  },
  "Algemene-informatie/Apparaten/Monta-Pacman/Gebruik-en-schoonhouden-van-Monta-Pacman/index.html": {
    "href": "Algemene-informatie/Apparaten/Monta-Pacman/Gebruik-en-schoonhouden-van-Monta-Pacman/index.html",
    "title": "Gebruik en schoonhouden van Monta Pacman",
    "keywords": "Gebruik en schoonhouden van Monta Pacman Monta Pacman is een verpakkingsmachine die momenteel in Lelystad gebruikt wordt. Op deze pagina zijn instructies en video's te vinden voor het gebruiken en schoonmaken van de Monta Pacman Quick reference guide De Quick reference guide als PDF te zien, zodat je kunt printen of inzoomen. Quick Reference.pdf Algemene machine bediening gegevens Onderstaand zijn video's te vinden over voorkomende werkzaamheden bij de Monta Pacman machine Gevaren symbolen Overzicht van machine met benamingen Linker en rechter operator Aanzetten en uitzetten van de machine Hoofdbedieningspaneel Bedienings modus Verbruiksmaterialen De machine heeft verschillende soorten verbruiksmaterialen. Karton, Tape en Verzendetiketten. Laden karton Laden karton vaste molen Laden karton variabele molen Tape Vervangen van tape Nieuw tape Labels Filmpjes en instructies voor Evolabel label printer zijn aangevraagd (Bart Lucht heeft dit gevraagd bij Michel van Sparck) Orders verwerken In dit gedeelte worden wat zaken beschreven die van belang zijn tijdens het verwerken van orders. Schermen rondom orderverwerking. Instructies voor het plaatsen van de producten. Errors afhandelen In dit deel worden enkele errors beschreven en wordt uitleg gegevens hoe de errors het beste afgehandeld kunnen worden. Allereerst wat toelichting over de typen meldingen die kunnen voorkomen. Indicator lamp op de invoer lopende band @kevin, graag hier filmpje invoegen van pagina 31 van de presentatie \"How to Operate Impack v1.pptx\" uit map RandD - General\\Verpakkingsmachines\\Sparck - Quadient Dual induct station control panel: Control cardbord feed: Control panel 3D scanner: Control panel Insert Position: Control panel Taper Position: Remove cardbord after jam in Cut & Crease Orders verwijderen (top support) Orders en tape verwijderen (taper unit) Onderhoud In dit gedeelte wordt aangegeven hoe de machine het best onderhouden kan worden. Dagelijks Schoonmaken door Operator Dagelijks schoonhouden Cut & Crease Dagelijks schoonhouden S-curve Dagelijks onderhoud folder-inserter Dagelijks onderhoud top-support Dagelijks onderhoud taper Dagelijks onderhoud waste conveyor Schoonmaken door Technische Dienst"
  },
  "Algemene-informatie/Apparaten/Monta-Pacman/index.html": {
    "href": "Algemene-informatie/Apparaten/Monta-Pacman/index.html",
    "title": "Monta Pacman",
    "keywords": "Monta Pacman Monta Pacman is de naam van een verpakkingsmachine. Deze verpakkingsmachine kan dozen op maat maken door de producten van een order te meten en op basis daarvan een doos van het juiste formaat te maken. Onderstaand een video die de werking van de Monta Pacman laat zien. ::: video ::: Instructies over gebruik en schoonhouden van de machine. Klik hier voor een aparte pagina over het gebruik en het schoonhouden van de Monta Pacman machine. Pickstroomfilter voor Monta Pacman De Monta Pacman heeft een minimale en maximale afmeting voor producten binnen een order. Grofweg is de minimale afmeting (binnenkant doos) 18 cm x 24 cm x 10 cm (Lengte x Breedte x Hoogte). De maximale afmeting is afhankelijk van welke rollen karton er gekozen zijn, het maximum van de machine is (binnenkant doos) 60cm x 60cm x 35cm (Lengte x Breedte x Hoogte). Om ervoor te zorgen dat alleen orders die binnen deze afmetingen vallen naar de Monta Pacman toe gaan, is een nieuw pickstroom filter gedefinieerd. Het Monta Pacman pickstroom filter. Zie voor uitgebreider informatie over dit filter deze pagina In GoMonta kan per klant worden ingesteld of de orders in de Monta Pacman pickstroom terecht mogen komen. Ook kan per klant het maximaal aantal items per order worden ingesteld. In GoMonta kan bij de magazijn outbound instellingen worden ingesteld, wat het maximale gewicht is van een order. Ook kan er worden ingesteld, dat een waarschuwing in de e-echeck wordt gegeven, als de orders geschikt is voor buspost. Als laatste kan worden ingesteld of orders, die in eigen verpakking verzonden mogen worden, in de Monta Pacman pickstroom terecht komen. https://gomonta.montapacking.nl/WMS/Shift/WarehouseSettings#MontaPacMan Echeck voor Monta Pacman De Monta Pacman heeft 2 zogeheten induct stations. Dit zijn de plaatsen waar producten op de machine gelegd kunnen worden. Op die plekken staat ook een Echeck station, waarmee de orders binnen het montaWMS ge-echeckt worden. In de Echeck schermen is duidelijk te herkennen dat het om een Echeckstation bij de Monta Pacman machine gaat doordat er een afbeelding van de Monta Pacman machine te zien is. Jokers De Monta Pacman machine kan een aantal orders gelijktijdig op de lopende band hebben liggen. De Monta Pacman kan storingen hebben. Denk aan een mislukte verpakking, of producten die zijn gaan schuiven op de lopende band. In dat geval geeft de Monta Pacman in de software door dat er een storing is. In de schermen die op de Monta Pacman zelf zitten is te dien op welke positie(s) in de Monta Pacman machine de storing is. Dan is er de behoefte om de producten uit de machine te halen. Op dat moment willen we de producten graag bij elkaar houden met de orderinformatie. Omdat we voor veel klanten zonder papieren pakbon verzenden, wordt een joker geprint om de producten te markeren bij welke order ze horen. Soms kunnen meerdere orders tegelijk storing hebben. Om dan het juiste joker label te gebruiken bij de juiste producten, is een joker label gemaakt waar ook de product barcodes en benaming op staan. Voorbeeld van een joker label van een order met 1 product Voorbeeld van een storing die wordt weergegeven in het scherm van de Monta Pacman machine Business Intelligence montaWCS Er wordt bijgehouden hoeveel orders verpakt zijn door de Monta Pacman en hoeveel jokers er zijn opgetreden. Deze informatie is in te zien via montaportal, onder het account van de vestiging waar de machine staat. (plaatje nog updaten als er meer te zien is) [[Doelgroep: IT ********** De informatie hieronder is meer van technische aard ********** Technische informatie bij de Monta Pacman Onderstaand worden wat zaken toegelicht zodat de structuur van de software rondom de Monta Pacman helder is. Echeckstation gekoppeld aan Monta Pacman De tabel waar een echeckstation aan een Monta Pacman machine wordt gekoppeld is in de Monta_Backend database te vinden. De naam van de tabel is tblMontapacker Een Monta Pacman kan 2 echeckstations hebben, omdat er 2 inductstations op de machine zitten waar producten neergelegd kunnen worden. Afmetingen en gewicht Doordat de Monta Pacman de producten opmeet voordat de verzend doos op maat gemaakt wordt, kunnen deze afmetingen en het gewicht gebruikt worden bij het kiezen van de verzender en het aanvragen van het verzendlabel. De gemeten afmetingen en gewicht worden opgeslagen in tblEcheckedShippingBoxes. Pickstroom Om ervoor te zorgen dat alleen orders met passende producten bij de Monta Pacman terecht komen, is er een aparte pickstroom voor gemaakt. Voor de berekening of de producten van een order passen in de formaat dozen die de Montapacker machine kan maken, wordt gebruik gemaakt van een stapel algoritme. Dit algoritme zit in het MontaModel in de map ContainerPacking. Als een order geschikt is voor de Monta Pacman , dan wordt de ReadyToPickState op Monta Pacman gezet. Dit wordt gedaan bij het verifiëren van de order. Jokers Voor de Monta Pacman is een apart joker type gemaakt en is een apart joker label ontwikkeld waarop ook de product informatie te zien is, zodat het joker label bij de juiste producten/order gebruikt kan worden. tblEcheckJokerType Business Intelligence info Om in het montaWCS in montaportal weer te kunnen geven hoeveel orders de Monta Pacman verwerkt heeft en hoeveel jokers er waren, wordt deze informatie dagelijks geaggregeerd en opgeslagen in de monta_ai database op de MP-SQl06. De tabelnaam is MontapackerStats. Het script dat deze tabellen vult, draait op de proc02 via de WindowsService 'ScheduleR'. De naam van dit script is MontapackerStatistics. Montapacker service Voor de Monta Pacman is een webservice ontwikkeld, namelijk https://montapacker.monta.nl. Deze webservice handelt vragen van de Monta Pacman af. De webservice draait op de mp-web115 en als back-up op de mp-web215. De orders die ge-echecked zijn, worden in een RabbitMQ queue gezet. De exchange naam is MontapackerService. Ieder Montapackerstation heeft een eigen queue. Hierbij is het MachineId de routingkey. Monta Pacman video's De Monta Pacman machine neemt video's op. Dit zijn per verpakking twee video's. Integrity video Shipment video De integrity video laat het inpakproces zien. Daarbij is bijvoorbeeld te zien of alle producten in de verpakking gaan. Deze video is ongeveer 15Mb De Shipment video laat het ingepakte pakket zien. Deze video is ca 5 Mb. Bij vol bedrijf van de machine, is het heel wat data die opgeslagen moet worden. Daarom is er in het Lelystad netwerk lokaal een NAS geplaatst met voldoende schijfruimte voor 6 maanden aan video. \\\\ley21-nas01.montapacking.nl\\Shipment \\\\ley21-nas01.montapacking.nl\\Integrity We zijn nog bezig te kijken hoe en waar we deze video's willen ontsluiten. En ook het verwijderen van de video's binnen 6 maanden zal dan geregeld worden. Verzenddoos beheer Voor de Monta Pacman wordt een standaard verzenddoos aangemaakt. Deze wordt toegevoegd aan alle kanalen, die gekoppeld zijn aan het magazijn. Deze verzenddoos wordt altijd gekozen in de e-check. Om de verzenddoos automatisch te scannem, moet de barcode ingevuld worden in tblMontapacker kolom ShippingBoxBarcode. Bij de Monta Pacman kan worden ingesteld, dat op basis van het volume de juiste verzenddoos categorie wordt gekozen. Deze verzenddoos zal de standaard Monta Pacmanverzendoos vervangen, zodra de order verzonden is. Deze drager zal vervolgens op de factuur staan voor de klant. Deze functionaliteit kan worden aangezet in tblMagazijnen kolom MontapackerCalculateCupboard. Vervolgens moeten de verzenddozen worden gekoppeld aan de Monta Pacman in tblMontapackerDrager. Deze verzenddozen moeten worden aangemaakt in GoMonta."
  },
  "Algemene-informatie/Apparaten/MontaCast/index.html": {
    "href": "Algemene-informatie/Apparaten/MontaCast/index.html",
    "title": "MontaCast",
    "keywords": "MontaCast Wat is de Montacast? De Montacast bestaat uit een kleine computer (Intel celeron nuc) die achter een TV gemonteerd kan worden en verschillende dashboards in carrouselvorm kan weergeven. De Montacast wordt gebruikt om (onder andere) logistieke informatie weer te geven op beeldschermen, zoals in een magazijn of op kantoor. Het systeem is beschikbaar voor zowel Monta zelf, als voor WMS-klanten. Er is een mogelijkheid om meerdere dashboards te tonen op één scherm, middels de zogenoemde 'carrousel'-functionaliteit. Hiermee kunnen er achter elkaar verschillende dashboards worden getoond op hetzelfde beeldscherm met een instelbare interval. In dit geval zal er onderaan het scherm een timer-balk getoond worden die de timing van de carrousel aangeeft. Dit is op de onderstaande afbeelding aangeduid. Momenteel kunnen de volgende dashboards getoond worden: 10-Inbound dashboard 10.1-Inbound dashboard large 20-Outbound dashboard 20.1-Outbound scherm (Large) 21.1-Werkverdeling per afhaaltijd dashboard 21.2-Werkverdeling per type order dashboard 21.3-Werkverdeling per klant dashboard 21.4-Werkverdeling per kanaal dashboard 21.5-Werkverdeling per verdieping dashboard 22-MontaPacMan dashboard 23-EcheckToLight dashboard 28-MontaSorter dashboard 30-Performance dashboard 31-Scanner beheer 32-Joker dashboard 40-Monta neuws 41-Gamification dashboard 42-Website pagina weergave 43-Welkom scherm 90-Montacast Health dashboard (scherm voor IT afdelingen) 91-Killswitches status (Scherm voor IT afdelingen) Bij onderstaande schermafdrukken zul je soms Nederlands zien en soms Engels als taal. Een van deze talen kan gekozen worden bij het instellen van het MontaCast dashboard. Momenteel zijn de beschikbare talen; Engels, Nederlands, Duits en Frans. Welke schermen zijn er en hoe zien de schermen eruit? Momenteel kan er gekozen worden uit de volgende schermen: 10-Inbound dashboard In dit scherm zijn het aantal openstaande en verlate TT's (koppellabels) per relatie te zien. 10.1-Inbound dashboard Large In dit scherm wordt dezelfde informatie getoond als op het inbound dashboard, maar ingezoomd. Dit is geschikt voor magazijnen waar de TV's zo hoog hangen dat de informatie anders niet leesbaar zou zijn. Keerzijde van het zo groot weergeven van de informatie is uiteraard dat er minder informatie op het TV scherm past. Op deze manier kun je kiezen wat het beste past bij de situatie in je magazijn. 20-Outbound dashboard In dit scherm zijn alle openstaande, verzonden, verlate en toekomstige orderregels te zien per relatie. Bij langere lijsten zal dit scherm automatisch naar beneden scrollen. 20.1-Outbound scherm Large In dit scherm wordt dezelfde informatie getoond als op het outbound scherm, maar ingezoomd voor bijvoorbeeld hooggeplaatste schermen. 21.1-Werkverdeling per afhaaltijd dashboard Dit dashboard toont de werkverdeling per afhaaltijd van de te verwerken orderregels over de verschillende outboundactiviteiten, zoals het picken, sorteren (consolideren) en verpakken. Dit dashboard heeft als extraatje dat je een filter op Relatie (Klant) kunt instellen. Heb je bijvoorbeeld een speciaal proces rondom 1 Relatie, dan kun je van die specifieke Relatie zien op welke afhaaltijden er nog orders verwerkt moeten worden. 21.2-Werkverdeling per type order dashboard Dit dashboard toont de werkverdeling per type order van de te verwerken orderregels over de verschillende outboundactiviteiten, zoals het picken, sorteren (consolideren) en verpakken. 21.3-Werkverdeling per klant dashboard Dit dashboard toont de werkverdeling per relatie/klant van de te verwerken orderregels over de verschillende outboundactiviteiten, zoals het picken, sorteren (consolideren) en verpakken. 21.4-Werkverdeling per kanaal dashboard (komt week 35 beschikbaar) Dit dashboard toont de werkverdeling per kanaal/esetting van de te verwerken orderregels over de verschillende outboundactiviteiten, zoals het picken, sorteren (consolideren) en verpakken. Dit dashboard is vooral interessant voor WMS klanten die meerdere kanalen hebben. 21.5-Werkverdeling per verdieping dashboard Dit dashboard toont de werkverdeling per verdieping van de te verwerken orderregels over de verschillende outboundactiviteiten, zoals het picken, sorteren (consolideren) en verpakken. 23-EcheckToLight dashboard Dit dashboard toont de prestaties en overige inzichten van het Echeck-To-Light proces. Uiteraard is dit scherm alleen interessant voor de magazijnen die gebruik maken van een Echeck-To-Light opstelling. 28-MontaSorter dashboard Voor de magazijnen waar een door Monta ontwikkelde pakket sorter staat, is een MontaSorter dashboard beschikbaar. 29-MontaPacMan dashboard Dit scherm is gemaakt om de statistieken van Monta Pac-man weer te geven. Dit dashboard maakt het extra leuk om nieuwe records met de inpakmachine neer te zetten. Uiteraard is dit scherm alleen interessant voor de magazijnen die gebruik maken van een Monta Pac-man inpakmachine. 30-Performance dashboard Dit is het scherm dat de productiviteit of performance toont. De dagen dat de begroting behaald is qua productiviteit zijn de balken van de grafiek groen, op de andere dagen blauw. 31-Scanner beheer Dit Montacast scherm laat zien welke scanners in de laadkast staan en welke in gebruik zijn. Op deze manier kan ook bijgehouden worden of er scanners kwijtraken. Vaak zie je dit op een monitor boven op de scanner kast, maar je kunt het dashboard ook op andere Montacasts tonen. Op het dashboard wordt een 🚨 weergegeven wanneer een scanner defect is en een ⚠️ wanneer er meer dan 24 uur geleden is ingelogd op de scanner. 32-Joker dashboard In het joker scherm is te zien wat het percentage jokers is ten opzichte van de verzonden orderregels. 40-Monta neuws Dit Montacastscherm toont het Montanieuws. Doordat dit scherm op zichzelf al een carrousel is, kan dit scherm niet in combinatie met andere Montacast schermen gebruikt worden. 41-Gamification dashboard Dit is het scherm dat de gamification uur-winnaars toont. Ieder uur is er per categorie een winnaar Monta breed. Deze winnaar wordt op dit scherm getoond. 42-Website pagina weergave In dit Montacast scherm kun je webpagina's embedded. Dit kan bijvoorbeeld handig zijn voor Servicedesk als je een aantal status pagina's wilt zien. Of een bepaald Power BI scherm. Door web pagina's via Montacast te bekijken, kun je de webpagina's als carrousel langs laten komen. Het instellen van de url's voor web pagina's is niet mogelijk voor kantoor gebruikers, maar alleen in het admin gedeelte. 43-Welkom scherm Dit Montacast scherm laat zien welke welkom teksten en afbeeldingen je hebt ingesteld in gomonta 90-Montacast Health dashboard (scherm voor IT afdelingen) Op dit dashboard is te zien hoe de MontaCasts het doen. De Montacasts de 6 oudste screenshots worden hier getoond. 91-Killswitches status (Scherm voor IT afdelingen) In dit dashboard wordt de status van de killswitchers getoond. Een killswitch is een digitale schakelaar die stukjes van de systemen kan uitschakelen bij eventuele storingen. Waar kan bekeken worden hoe de Montacasts in je vestiging het doen? In het kantoor gedeelte van Gomonta kun je zien hoe de Montacast in je vestiging het doen. Via Kantoor - TVs MontaCast Regelmatig wordt een schermafdruk gemaakt van de MontaCast welke te zien is in gomonta. Als de schermafdruk recent is, is er een groene balk te zien. Als het lang geleden is dat het screenshot gemaakt is, dan is de balk rood. In dat geval kan gekeken worden of de MontaCast wel aan staat. Waar kunnen de Montacast pagina's ingesteld worden? Vanuit het Gomonta kantoor gedeelte In het kantoor gedeelte van Gomonta kun je instellen welke dashboards je op de MontaCast wilt hebben. Via Kantoor - TVs MontaCast https://gomonta.montapacking.nl/Office/MontaCast Wanneer je op een tegel van een MontaCast klikt, verschijnt een popup waar je dashboards kunt kiezen. Via de knop Toevoegen (A), kun je een nieuw dashboard toevoegen, er opent dan een keuzelijst bij (B), waar je een dashboard kunt kiezen. Bij (C) kun je instellen hoeveel seconden het scherm in beeld blijft voor het geval je meer dan 1 dashboard hebt ingesteld. Vervolgens kun je de gekozen instellingen opslaan met (D) Vanuit het Gomonta Admin gedeelte (IT-ers) Op GoMonta/Admin/MontaCast kunnen er instellingen worden gewijzigd van de MontaCast. Op de eerste pagina wordt een overzicht getoond van alle MontaCast devices per vestiging: https://gomonta.montapacking.nl/Admin/MontaCast Zodra een device wordt opengeklikt, kan deze specifiek geconfigureerd worden: Zoals bij de blauwe pijltjes in de bovenstaande afbeelding te zien is, kunnen hier verschillende typen Montacast schermen worden toegevoegd. Daarnaast kan er van ieder dashboard ingesteld worden hoe lang deze getoond mag worden in de carrousel. Als er maar één dashboard is ingesteld, zal de carrousel niet geactiveerd worden. Daarnaast zal de carrousel ook niet actief zijn als één van de ingestelde pagina's de Montanews pagina is. De Montanews pagina kan namelijk niet in gebruik met andere dashboards gebruikt worden. Is er aan de veiligheid gedacht? Voor de veiligheid is er een eenmalige login vereist indien het apparaat niet is verbonden met een Monta-netwerk. Dit inloggen gebeurt met een geldige personeelsbadge. Daarnaast moet het apparaat worden goedgekeurd door Servicedesk qua Internal Rest Credentials. Hiermee ligt het nivo van beveiliging ongeveer gelijk aan de gebruikelijke Echeck en Inbound stations. Het inloggen werkt nu volgens onderstaande schema's: Herstart De Intel Celeron Nucs die voor Montacast gebruikt worden, worden geïnstalleerd via intune. Via intune is het geregeld dat elke nacht om 02:00 er een herstart is. Hoe werkt het update mechanisme. Als er nieuwe dashboards ontwikkeld worden, is het over het algemeen niet nodig dat de Montacast app wordt ge-update. Maar soms zullen er updates aan de Montacast app zelf zijn. In het geval er een update is, zitten we met de uitdaging dat een TV vaak geen toetsenbord en muis heeft en we geen update meldingen in beeld willen hebben waar je op klikken moet. Automatische update In intune wordt de nieuwste versie van de Montacast app geladen als er een nieuwe versie is. IT Operations kijkt elke donderdag of er een nieuwe versie van de Montacast app beschikbaar is op https://software.monta.nl/uwpupdate/ Als dat het geval is, wordt de Montacast update in Intune verwerkt en bij de eerstvolgende herstart van de intel celeron nuc, wordt de nieuwe versie van Montacast geïnstalleerd. https://vragen.monta.nl/Docs/Operations/Werkstations/Productie-machines/Installatie-proces-Productie-machines/ Manuele update Mocht er een update zijn waarbij je niet maximaal een week wilt wachten voordat de update gedaan is, is er ook een mogelijkheid manueel te updaten. Links bovenin de Montacast app komt een onopvallende knop 'New update' Daarop kan geklikt worden op een moment dat updaten gelegen komt, vervolgens komen er wat schermpjes uit de update wizard langs. -- -- -- Waar is er meer technische informatie te vinden? Via onderstaande link wordt er doorverwezen naar de pagina met technische beschrijvingen: https://vragen.monta.nl/Docs/Operations/Werkstations/Productie-machines/MontaCast/"
  },
  "Algemene-informatie/Apparaten/Montabots/Lowpad-Gebruikershandleiding/index.html": {
    "href": "Algemene-informatie/Apparaten/Montabots/Lowpad-Gebruikershandleiding/index.html",
    "title": "Lowpad Gebruikershandleiding",
    "keywords": "Lowpad Gebruikershandleiding Voorwoord 1 Inleiding 1.1 waarschuwing 1.2 Fabrikant 1.3 Machinerichtlijn 1.4 Doel en doelgroep van dit document 1.4.1 Overige documenten 1.5 Copyright 1.6 Aansprakelijkheid 1.7 Garantie 1.7.1 Garantieperiode 1.7.2 Garantiedekking 1.7.3 Uitsluiting van garantie 1.8 Herkomst en jaar van productie 1.9 veiligheidssymbolen in de gebruikershandleiding 1.10 Overige symbolen 1.11 Terminologie 2 Aflevering en opslag 2.1 schade bij aflevering 2.2 Opslag 2.3 Transport 2.3.1 Hijsen 2.3.2 Verplaatsen korte afstand 2.3.3 Verplaatsen lange afstand 2.3.4 Afzetten werkgebied 3 Veiligheid 3.1 Beoogd gebruik 3.2 Algemene veiligheidsvoorschriften 3.2.1 Installatie/Gebruiksgereed maken 3.2.2 Veiligheidsvoorschriften 3.2.3 Veiligheidszones en veiligheidsafstanden 3.2.4 Gebruiker 3.2.5 Onderhoud 3.3 Machinespecifieke veiligheidsinstructies 3.3.1 Waarschuwingssymbolen op de Lowpad 3.3.2 Persoonlijke beschermingsmiddelen 3.3.3 Veiligheidsvoorzieningen 3.4 Restrisico’s (uit de risicobeoordeling) 4 Installatie 4.1 In gebruikname 4.2 Vloerconditie 4.3 Omgevingsfactoren 4.4 Eisen aan te laden ladingdragers 5 Beschrijving 5.1 Functie 5.2 Werking 5.3 Buitenkant van de Lowpad 5.4 Delen van de Lowpad 5.4.1 Onderdelen onder de bovenkap 5.4.2 Liftsysteem 5.5 Accu 5.5.1 Algemeen 5.5.2 Specificaties accu 5.5.3 Specificaties lader 5.5.4 Veiligheid 5.6 Bedieningselementen 5.6.1 Overzicht 5.6.2 Sleutelschakelaar 5.6.3 LED-verlichting 5.6.4 Handbediening 6 Bediening 6.1 Voorzorgsmaatregelen 6.2 In bedrijfstellen 6.3 Uitschakelen 6.3.1 Uitschakelen van de machine 6.3.2 Geforceerd uitschakelen 6.3.3 Herstart na onderbreking 6.4 Noodstop 6.4.1 Starten na een noodstop 6.4.2 Let op bij beide stopfuncties 6.5 Storing 6.6 Foutcodes van veiligheidsscanner 6.7 Handelingen 6.7.1 Identificatie Lowpad 6.7.2 Lowpad overnemen via handbediening 6.7.3 Lowpad terug in bedrijf plaatsen 6.7.4 Instructie handmatig laden via kabel (optioneel) 7 Onderhoud 7.1 Veiligheid 7.2 Onderhoudshistorie 7.3 Periodiek onderhoud 7.3.1 Dagelijks onderhoud 7.3.2 Wekelijks onderhoud 7.3.3 Maandelijks onderhoud 7.3.4 Driemaandelijks onderhoud 7.3.5 Jaarlijks onderhoud 7.4 Liftsysteem smeren 7.5 Onderdelen verwisselen 7.5.1 Accu vervangen 7.5.2 Bufferbatterij van PLC (PS-101) vervangen 7.5.3 Hefdop/positioneerpen vervangen 7.5.4 Voor- en achterkappen vervangen 7.5.5 Aardlitze verlengen 8 Afdanken 8.1 Veiligheidsaspecten 8.2 Milieuaspecten 8.3 Lithium-Ion accu BIJLAGE 3 SMEERMIDDELEN B3.1 Vet voor kogellagers, linear geleidingen en tandheugels BIJLAGE 8 AFSTELLEN HIJSGEREEDSCHAP"
  },
  "Algemene-informatie/Apparaten/Montabots/Montabots-updates/index.html": {
    "href": "Algemene-informatie/Apparaten/Montabots/Montabots-updates/index.html",
    "title": "Montabots updates",
    "keywords": "Montabots updates Updates in de monta software rondom de montabots worden onderstaand weergegeven. Update 4-8-2022: Weergave S of Echeckwall orders schermen pickeiland. Door de weergaven van S of Echeckwall orders op de schermen boven de transportbakken is beter te zien welk type orders momenteel gepickt wordt. Dit helpt ook om de juiste instellingen te kiezen rondom tijdigheid. Update 4-8-2022: Pickeiland schermen tonen aankomst en vertrek van de rekken Op de schermen boven de pickrek posities is te zien wat de montabots gaan doen voor die posities. Update 4-8-2022: Lege rekken van de 3e naar de inbound Lege rekken vanaf de 3e verdieping worden nu automatisch naar inbound gebracht. Update 4-8-2022: Afhaaltijd prio bij het plannen van de orders Bij het inplannen van orders voor de montabots wordt nu allereerst gekeken naar de afhaaltijd en pas daarna naar de rekken met de meeste picks. Dit om ervoor te zorgen dat het relatief grote aantal orders met vroege afhaaltijden (zoals buspost) tijdig ingepakt kunnen worden. Update 4-8-2022: Supervisor 2.1 draait op de 3e verdieping De software van Eurotec (supervisor) is naar een hogere versie gegaan. Ook de monta software is daarop aangepast. Deze supervisor 2.1 draait op de 3e verdieping. Update 4-8-2022: Voorbereiden replenishen pickeiland De software bij het pickeiland op de 3e verdieping is voorbereid op het kunnen replenischen op het pickeiland. Update 4-8-2022: Afhaaltijd prioriteit verdelen over de dag Om de beste combinatie te vinden van tijdigheid en efficiency, zijn er veel keuzen mogelijk op de 3e verdieping bij het pickeiland. Er is nu een mogelijkheid om voor verschillende perioden op de dag verschillende instellingen te doen. Vooralsnog is dat nog in de database en niet via een scherm. (David kan dan de gewenste instellingen doen). Op termijn, als deze manier van werken bevalt, wordt er ook een scherm voor gebouwd."
  },
  "Algemene-informatie/Apparaten/Montabots/Veiligheid-Montabots/index.html": {
    "href": "Algemene-informatie/Apparaten/Montabots/Veiligheid-Montabots/index.html",
    "title": "Veiligheid Montabots",
    "keywords": "Veiligheid Montabots De Montabots hebben sensoren waardoor ze afremmen voor obstakels. Hierdoor is het mogelijk voor Monta medewerkers om in dezelfde ruimte te werken als de Montabots. Wel is het goed de veiligheid flyer te bekijken voordat je in het Montabot gebied gaat werken. Deze flyer is hier te vinden en hangt op bij de ingangen van de Montabot gebieden. Veiligheid flyer Nederlands Safety flyer English"
  },
  "Algemene-informatie/Apparaten/Montabots/index.html": {
    "href": "Algemene-informatie/Apparaten/Montabots/index.html",
    "title": "Montabots",
    "keywords": "Montabots De Montabots zijn Autonome Mobiele Robots (AMR's) van het merk Lowpad. De Montabots worden gebruikt voor het transporteren van opslagrekken. Een Montabot is in staat een rek op te tillen, ergens heen te rijden en weer neer te zetten. De Montabots hebben sensoren waardoor ze afremmen voor obstakels. Hierdoor is het mogelijk voor Monta medewerkers om in dezelfde ruimte te werken als de Montabots. Wel is het goed de veiligheid flyer te bekijken voordat je in het Montabot gebied gaat werken. Deze flyer is hier te vinden en hangt op bij de ingangen van de Montabot gebieden. Naast deze pagina met algemene informatie is er ook een handleiding en een pagina over troubleshooting Introductie Als introductie een filmpje van monta uit 2021, waarin de montabots ook te zien zijn ::: video ::: Einde dag script Aan het einde van de werkdag is het op de 2e verdieping van belang dat montabots aan de goede kant van de branddeuren terecht komen, omdat bij het afsluiten van het pand de branddeuren gesloten worden. De kant bij de echeckwalls, met de betonnen vloer en de montabot laders is de kant waar de montabots 's nachts horen te zijn. Om dit mogelijk te maken is er een 'einde dag script'. Dit zorgt ervoor dat rekken die nog bij de echeckwalls staan in de hal gezet worden en dat er daarna geen nieuwe opdrachten aan de montabots gegeven worden. Daarnaast worden de opportunity laadpunten naar measured gezet. (dit is iets dat nodig is in supervisor 1, de versie van lowpad software die op de 2e verdieping draait, omdat bij opportunity laders de lowpads niet op hun plek blijven 's nachts) Liften De liften logica van de Montabots: Eerst wordt er gekeken naar transportrekken die naar de 2de verdieping moeten. Daarna wordt er gecheckt over er voldoende transportrekken zijn op de 3de verdieping. Vervolgens wordt er gekeken of er rekken van de inbound naar de 3e verdieping moeten om orders te voltooien. Als laatst zal de lijst in volgorde worden afgerond. Pickpoortjes Op de pickpoortjes van het transportrek wordt getoond hoeveel producten op een andere verdieping liggen. Standaard wordt er net zolang gewacht totdat deze gepickt zijn. Door de krat gereed te melden, zal dit worden genegeerd en zal het rek naar de 2de verdieping gaan. In het pickscherm staan nu 2 knoppen. \"Blokkeer krat\" en \"Krat gereed\". Blokkeer krat In deze krat mogen geen nieuwe orders worden toegevoegd door de planner. Krat gereed In deze krat mogen geen nieuwe orders worden toegevoegd door de planner en alleen de producten op de 3de verdieping hoeven gepickt te worden. ! let op mogelijke jokers worden hiermee geaccepteerd ! Pickeiland Het pickeiland is een pick concept dat op de 3e verdieping draait. Montabots brengen pickrekken, waaruit een medewerker pickt en de producten in een transport rek legt. Wanneer de transportrekken vol zijn qua orders, worden de transportrekken door montabots in de goederenheffer gezet en vervolgens door een andere montabot op de 2e verdieping er weer uit gehaald. Vervolgens wordt het transportrek als het S-orders bevat bij een echecktafel gezet en als het transportrek een bulkpick voor M-orders is, wordt het transportrek bij een echeckwall gezet. In en uitschakelen van het Pickeiland Instellingen pickeiland. Instellingen zijn te vinden in gomonta - outbound - magazijn outbound instellingen - montabots https://gomonta.montapacking.nl/WMS/Shift/WarehouseSettings Bij het pickeiland kan het \"Montabot pickeiland tijdschema\" aangepast worden. In dit tijdschema kan je de prio cutoff tijd, niet prio cutoff tijd en ingesteld tot tijden aanpassen. Prio cutoff tijd Dit geeft aan tot en met welke afhaaltijd orders prioriteit hebben. In het voorbeeld staat een prio cutoff tijd van 14:00 dit betekent dat orders die een afhaaltijd hebben tot en met 14:00 gepickt worden en geprioriteerd. Let op! Dat wanneer een prio cutoff tijd is ingesteld, dat alleen orders die binnen de aangegeven afhaaltijden gepickt worden. Niet prio cutoff tijd Dit geeft aan tot en met welke afhaaltijd orders die geen prioriteit hebben gepickt. In het voorbeeld staat een niet prio cutoff tijd van 17:00 dit betekent dat orders die een afhaaltijd hebben van 14:00-17:00 wel gepickt worden, alleen zonder een prioriteit. Let op! Dat wanneer een niet prio cutoff tijd is ingesteld, dat alleen orders die binnen de aangegeven afhaaltijden gepickt worden. Ingesteld tot Dit geeft aan tot hoelaat de prio cutoff en niet prio cutoff instellingen gelden. In dit voorbeeld is een ingestelde tijd van 07:30 ingesteld. Dit geeft aan dat de instellingen van prio cutoff en niet prio cutoff gelden vanaf de starttijd tot 07:30. Daarna is een tijd ingesteld van 09:00, dit betekent dat de tweede set van prio cutoff en niet prio cutoff tijden gelden van 07:30 tot 09:00. Let op! als er daarna geen instegelde tijde meer zijn gaat het tijdschema werken met de standaard instellingen *Standaard is de prio cutoff tijd ingesteld op 22:00 en de niet prio cutoff tijd op 23:59. Per afhaaltijd De instellingen van het tijdschema kunnen aangepast worden zodat orders met een bepaalde afhaaltijd gepickt kunnen worden. voorbeeld scenario De huidige opstelling voor het pickeiland ziet er als volgt uit: Met het volgende tijdschema: Je kunt in de opstellingen zien dat 4 posities wit zij. Dit zijn de bakken waar de gepickte orders geplaats worden op basis van grote order en prioriteit. Zo worden in echeckwall prio de orders geplaatst met prioriteit. In de S bak niet prio worden S orders geplaatst die geen prioriteit hebben. De dag begint met een prio cutoff tijd van 16:00 en een niet prio cutoff tijd van 17:00 tot een ingestelde tijd van 07:30. Dit betekent dat eerst orders met een afhaaltijd van 16:00 of eerder gepickt worden met prioriteit. Daarna worden orders gepickt met een afhaaltijd vanaf 16:00 tot en met 17:00 zonder prioriteit. Dit wordt gedaan tussen de starttijd en de ingestelde tijd 07:30. Daarna gaat het tweede deel van het schema inwerking. De prio cutoff tijd is nu 17:00 en de niet prio cutoff tijd is nu 22:00. Deze instellingen zijn nu geldig vanaf 07:30 tot 09:00. Daarna is er geen Prio cutoff of niet prio cutoff ingesteld, dus worden vanaf 09:00 de standaard instellingen gebruikt. Standaard is de prio cutoff tijd ingesteld op 22:00 en de niet prio cutoff tijd op 23:59. Dit blijf gelden totdat de nieuwe werkdag begint. Troubleshooting"
  },
  "Algemene-informatie/Apparaten/Pick-To-Light/Zone-Pick-To-Light/index.html": {
    "href": "Algemene-informatie/Apparaten/Pick-To-Light/Zone-Pick-To-Light/index.html",
    "title": "Zone Pick To Light",
    "keywords": "Zone Pick To Light Met Zone picking is het mogelijk om met meerder mensen een Pick To Light stelling te bedienen. Dit wordt gedaan door de stelling op te delen in kleinere delen, zones. Hoe werkt zone picking Als een systeem ingesteld staat krijgt een medewerker een pop-up die vraagt of je met zones wilt werken. \"Nee\" stuurt de medewerker het standaardscherm. \"Ja\" stuurt de medewerker naar het zone pick scherm. Orders zullen nu per zone behandeld worden. Door met zones te werken wordt elke order opgedeeld in delen. Deze delen worden één voor één verwerkt. Hieronder is een schema te zien hoe dit er uit ziet. De eerste picker scant een krat om het picken te beginnen. De eerste picker pickt de producten in zijn/haar zone. De picker vervoert het krat naar de volgende zone via de rollerbaan die aan de stelling vast zit. De volgende picker verzamelt het deel in zijn/haar van de order en vervoert het krat naar de volgende zone. dit herhaalt zich totdat de order klaar is. de laatste picker plaatst het krat op de aangestuurde rollerbaan. Als een deel verzamelt is, wordt er een signaal gegeven om aan te geven naar welke zone de order moet. Dit gebeurt via de stelling en het scherm. op de stelling geven de lampjes oranje licht, met het zonenummer op de displays naast de knoppen. Het scherm weergeeft deze informatie ook in een pop-up, zoals hieronder te zien is. Deze pop-up samen met de lampjes op de stelling na 5 seconden uit. Dit wordt aangegeven met de aflopende balk boven in de pop-up. Dit kan ook uitgezet worden met de checkbox links onderin. Als een order klaar is wordt het standaard eindsignaal gegeven op de laatste zone van de order. een order kan opgehaald worden vanuit elke zone. Er is echter op dit punt nog geen garantie dat de opgehaalde order daadwerkelijk in die order start. Om te voorkomen dat zones stil staan, is het mogelijk gemaakt om meerdere orders tegelijkertijd te verwerken. dit kan door een nieuw krat te scannen. Als er meerdere orders in dezelfde zone moeten zijn, wordt de laatst aangekomen order in een wachtrij gezet. Deze order wordt automatisch getoond zodra de order daarvoor de zone verlaat. Hieronder is uitgebeeld hoe dit er met drie orders uit ziet. Alle orders worden bijgehouden in een lijst in de software die aangeeft in welke volgorde de orders staan. Hier wordt ook verdere informatie gegeven, zoals de hoeveelheid producten en de zone waar de order zich bevindt. Om de details van een order te zien, zoals kan op de niet zone pick pagina druk je op de knop rechts in de order regel onder Details. Zones instellen [[Doelgroep: IT ********** De informatie hieronder is meer van technische aard ********** Technische informatie bij de Pick To Light technisch kopje 1"
  },
  "Algemene-informatie/Apparaten/Pick-To-Light/index.html": {
    "href": "Algemene-informatie/Apparaten/Pick-To-Light/index.html",
    "title": "Pick To Light",
    "keywords": "Pick To Light Pick To Light is een systeem dat we gebruiken om te kunnen orderpicken zonder dat je veel scans met je pistoolscanner hoeft te doen. Van de systemen die we nu (2022) hebben is Pick To Light het snelste picksysteem.​ Het picken gaat door een krat te scannen waar de order in gaat. Dan gaan lampjes branden met het te picken aantal eronder. Als de producten uit het juiste vakje gepakt zijn, wordt door het indrukken van het knopje bij het vak aangegeven dat het picken gelukt is. Deze pagina geeft informatie over de werking van de Pick To Light stelling en sluit af met technische informatie over de Pick To Light. Hoe werkt een Pick To Light Bij het verifiëren van een order herkent het systeem dat de producten gepickt moeten worden via de pick-to-light stelling. Zie Outbound - Locatie keuze. Bij de order wordt opgeslagen van welke pick-to-light stelling hij gepickt moet worden. Bij de stelling hangt een monitor waarop wordt aangegeven hoeveel orders er gepickt moeten worden De gebruiker scant een krat Het pick-to-light systeem kiest een order en wijst deze toe aan de krat Het pick-to-light systeem geeft bij de locaties waar een product gepakt moet worden met het display aan hoeveel er gepakt moeten worden De gebruiker pakt het aangegeven aantal producen van de locatie, drukt op de knop ter bevestiging en legt de producten in de krat. Gebruiker scant de volgende krat, tot alle orders gedaan zijn Mocht er een probleem zijn met de pick-to-light stelling, dan is het ook mogelijk om de orders met de scanner te picken. Hiervoor is een filter optie bij het kiezen van een pickstroom. Zie ook onderstaand filmpje: ::: video ::: Verschillende typen Pick To Light stellingen Verspreid over de vestigingen bestaan er verschillende soorten Pick To Light stellingen. De meest voorkomende variant is een Pick To Light met flowracks. De producten staan in bakjes in een flowrack, zodat de voorraad aan de achterkant van de Pick To Light stelling kan worden bijgevuld en de producten door de zwaartekracht naar voren rollen, naar de kant waar het daadwerkelijke picken gedaan wordt. Dan is er nog een Pick To Light met vakken. En er bestaat ook een Pick To Light in een palletstelling. De vakken zijn daar wat groter, zodat er ook hele pallets in gezet kunnen worden. Typen orders in een Pick To Light In principe is een Pick To Light stelling vooral geschikt voor M-orders. Maar als er ook S-orders gepickt kunnen worden van de locaties van de Pick To Light, kan bij het picken gekozen worden een krat met S-orders te picken. ... Picken op een specifiek kanaal Het is mogelijk een kanaal te kiezen, waardoor alleen orders van dat kanaal gepickt worden. Dit kan gebruikt worden om orders van bijvoorbeeld een bol of amazon kanaal eerst te picken. Bijvulmonitor Door op de omcirkelde knop te drukken kan de picker aangeven, dat de voorraad van de bijhorende locatie bijna leeg is. Zodra deze knop is ingedrukt wordt er een melding gestuurd naar de Bijvulmonitor. Via de knop ‘Wis alles’ kunnen alle meldingen worden gewist. De naam van het product met de hoogste prioriteit. De locatie van het product met de hoogste prioriteit. De prioriteit, dat de voorraad bijvult moet worden. Dit is verdeeld in 5 niveaus, namelijk zeer laag, laag, gemiddeld, hoog en zeer hoog. Door meerdere keren dezelfde melding te sturen, wordt de prioriteit hoger. Lijst met alle meldingen, die binnen zijn gekomen. Via de knop ‘Aangevuld’ kan worden aangegeven, dat de voorraad is aangevuld. Vervolgens zal de melding verwijderd worden vanuit de lijst. Bijvullen algemeen Voor de Pick To Light stellingen die geen bijvulmonitor hebben, kan bijvullen gedaan worden zoals ook reguliere magazijnlocaties kunnen worden bijgevuld. Een omschrijving van hoe dit werkt is hier te vinden. Heatmap Bij een Pick To Light is het vaak wenselijk om de producten waar er het meest van gepickt worden dichtbij elkaar te leggen. Omdat het in de loop van de tijd kan wijzigen hoeveel een product gepickt wordt, is er een scherm beschikbaar waarin gekeken kan worden of de producten nog logisch verdeeld liggen in de Pick To Light. Via onderstaande schermen kan aangegeven worden dat de heatmap getoond kan worden en dan gaan de lampjes op de Pick To Light branden in verschillende kleuren. In het volgende scherm kan gekozen worden over hoeveel dagen in het verleden de heatmap berekend kan worden. Vervolgens gaan de lampjes op de Pick To Light branden in verschillende kleuren. Bij artikelen die het meest gepickt zijn gaat een rood lampje branden. Door de artikelen bij rode lampjes te verplaatsen naar de 'beste' locaties binnen de Pick To Light stelling, wordt de Pick To Light efficiënter in gebruik. Business Intelligence montaWCS Er wordt bijgehouden hoeveel orders gepickt zijn via een Pick To Light en hoeveel jokers er zijn opgetreden. Deze informatie is in te zien via montaportal, onder het account van de vestiging waar de Pick To Light staat. Zone picking Wanneer een Pick To Light stelling erg groot is, of op drukke momenten, kan het wenselijk zijn om met meerdere mensen tegelijk met de Pick To Light stelling te kunnen werken. Dat kan door zone picking toe te passen. Zone picking binnen Pick To Light heeft een aparte pagina met uitleg die hier te vinden is [[Doelgroep: IT ********** De informatie hieronder is meer van technische aard ********** Technische informatie bij de Pick To Light De tabellen voor Pick To Light staan gewoon in de Monta_Backend database. Tabelstructuur In tblPickToLightStellingen worden PickToLight stellingen gedefinieerd. Hierin kunnen onder andere zaken geregeld worden zoals: Naam van de PickToLight stelling en aangeven in welk magazijn de Pick To Light stelling staat. Gekoppelde computer/nuc ID instellen Instellen of de Pick To Light knopjes heeft met waarop 2 karakters of 3 karakters worden weergegeven. Instellen van Rabbit Mq exchange voor communicatie met de bijvulmonitor Instellen welke Pick To Light stellingen bij elkaar horen als er gewerkt wordt met gekoppelde stellingen Pick To Light locaties In tblPickToLightLocations kan worden ingesteld welke Pick To Light locaties bij een Pick To Light stelling horen. In deze tabel wordt een link gelegd tussen de Pick To Light stelling, een magazijnlocatie en een Atop knopje. (Atop is de naam van de hardware die wordt gebruikt bij Pick To Light stellingen. Dit zijn knopjes die gekleurd kunnen oplichten en een display hebben waarin een getal getoond kan worden) Gekoppelde Pick To Light stellingen Er zijn gevallen waarbij het wenselijk is om met 2 Pick To Light stellingen te werken die dezelfde producten bevatten. Vaak wordt dan op rustige dagen met 1 stelling gewerkt en op drukke dagen kunnen er 2 stellingen ingezet worden. Via tblPickToLightStellingen kan in de velden InGroupWithPreferredStellingId en IsPreferredPickToLightStelling worden ingesteld welke Pick To Light stellingen bij elkaar horen. Er zijn 2 manieren van werken; In onderstaand screenshot staan 2 Pick To Light stellingen in Waspik, daarbij is het zo dat als \"Waspik-To-Light 1\" aan staat, de orders om en om verdeeld worden met \"Waspik-To-Light 2\". De beide Pick To Light stellingen in Waspik zijn identiek qua indeling en bevatten dezelfde producten op dezelfde Pick To Light locaties De \"Pink-To-Light Groot\" en \"Pink-To-Light Klein\" in Papland werken net iets anders. De \"Pink-To-Light Klein\" bevat minder Pick To Light locaties dan de \"Pink-To-Light Groot\". Als de \"Pink-To-Light Klein\" aan staat, zullen orders die volledig op de \"Pink-To-Light Klein\" gepickt kunnen worden standaard op de \"Pink-To-Light Klein\" worden gezet. Orders die ook producten bevatten die niet in de \"Pink-To-Light Klein\" liggen, worden op de \"Pink-To-Light Groot\" gezet. tblPickToLightStellingen Shipper Het is mogelijk om specifieke verzenders te koppelen aan een Pick To Light. Als een verzender aan een Pick To Light is gekoppeld, dan kunnen alleen orders van deze verzender gepickt worden van de Pick To Light. Dit is in te stellen in de tabel tblPickToLightSettingsShippers. BijvulMonitor De bijvulmonitor is een scherm dat achter de picktolight kan staan om adviezen te geven over bijvullen. In onderstaande tabel kan dit geconfigureerd worden. Als op de onderste kleine knop van de A-Top node wordt gedrukt tijdens het picken, dan wordt er een bericht naar de ingevulde RabbitMQ exchange gestuurd. Dit bericht wordt door de bijvulmonitor uitgelezen en getoond op het scherm. Als hetzelfde bericht vaker wordt gestuurd, dan wordt de prioriteit van deze bijvulactie hoger. Zone picking In tblPickToLightZone kan zone picking worden ingesteld. Dit is mogelijk via het WCS Pick To Light scherm in montaportal. Verdere toelichting schrijven samen met Jerke"
  },
  "Algemene-informatie/Apparaten/Put-To-Light/Put-To-Light-Cart/index.html": {
    "href": "Algemene-informatie/Apparaten/Put-To-Light/Put-To-Light-Cart/index.html",
    "title": "Put To Light Cart",
    "keywords": "Put To Light Cart Handleiding Solderen langere draden accuhouders. Schroef de houders open met de 2 zwarte schroeven. Desoldeer de bestaande draden Soldeer nieuwe langere draden met minimale diameter 0.75mm2 (let goed op + en -) Uploaden arduino programma Download de Arduino ide (https://apps.microsoft.com/store/detail/arduino-ide/9NBLGGH4RSD8?hl=nl-nl&gl=nl&ocid=badge&rtc=1) Open het arduino programma op de volgende locatie (Monta Services BV\\RandD - General\\22-PickToLight-PutToLight\\23-GaaskarMetLampjes) Selecteer bij tools, board: Arduino nano, port: de weergegeven COM-port Druk op ctrl+U of op de knop met de pijl linksboven Als het uploaden niet lukt probeer dan een van de voorbeelden up te loaden. Onder file, examples, 01-basics, blink. Druk weer op de pijl of ctrl+U Probeer nogmaals het Arduino programma up te loaden Aansluiten pcb, 2 accu houders, signaallampen en 12V converters. Arduino met usb aansluiting bij de pijl op printplaat plaatsen. Wanneer alles is aangesloten ziet het er zo uit: Nb dit is een oude versie van de printplaat maar de werking is hetzelfde. Instellen Moxa Wifi Bridge Onder interface On/Off moet de operation mode op client staan: Bij Wireless LAN Setup de MP-WIFI invullen (met site survey kun je de beschikbare netwerken weergeven) Hier wpa2 selecteren en bij Passphrase het wachtwoord invullen Hierna functioneert de moxa als een bridge en kunnen de apparaten die via de ethernet kabel aangesloten zijn benaderd worden via netwerk. De atop controller stel je in op een IP-adres in de reeks van het wifi netwerk waarmee je verbind. MP-WIFI bijvoorbeeld = 10.32.0.210 De Moxa bridge zelf heeft ook een IP-adres, deze kun je als standaard houden en dan met kabel verbinden naar de bridge. Of ook in de reeks zetten van het wifi netwerk MP-WIFI bijvoorbeeld = 10.32.0.222 Instellen Atop Controller Sluit de atop controller aan op een laptop. Zet de laptop in de reeks 10.0.50.X Ga naar 10.0.50.100 in de browers om naar de Atop controller te gaan. Bij settings kan het IP-adres veranderd worden naar bijvoorbeeld 10.32.0.X Sluit de Atop controller aan op de Moxa wifi bridge De Atop controller kan nu benaderd worden via het ingestelde IP-adres (dit kan getest worden met ping 10.32.0.X) Uiteindelijk is de strucutuur van het aansturen als volgt:"
  },
  "Algemene-informatie/Apparaten/Put-To-Light/index.html": {
    "href": "Algemene-informatie/Apparaten/Put-To-Light/index.html",
    "title": "Put To Light",
    "keywords": "Put To Light Een Put To Light stelling lijkt qua uiterlijk wel op een Pick To Light stelling, de lampjes en knopjes zijn hetzelfde. De werking is anders. De Put To Light wordt gebruikt om producten die door elkaar gepickt zijn in een bulk kar uit te sorteren naar (M) orders. Het proces begint door een bulk pick kar te scannen en vervolgens door blauwe kratjes aan de locaties te koppelen in de Put To Light, dat kan door de barcode van de krat te scannen en het knopje in te drukken waar de krat staat. Vervolgens kan het uitsorteren beginnen. Het uitsorteren wordt gedaan door een willekeurig product uit de bulk pick kar te pakken en dat te scannen, vervolgens gaat een lampje branden onder het juiste kratje en kan door de knop bij het lampje in te drukken de actie gereed gemeld worden. ​ Er zijn enkele verschillende typen Put To Light stellingen mogelijk. De variatie zit hem in de vorm en in de manier waarop kratjes die gereed zijn naar de echeck gaan. Hoe werkt een Put To Light ::: video ::: Aanvulling op Put To Light video Als de kratten gelinkt zijn zie je in 1 rij welke orders er uit gesorteerd gaan worden, en om hoeveel producten het gaat in de bulk pick kar. Het systeem houdt bij hoeveel scans er al gedaan zijn, dus kun je als medewerker zien hoever je bent met het verwerken van de bulk pick kar. Als de krat incompleet is kun je de krat openklikken op het scherm om te zien welk product je mist en in welke krat je het mist. In Breda is ervoor gekozen om de kratten die incompleet zijn gelijk naar een Troubleshooter te brengen zodat de mensen aan de Put To Light door kunnen gaan met de volgende bulk pick kar. Als het voorkomt dat je een bulk pick kar niet helemaal kan uitsorteren is er rechts een joker knop daarmee rond je de bulk pick kar af kan je de volgende beginnen De Put To Lights laten zien hoeveel producten er nog gescand moeten worden tot dat het kratje klaar is en verwerkt kan gaan worden bij de echeck Wanneer is een Put To Light efficiënt Een Put To Light is efficiënt als je veel M orders hebt met niet teveel regels en items. M orders met veel items van hetzelfde product kunnen beter via een kar met kratten gepickt worden. Omdat daarbij meerdere producten in één keer in een krat gelegd kunnen worden, terwijl deze via de Put to Light allemaal individueel gescan moeten worden. Verschillende typen Put To Light Stellingen In grote lijnen zijn er 2 typen Put To Light stellingen. De Put To Light stelling met doorschuifsysteem en de standaard Put To Light stelling. (en daarnaast nog een systeem dat in ontwikkeling is) Put To Light doorschuifsysteem De Put To Light stelling met doorschuifsysteem is o.a. in Lelystad, Watermolen 3 en Papland in gebruik. Bij dit type Put To Light stelling, staan de Echeckstations aan de achterkant van de Put To Light stelling. De Put To Light stelling is zo diep dat er 2 kratjes achter elkaar kunnen staan. Is het sorteren van producten in een kratje gereed, dan kan de Put To Light medewerker het kratje eenvoudigweg doorschuiven naar de achterkant van de Put To Light stelling en staat het kratje gereed voor de Echeck medewerker. De Put To Light met doorschuifsysteem heeft een overzichtelijke stroom van lege en volle kratjes, deze blijven in principe in het gebied van de Put To Light en de Echeckstations. Wel heeft deze Put To Light met doorschuifsysteem de eigenschap dat de Put To Light op dezelfde verdieping als de Echeckstations moet staan en zelfs vrij dichtbij de Echeckstations. Put To Light bij Rollenbaan De standaard Put To Light staat vaak bij een rollenbaan waarmee de volle kratjes (met uitgesorteerde M-orders) door een rollenbaan naar de Echeckstations worden gebracht. Dit type Put To Light is in gebruik in Breda en in aanbouw voor Weide 30 en Molenaarsgraaf. De Put To Light medewerker gaat in principe door met sorteren tot de hele bulk pick krat uitgesorteerd is en zet dan de volle kratjes op de rollenbaan. Vervolgens kunnen weer lege kratjes worden gepakt om in de Put To Light stelling te zetten. Deze variant heeft als voordeel dat de Put To Light niet dichtbij de Echeckstations hoeft te staan en ook niet op dezelfde verdieping. Een nadeel is hier wel dat het vervoeren van de lege kratjes wat meer organisatie vraagt. Vaak zie je dat lege kratjes op de verkeerde plek staan. Mogelijke oplossingen hiervoor zijn karratjes om lege kratten in te stapelen en het aanschaffen van flink meer blauwe kratjes dan in theorie nodig, zodat er steeds ruim voldoende blauwe kratjes beschikbaar zijn bij de Put To Light. Voor de standaard Put To Light is inmiddels een standaard bouwblok ontwikkeld, waarmee de Put To Light ook verplaatsbaar wordt. De standaard Put To Light is soms ook in V-vorm geplaatst als experiment om te kijken of daarmee de loopafstanden van de Put To Light medewerker minder zouden worden. Deze opstellingen zijn in Breda te zien. Put To Light met deense karren Daarnaast is er nog een ander type Put To Light in ontwikkeling. Dit is een frame met de Put To Light lampjes en het scherm, met daarachter karren waar de kratjes op zitten. Deze karren kunnen bijvoorbeeld Deense karren (goedkoop) zijn, met daarop kratjes die vastzitten aan de karren. De karren kunnen achter het Put To Light frame geplaatst worden. Het koppelen van de kratjes wat normaal best wat werk is, wordt nu vervangen door alleen het koppelen van de hele kar aan de Put To Light, waarna het uitsorteren kan beginnen. Als het uitsorteren gereed is, wordt de deense kar naar echeck gereden en gewisseld voor een deense kar met lege kratjes. Instellingen In Gomonta kan ingesteld worden wat het maximale formaat is van producten die in de Put To Light pickroute moeten worden meegenomen en hoeveel orders er maximaal in de bulk pick kar kunnen. Dit maximale aantal orders is over het algemeen gelijk aan het aantal kratjes dat in de Put To Light past. Of er kan een lager aantal orders worden gekozen, bijvoorbeeld als de bulk pick karren te vol blijken te zijn als het maximale aantal orders gekozen wordt. https://gomonta.montapacking.nl/WMS/Shift/WarehouseSettings Een voorbeeld van zulke Put To Light instellingen is onderstaand te zien Picktroom De pickstroom voor PutToLight orders op de pickscanner is te herkennen zoals in onderstaand plaatje te zien is. Business Intelligence montaWCS Er wordt bijgehouden hoeveel orders er gesorteerd worden met een Put To Light en hoeveel jokers deze orders bevatten. Deze informatie is in te zien via montaportal, onder het account van de vestiging waar de PutTo Light staat. Plaatje toevoegen zodra deze montaWCS beschikbaar is op montaportal [[Doelgroep: IT ********** De informatie hieronder is meer van technische aard ********** Technische informatie bij de Put To Light De tabellen voor Pick To Light staan gewoon in de Monta_Backend database. Tabelstructuur"
  },
  "Algemene-informatie/Apparaten/Sorteermachine/Costo-sorter-Oosterhout/index.html": {
    "href": "Algemene-informatie/Apparaten/Sorteermachine/Costo-sorter-Oosterhout/index.html",
    "title": "Costo sorter Oosterhout",
    "keywords": "Costo sorter Oosterhout In de vestiging Oosterhout staat een pakket sorteermachine die geleverd is door Costo. Op deze pagina is de bedieningshandleiding te vinden. ' Starten en stoppen van de installaties ##Opstarten schakelkast X1 Lampen bediengspaneel X1 Lampen in drukknoppen kast X1 Witte lamp in resetknop Groene lamp in startknop Lampen signaalkolom bovenop X1 Groene lamp (in bedrijf) Rode lamp(storing) Continu aan Storing veiligheid Knipperen (1 sec.puls) Storing 400V voeding motor(en) Storing motor Storing luchtdruk Storing 24VDC Storing bus unit Knipperen (0,2 sec. puls) Communicatiefout Ethernet/IP Oranje lamp storing algemeen Knipperen (1 sec. puls) Alle lampjes knipperen snel Algemeen Lampen veld Signaalkolommen verdieping 2 Lamp groen Continu aan Knipperen(1 sec.puls) Lamp rood Continu aan Knipperen (1 sec. puls) Signaalkolom kruispunt begane grond/verdieping Lamp rood Continu aan Knipperen (1 sec. puls) Lamp geel Lampen geel sorter Lampen geel chutes Knipperen (1 sec.puls) Resetten van de installatie na een noodstopstoring Spanningsuitval Noodstop Veiligheid Hoofdscherm Verzend- en ontvangdata Reset ethernetdata Totaalteller Flowcontrol STORINGSMELDINGEN X1 01 Pilz linkmodule geeft geen vrijgave, bel Costo +31-183-745 045 11 Storing RS232 poort op CPU 13 Storing Ethernet/IP, druk resetknop in. Bij blijvende melding bel Costo +31-183-745 045 14 Brandalarm via de brandmeldcentrale, schakel de melding op de centrale uit 15 Geen Socket connectie X1 (geen verbinding met server) mogelijk, bel IT afdeling MONTAPACKING FULFILMENT SERVICES 16 Geen communicatie tussen PLC X1 <-> PC (socket 1), bel IT afdeling MONTAPACKING FULFILMENT SERVICES 17 Veiligheidscircuit kast X1 niet vrijgegeven, druk op de resetknop van kast X1 18 Noodstop gedrukt op paneel van kast X1, draai de noodstop een kwart slag uit 19+25+33+41 Noodstop gedrukt veld locatie, draai de noodstop een kwart slag uit 49-50 Storing motorvoeding 400V xxFx, check de motorbeveiliging in kast X1 64 Luchtdruk is te laag, controleer de compressor en de leidingen 65 Storing 24VDC (2U1/2F3) in kast X1, bel Costo +31-183-745 045 66-77 Storing 24VDC in veldkast X80-X84, bel Costo +31-183-745 045 81-83 Storing Smartmotor, schakel de werkschakelaar bij de motor uit 97-114 Storing module X100-X115 E/IP veldbussyteem, bel Costo +31-183-745 045 177-371 Fotocel start/einde baandeel is bedekt gebleven waardoor dit baandeel is stopgezet 385-400 Te lang gedraaid baandeel, controleer of de pakket vastgelopen is of verwijderd 481-496 Fotocel niet vrij (gekomen) baandeel, check stapnummer en de pakket 625-640 Stapnummer blijft 0000, fotocel blijft bedekt baandeel, verwijder de (onbekende) pakket en/of controleer de fotocel(len) 753-768 Storing ventiel wissel 785-804 PC geeft geen ACKN bericht, bel IT afdeling Montapacking"
  },
  "Algemene-informatie/Apparaten/Sorteermachine/Costo-sorter-Waspik/index.html": {
    "href": "Algemene-informatie/Apparaten/Sorteermachine/Costo-sorter-Waspik/index.html",
    "title": "Costo sorter Waspik",
    "keywords": "Costo sorter Waspik BEDIENINGSHANDLEIDING TRANSPORTSYSTEEM Montapacking Waspik (NL). Het transportsysteem is uitsluitend bedoeld voor het transporteren van transportgoed gespecificeerd volgens onze orderbevestiging 140121. Starten en stoppen van de installaties X1 Lampen bedieningspaneel X1 (hoofdkast) Lampen in drukknoppen kast X1 Witte lamp in resetknop Groene lamp in startknop Lampen signaalkolom bovenkant X1 Groene lamp (in bedrijf) Rode lamp (storing) Continu aan Storing veiligheid Knipperen (1 sec. puls) Storing 400V voeding motor(en) Storing motor Storing 24VDC Storing luchtdruk Knipperen (0,2 sec. puls) Brandalarm (optioneel uitgevoerd aan Costo zijde) Communicatiefout tussen PLC en PC Oranje lamp storing algemeen Knipperen (1 sec. puls) Alle lampjes knipperen snel Algemeen Signaalkolommen veld Oranje lamp Continu aan Knipperen (1 sec. puls Resetten van de installatie na een noodstopstoring Spanningsuitval Noodstop Veiligheid Hoofdscherm Statusweergave links bovenin het scherm Button noodmodus Button reset alle PLC software STORINGSMELDINGEN X1 Overzicht meldingen met codes 01 Storing noodstop 13 Ethernet/IP storing 14 Brandalarm van de brandmeldcentrale (optioneel) 15 Geen socket 1 connectie mogelijk 16 Geen communicatie tussen PLC <-> PC(socket) 17-19 Storing 11Fx voeding in kast X1 voor motor 32 Luchtdruk te laag 33-35 Storing motor 49-53 Storing 24VDC 65-71 Storing node X100-X106 bussysteem, bel Costo +31-183-745045 98-102 Pusher storing 112 Zwarte drukknop(pen) bij pusher is lang ingedrukt 113-121 209-215 Band/sectie/bocht vast einde 162-176 Er staat een doos op de sorter te wachten voor de shute 225-234 Te lang gedraaid sectie 241-250 Fotocel niet vrijgekomen buffer 257-266 Stapnummer blijft 0, fotocel blijft bedekt motorrol 273 Foutmelding RS232 poort"
  },
  "Algemene-informatie/Apparaten/Sorteermachine/MontaSorter-Papland/index.html": {
    "href": "Algemene-informatie/Apparaten/Sorteermachine/MontaSorter-Papland/index.html",
    "title": "MontaSorter Papland",
    "keywords": "MontaSorter Papland Monta sorter is de naam van een in 2022 ontwikkelde sorteermachine van Monta die als bouwblok kan worden ingezet. Voor het gebruik van deze machine komen handleidingen beschikbaar die op deze plek te vinden zullen zijn. Interface Hardware Scherm De MontaSorter heeft een touchscreen op de elektriciteitskast dat met behulp van 3 knoppen verschillende schermen kan laten zien. Op deze schermen kunnen er verschillende functies aan en uit gezet worden. Knoppen De hardware interface van de MontaSorter bestaat ui 5 knoppen: software De software interface van de MontaSorter is een applicatie: Diverters In de applicatie zijn de verschillende diverters weergegeven met hun huidige status: Als er een diverter een probleem heeft wordt er op de desbetreffende diverter een rode kruis weergegeven. Om het probleem op te lossen zie Probleem oplossen. Barcodes Bij de sectie barcodes wordt live weergegeven welke pakketjes geregistreerd zijn door de scanner en naar welke baan ze gaan: Onderaan van de barcode sectie staan twee knoppen: \"Clear\" en \"Clear selection\" deze worden gebruikt om de geregistreerde pakketjes te verwijderen. Errors De sectie errors geeft weer welke errors er opgetreden zijn binnen het proces. Console De sectie console geeft een logboek weer van de acties die het systeem heeft uitgevoerd. [Oranje tandwiel] Indeling veranderen Met het oranje tandwiel kan je de indeling aanpassen per loopbaan( shute ) en vervoerder. Wanneer er veranderingen zijn gemaakt in de instellingen dan moet de applicatie altijd opnieuw opgestart worden. [Grijze tandwiel] Verzender en barcode aanpassen Bij deze instellingen is een wachtwoord vereist, alleen de admin kan veranderingen aanbrengen. Na het invoeren van het wachtwoord worden de instellengen van de verzenders met hun bijhorende condities. Contacteer de R&D afdeling als je hier instellingen wilt aanpassen. Probleem oplossen Rode lamp Rode lamp brand als MontaSorter aanstaat kan 2 dingen betekenen: sorteerslag mislukt of baan vol. controleer of er een diverter omhoog staat. als dat het geval is dan is de sorteerslag mislukt. haal alle pakketjes tot en met het scan huis van de baan af. Start Reset reeks. kijk of de baan vol is Maak de baan leeg die vol is. druk op de \"Groene knop\" om het proces te starten. Noodknop Als de noodknop ingedrukt geeft hij een melding weer: Om dit probleem op te lossen ga je dit stappenplan langs: Draai de noodknop zodat hij weer omhoog staat. Druk op de \"oranje knop\" om weer stroom op de rolbaan te zetten. start Reset reeks. Reset reeks druk op de de \"clear\" knop en zorg dat er geen pakketjes meer in de barcodes sectie staan. Druk daarna op de \"blauwe klop\" op de kast om de baan te resetten. De knop gaat licht geven en wacht tot deze weer uit is. Druk vervolgens op de \"Oranje knop\" om de software te resetten. Druk als laatst op de \"groene knop\" om het proces weer te starten."
  },
  "Algemene-informatie/Apparaten/Sorteermachine/index.html": {
    "href": "Algemene-informatie/Apparaten/Sorteermachine/index.html",
    "title": "Sorteermachine",
    "keywords": "Sorteermachine Met een sorteermachine kunnen de pakketten van de verschillende vervoerders uitgesorteerd worden. Er worden binnen Monta 2 typen sorteermachines gebruikt; Costo sorters, in Waspik en Oosterhout Montasorters, in Gorinchem Papland en Molenaarsgraaf Costo sorter Oosterhout Bedieningshandleiding Costo sorter Oosterhout Costo sorter Waspik Bedieningshandleiding Costo sorter Waspik Montasorter Papland Handleiding Montasorter Papland Costo sorter De sorteermachine scant de barcode van een pakket en vraag aan de bijbehorende PC naar welke goot het pakket moet. Op de PC draait een applicatie (console venster) die de barcode uitleest, herkent van welke verzender de barcode is en de juiste goot teruggeeft. In een bestand staat ingesteld welke verzender naar welke goot moet. Dit bestand staat op C:\\SorterServer\\BS.txt. Monta IT heeft invloed op het toekennen van goten aan de hand van de gescande barcode. Voor alle andere meer hardware gerelateerde zaken en voor onderhoud is Costo de juiste partij om vragen aan te stellen. Contactgegevens van Costo zijn bekend op de vestigingen Waspik en Oosterhout Montasorter In 2022 is de eerste Montasorter opgebouwd. Monta techniek heeft een eigen sorteermachine ontwikkeld zodat we geen afhankelijkheden hebben van integrators. Levertijden en prijzen van sorteermachines loopt steeds verder op, en onderhoudscontracten worden duurder. Ook zijn de reactietijden bij storingen te lang voor ons proces. Vanaf 2022 is de Montasorter een bouwblok dat kan worden ingezet. De sorteermachine bestaat uit modulaire bouwblokken, waardoor hij in elke vestiging toepasbaar is. De sorter helpt bij het verminderen van sorteerfouten en helpt bij het efficiënter vullen van postkarren. Ook wordt van elke pakket een foto gemaakt, die via de eorderattachments beschikbaar is in GoMonta en de Montaportal. [[Doelgroep: IT ********** De informatie hieronder is van technische aard ********** Technische informatie bij de Montasorter De Montasorter bestaat uit twee onderdelen: hardware met aansturing en software. In dit kopje gaan we verder in op de werking. Componenten De sorteermachine bestaat uit de volgende onderdelen: X aantal diverters met chutes Schakelkast met PLC en diverse componenten voor de aansturing van de motoren in de sorter Barcodescanner PC met sorteersoftware PC met lokale FTP server Software onderdelen De Montasorter bestaat uit een aantal diverters, ofwel wissels, waar pakketjes af kunnen slaan, of rechtdoor gevoerd kunnen worden. Deze keuze wordt gemaakt aan de hand van het vezendlabel op het te sorteren pakket. Van te voren wordt voor elke goot aangegeven welke vervoerder er op uitgesorteerd moet worden. Een barcodescanner leest de barcodes op de verzendlabels. Daarna worden de pakketjes gevolgd over de sorter. Zodra ze bij de juiste goot zijn aangekomen, worden ze gesorteerd. De aansturing van de hardware, en het bijhouden van de pakketten gebeurt in 2 verschillende stukken software: PLC software UWP app PLC software De PLC software is verantwoordelijk voor de aansturing van alle bewegende, en elektrisch gestuurde delen. Schakelen van relais, noodstopciruits e.d. worden allemaal in de PLC afgehandeld. Ook de communicatie met de voorliggende rollenbaan gebeurt in de PLC. Via een S7 verbinding praten de plc's met elkaar om door te geven of pakketjes de sorteermachine mogen betreden. UWP app De UWP app maakt verbinding met de barcodescanner, en de PLC. Als een pakket gescand wordt, bedenkt de app welke vervoerder bij de barcode hoort. Daarna wordt het pakket bijgehouden tot het bij de juiste diverter is. Dan wordt een signaal gestuurd naar de PLC dat het pakket gesorteerd moet worden. netwerk inrichting De verschillende onderdelen van de sorter communiceren met elkaar via een ethernet netwerk. Het netwerk is in de onderstaande afbeelding schematisch weergegeven: ####Wie praat met wie? De verschillende computers in het netwerk van de montasorter, kun je vergelijken met de lokale breiclub. Heel veel geklets, maar niet iedereen praat met iedereen. De verschillende PLC's praten met elkaar om door te geven of er pakketjes op weg zijn en of die pakketjes ook doorgegeven mogen worden naar het nieuwe stuk baan. Iedere PLC stuurt een deel van de rollenbaan aan. Er is 1 PLC die de sorteermachine aanstuurt. Ook die praat met de rollenbanen over de pakketjes. Op 1 van de MonPC's draait de UWP app die logica van de sorter uitvoert. Die UWP app praat met de PLC van de sorter. Verder maakt de app verbinding met de barcodescanner. De scanner stuurt berichtjes naar de app, bij iedere barcode die gescand wordt. Die barcodescanner slaat ook afbeeldingen op van de barcodes die hij heeft gescand. Dat gaat via een FTP verbinding. Op de tweede MonPC draait een FTP server. Hierop worden de afbeeldingen tijdig opgeslagen. Iedere 5 seconden (dit is een instelbaar getal, de waarde kan wisselen per sorter) worden de afbeeldingen van de FTP server gedownload en geupload naar de blobstorage. Dit doet de UWP app. Daarna wordt de ftp server leeggemaakt. instelbare opties De sorteermachine is zo geprogrammeerd dat hij flexibel ingezet kan worden. Hierdoor zijn er wel een heel aantal instellingen, die voor elke sorter goed moeten staan. Voor dagelijks gebruik zijn vooral de instelbare shippers, met hun labels en de chutes van toepassing. Via de adminsettings kan worden ingesteld hoe een verzender herkend kan worden aan een label. Let op! Afbeeldingen van user interface kunnen verschillen van de werkelijkheid De verzender kan met verschillende conditions uit een barcode herkend worden. Bijvoorbeeld een PostNL label begint '3S' + klantcode van de vestiging. Sommige verzenders bestaan uit enkel nummers, of hebben altijd een barcode van X lengte. Via de chute settings kunnen verzenders aan chutes gekoppeld worden: selecteer de gewenste chute met de bovenste dropdown. Voeg vervolgens de gewenste shippers toe met de add knop. Een shipper kan verwijderd worden door hem te selecteren in de list, en vervolgens op de remove knop te drukken. #####backups Er kan eenvoudig een backup van de instellingen worden gemaakt met de backup knop rechtsbovenin het interface. De backup wordt automatisch weggeschreven in de blobstorage. De gebruiker hoeft dus geen bestand op te slaan. Als een backup wordt ingeladen, worden de actieve instellingen overschreven. Bedenk dus goed of je dat wel wilt. Barcode scanners Tot nu toe wordt in iedere sorter de Keyence SR-5000 scanner gebruikt. In theorie kan iedere scanner waar een tcp verbinding mee gemaakt kan worden aangesloten worden. Wel hebben de meeste scanners dan een eigen stukje software nodig om ze aan en uit te schakelen. Keyence SR-5000 De SR-5000 voert op zichzelf het onderstaande script uit bij iedere scan, om de data te saneren. Dit doen we omdat vreemde tekens niet altijd via FTP verzonden kunnen worden. Dit zou de scanner langzaam kunnen maken Script Dit is een LUA script dat via de AUTO ID Navigator software op de scanner gezet kan worden. Het script moet als LUA file worden opgeslagen met de naam: FMTSET.LUA function readformatEvent() return(readResult():readData()) end function nameformatEvent() local read_data read_data = readResult():readData() read_data = string.gsub(read_data,'%%','PROCENT') return(read_data) end Shipment images De sorters maken afbeeldingen van alle pakketjes die langskomen. Deze afbeeldingen worden gebruikt om de barcode te herkennen, maar worden ook opgeslagen op een lokale FTP server. Terwijl de sorter aanstaat wordt door de software eens in de zoveel tijd gecontroleerd of er nog afbeeldingen op de FTP server staan die verwerkt moeten worden. Als dat zo is, wordt aan de hand van de TT code een eorderId opgevraagd bij de REST server. Als dat lukt, wordt de foto van de ftp server gedownload, en naar de blob storage gestuurd. Hiervoor wordt het stservicesweu001 opslagaccount gebruikt. Als het opslaan van de blob in de container 'montasorterpackageimages' is gelukt, maken we een eorderattachment aan, met een verwijzing naar de blob. Backups van instellingen De sorteermachines hebben een aantal instellingen die een operator zelf kan instellen. Een backup van deze instellingen wordt opgeslagen als file in de azure blob storage. Hier is voor gekozen omdat de instellingen als een serialiseerbaar object geëxporteerd kan worden. Omdat de pc in kioskmodus geen toegang heeft tot het file system, kunnen de instellingen niet lokaal worden opgeslagen. Wel worden de instellingen in de registry weggeschreven. Bij normaal gebruik, hoeft de backup niet gebruikt te worden. De software leest de instellingen uit de registry, en past die toe. Pas als het lezen uit de registry niet lukt, of er een nieuw device gebruikt wordt, kan de backup uit de blobstorage gelezen worden. Ook kan het zijn dat een operator instellingen heeft veranderd, en hier later toch niet tevreden mee is. Ook dan kan de backup terug gelezen worden. Tijdens het debuggen kun je middels de backups eenvoudig wisselen tussen apparaten. Lees de backups in, en je debugaparaat gebruikt exact dezelfde instellingen als het host apparaat. FAQ Wat zijn de minimale afmetingen van pakketjes die over de sorteermachine kunnen? Het kleinste pakketje mag 10cm breed, 10cm lang en 2cm hoog zijn. Wat zijn de maximale afmetingen van pakketjes die over de sorteermachine kunnen? Het grootste pakketje dat over de sorteermachine past is 40 cm breed, 60cm lang en 40cm hoog zijn. Welk type sorteermachine past het beste in mijn vestiging? alle soorten sorteermachines hebben hun voor en nadelen. Neem contact op met de R&D afdeling, en dan kijken we samen welke sorter het best bij de situatie past. Wat is de maximale snelheid van de sorteermachine? De sorteermachine elke 3 seconden een pakketje sorteren. Dat zijn dus 1200 pakketjes per uur."
  },
  "Algemene-informatie/Apparaten/index.html": {
    "href": "Algemene-informatie/Apparaten/index.html",
    "title": "Apparaten",
    "keywords": "Apparaten Er draaien bij Monta verschillende apparaten waar informatie over te vinden is. Pick To Light Monta Pacman Echeckwall Put To Light Montabots Goederenheffer BVM Sorteermachine LedControl Echeck To Light Label Applicator (S-Lane) MontaCast Autostore Voor het uitlezen en doormelden van machine meldingen wordt een systeem ontwikkeld dat Machine Whisperer genoemd wordt."
  },
  "Algemene-informatie/Checkout-module/BigCommerce-Checkout/index.html": {
    "href": "Algemene-informatie/Checkout-module/BigCommerce-Checkout/index.html",
    "title": "BigCommerce Checkout",
    "keywords": "BigCommerce Checkout Met de BigCommerce checkout kunnen bezorgopties worden getoond aan de klant in de Woocommerce webshop bij het afrekenen. Belangrijk bij BigCommerce checkout Er zijn nog geen bijzonderheden bekend over het gebruik van de BigCommerce checkout. Talen Het is nog niet bekend welke talen worden ondersteund voor de BigCommerce checkout. Configuratie Zorg dat alle tarieven en verzendmethoden + opties juist staan in de Monta portal. Maak in de MP REST Api gegevens aan. Zie handleiding: Installatie REST API Installeer de Monta checkout app in BigCommerce. Doorloop de stappen in BigCommerce. Doorloop de benodigde stappen in BigCommerce. Na installatie van de app maakt Bigcommerce automatisch de volgende waarden aan: - Zone (Land of landen waar klant naartoe kan verzenden) - Carrier(s) ( Onze Carrier die we bij BigCommerce hebben aangevraagd) - Shipping methods aangemaakt. (Verzenders en verzendopties van Monta) Doorloop nu de stappen in BigCommerce. Ga naar de instellingen op de 'Connection' tab en vul hier de benodigde informatie in. Deze zijn later aan te passen. Let op: Webshop is naam van origin waar je de checkout opties voor opvraagt Username: username van rest api Password: password van rest api Google api: google api key van de klant. Deze is nodig om de coördinaten van het verzend adres van de klant op te vragen en voor de werking van de pick-up points. Test de verbinding via de 'Quote' tab. Vul de gegevens in. Wanneer je geen quotes terugkrijgt, kan het zijn dat je credentials niet kloppen. Test de live checkout Algemene informatie en functies Van de volgende functies is bekend dat BigCommerce het wel ondersteund: Berekenen van verzendmethoden inclusief prijs Weergeven van verzendopties Van de volgende standaard functies is bekend dat BigCommerce het niet ondersteund: Weergeven van levertijden (NOG NIET GETEST 13/1/2023) Leverdag kiezen (NOG NIET GETEST 13/1/2023) Van de volgende aanvullende functies is bekend dat BigCommerce het niet ondersteund: Known issues & bugs In de 'Get Quote' werkt de checkout, maar op de website niet. Let er op dat je Google API key de juiste rechten heeft voor het ophalen van coordinaten op basis van een adres en postcode. Op de Quote tab bij het testen van je connectie wordt de Google API key niet gebruikt omdat er geen straat en postcode zijn ingevuld. Dan kan het op de Quote tab wel goed gaan, maar in de checkout zelf toch niet werken. Ik wil de checkout app verwijderen Verwijderen kan door op de app op uninstall te klikken. Bij het deinstalleren worden de shipping method, carrier en Monta zone verwijderd. Mocht je de app weer opnieuw willen installeren, kan door simpelweg de app te zoeken en de app opnieuw te installeren."
  },
  "Algemene-informatie/Checkout-module/Lightspeed-Checkout/index.html": {
    "href": "Algemene-informatie/Checkout-module/Lightspeed-Checkout/index.html",
    "title": "Lightspeed Checkout",
    "keywords": "Lightspeed Checkout Met de checkout module kan de klant verschillende functionaliteiten tonen in zijn webshop bij het afrekenen. Belangrijk bij Lightspeed checkout Lightspeed heeft geen specifieke app voor de checkout nodig. Wél moet je de checkout 'installeren' via de Order Import dataflow binnen de Montaportal: Talen De volgende talen worden ondersteund in de Lightspeed checkout: Nederlands Engels Configuratie Zorg dat de doel-webshop al is gekoppeld via connector Zorg dat alle tarieven en verzendmethoden + opties juist staan in de Monta portal. Installeer de checkout module via de order-import dataflow. Test de checkout Algemene informatie en functies Van de volgende functies is bekend dat Lightspeed het wel ondersteunt: Berekenen van verzendmethoden inclusief prijs Weergeven van verzendopties Leverdag kiezen (Alleen nieuwe lightspeed checkout) Weergeven van levertijden (Alleen nieuwe lightspeed checkout) Bedrag na korting is gebruikt voor berekening van de verzendkosten. Deze updaten ook bij verwijderen en toevoegen van kortingscodes Van de volgende standaard functies is bekend dat Lightspeed het niet ondersteunt: Van de volgende aanvullende functies is bekend dat Lightspeed het niet ondersteunt: UPS ' Altijd met UPS Express Saver verzenden ' Known issues & bugs Gratis verzending coupons werken niet en hebben geen directe invloed op de prijs van verzendkosten. De checkout wordt niet weergegeven De checkout module moet worden 'geactiveerd' in de order import dataflow binnen de Monta portal. Soms is er sprake van een bug waar de module al is geactiveerd. Wanneer dit gebeurd kan je hem verwijderen met de 'Verwijder checkout service' knop. Als dit niet werkt kan de checkout handmatig worden verwijderd uit de database door IT. Na het opnieuw installeren van de module zou hij weer moeten werken."
  },
  "Algemene-informatie/Checkout-module/Magento-Checkout/index.html": {
    "href": "Algemene-informatie/Checkout-module/Magento-Checkout/index.html",
    "title": "Magento Checkout",
    "keywords": "Magento Checkout Met de Magento checkout kunnen bezorgopties worden getoond aan de klant in de Magento webshop bij het afrekenen. Belangrijk bij Magento checkout Magento is een open-source softwarepakket die u zelf op een server installeert en onderhoud. Onze checkout module ondersteund de standaard Magento installatie. Het kan echter zijn dat uw webshop aanpassingen heeft, bijvoorbeeld andere plugins, waardoor problemen ontstaan met de Monta checkout plugin. Het is voor Monta niet mogelijk om alle plugins van de wereld goed samen te laten werken. Daarom hebben we de programmacode vrij beschikbaar gemaakt op GitHub zodat de klant zelf een aangepast versie van de checkout kan (laten) maken om deze problemen op te lossen. Bij problemen met veelgebruikte plugins kunnen we natuurlijk kijken of we een oplossing kunnen bieden in onze standaardversie. Aanvullend betekend dit dat niet elke checkout het zelfde is. Talen De volgende talen in de Magento checkout worden ondersteund: Nederlands Configuratie Zorg dat de klant de module Monta Checkout op Magento heeft geïnstalleerd. De klant kan de app vinden in Stores > Configuration > Sales > Shipping Methods > Montapacking Maak in de MP REST Api gegevens aan De klant kan in de instellingen de benodigde velden vullen: Algemene informatie en functies Van de volgende functies is bekend dat Magento het wel ondersteund: Berekenen van verzendmethoden inclusief prijs Weergeven van verzendopties Weergeven van levertijden Leverdag kiezen Automatisch geselecteerde verzender gebaseerd op voorkeur uit montaportal Aanpassen van verzendernaam Van de volgende standaard functies is bekend dat Magento het niet ondersteund: Van de volgende aanvullende functies is bekend dat Magento het niet ondersteund: Known issues & bugs Gratis verzending op coupons werken niet. Deze hebben geen invloed op de prijzen in de plugin. Wel is er een github branch waar een gelimiteerde oplossing is gemaakt voor klanten die dit toch werkend willen hebben. U moet deze wijzigingen dan zelf overnemen. Let op, dit kan problemen veroorzaken met het toestaan van gratis verzending na het selecteren van een verzendoptie in onze checkout. Alle prijzen die naar de REST Api gaan zijn de originele prijzen, kortingen hebben dus geen invloed op de berekende verzendprijs. Dit betekent dat wanneer er door korting de winkelmandprijs onder de gratis verzendinggrens komt er alsnog gratis verzending acties zou worden."
  },
  "Algemene-informatie/Checkout-module/Shopify-Checkout/index.html": {
    "href": "Algemene-informatie/Checkout-module/Shopify-Checkout/index.html",
    "title": "Shopify Checkout",
    "keywords": "Shopify Checkout Met de checkout module kan de klant verschillende functionaliteiten tonen in zijn webshop bij het afrekenen. Belangrijk bij Shopify checkout Het berekenen van verzendkosten tijdens de checkout is bij Shopify geen standaard functie. De webshop dient te beschikken over de module 'Door externe partij berekende verzendkosten'. Deze module is inbegrepen bij het Advanced Abbonnement en is los bij te bestellen via Shopify support voor ca. €20,- per maand. Het controleren van het actieve Shopify abbonnement kan via IT. Talen De volgende talen worden ondersteund in de Shopify checkout: Nederlands Engels Configuratie Controleer of de doel-webshop beschikt over de juiste module. Zorg dat alle tarieven en verzendmethoden + opties juist staan in de Monta portal. Installeer de Monta Checkout App voor Shopify Maak in de MP REST Api gegevens aan Zie handleiding: Installatie REST API Doorloop de stappen: Vul de benodigde informatie in. Controleer of de checkout werkt. Binnen Shopify kun je ook vervoerders instellen. Standaard voegt de Monta Checkout deze opties toe. De klant kan optioneel extra acties uitvoeren als: Kosten toevoegen Landen uitsluiten Vervoerders uitsluiten Het is echter aangeraden om deze instellingen op standaard te laten, omdat dit wellicht kan conflicteren met de gegevens in de MontaPortal. Algemene informatie en functies Shopify ondersteund de meeste front-end functionaliteiten van onze checkout module: Van de volgende functies is bekend dat Shopify het wel ondersteund: Berekenen van verzendmethoden inclusief prijs Weergeven van verzendopties Weergeven van levertijden Van de volgende standaard functies is bekend dat Shopify het niet ondersteund: Leverdag kiezen Known issues & Bugs Alleen de originele artikel kosten kunnen gebruikt worden voor het berekenen van prijzen. Dit is een limitatie van de data die ontvangen word vanuit Shopify. Checkout wordt niet weergegeven Vaak beschikt de klant niet over de juiste module. Zie `Belangrijk bij Shopify Checkout`"
  },
  "Algemene-informatie/Checkout-module/Woocommerce-Checkout/index.html": {
    "href": "Algemene-informatie/Checkout-module/Woocommerce-Checkout/index.html",
    "title": "Woocommerce Checkout",
    "keywords": "Woocommerce Checkout Met de WooCommerce checkout kunnen bezorgopties worden getoond aan de klant in de Woocommerce webshop bij het afrekenen. Belangrijk bij WooCommerce checkout WooCommerce is een open-source softwarepakket die u zelf op een server installeert en onderhoud. Onze checkout module ondersteund de standaard WooCommerce installatie. Het kan echter zijn dat uw webshop aanpassingen heeft, bijvoorbeeld andere plugins, waardoor problemen ontstaan met de Monta checkout plugin. Het is voor Monta niet mogelijk om alle plugins van de wereld goed samen te laten werken. Daarom hebben we de programmacode vrij beschikbaar gemaakt op GitHub zodat de klant zelf een aangepast versie van de checkout kan (laten) maken om deze problemen op te lossen. Bij problemen met veelgebruikte plugins kunnen we natuurlijk kijken of we een oplossing kunnen bieden in onze standaardversie. Aanvullend betekend dit dat niet elke checkout het zelfde is. Talen De volgende talen in de Woocommerce checkout worden ondersteund: Engels (standaard) Nederlands Duits Configuratie Zorg dat alle tarieven en verzendmethoden + opties juist staan in de Monta portal. Installeer de Monta Checkout App voor Woocommerce Maak in de MP REST Api gegevens aan. Zie handleiding: Installatie REST API Doorloop de stappen: Doorloop de benodigde stappen in Woocommerce. Veld \"Shop\" in Wordpress staat gelijk aan \"Channel\" in de Montaportal (Channel) Velden \"Username\" en \"Password kun je doormiddel van de REST API credentials uit stap 4 invullen. Vul in Woocommerce de overige velden in naar wens. Test de checkout Algemene informatie en functies Van de volgende functies is bekend dat WooCommerce het wel ondersteund: Berekenen van verzendmethoden inclusief prijs Weergeven van verzendopties Weergeven van levertijden Leverdag kiezen Gratis verzending met coupons Automatisch selecteren van in Montaportal geselecteerde voorkeursverzender Aanpassen verzendernamen Van de volgende standaard functies is bekend dat WooCommerce het niet ondersteund: Van de volgende aanvullende functies is bekend dat WooCommerce het niet ondersteund: Known issues & bugs Originele prijs is gebruikt voor het berekenen van korting. Foute Vertaling Mogelijke oorzaken in fouten vertaling: Er kan een fout in de website zitten die veroorzaakt dat niet het juiste vertaalbestand wordt ingeladen door Wordpress (montapacking-checkout.nl-NL). Wellicht dat een plug-in in conflict is wat leidt tot een JS foutmelding. Ook zou het kunnen zijn dat de \"server-locale\" van PHP anders is dan nl_NL."
  },
  "Algemene-informatie/Checkout-module/index.html": {
    "href": "Algemene-informatie/Checkout-module/index.html",
    "title": "Checkout module",
    "keywords": "Checkout module Met een checkout module kan de klant bezorgopties tonen in zijn webshop bij het afrekenen. Algemene beschrijving De checkout module is een module/plug-in/app die de klant op zijn website kan laten tonen. Deze module zorgt ervoor dat de consument op de website een vervoerder kan kiezen. De beschikbare vervoerders worden door middel van slimme programmatuur door Monta geselecteerd. De klant kan gelijk zien wanneer zijn pakketje aankomt en wat het hem kost. De webshop eigenaar kan zelf instellen hoeveel een klant voor een bepaalde vervoerder betaalt (Instelbaar per land). Ook kijkt het systeem of verzending met deze vervoerder mogelijk is in combinatie met o.a. het gewicht; cutoff tijden en voorkeur van verkoper. Monta heeft voor een aantal webshop platforms een checkout module ontwikkeld. Dit is een extra dienst die gratis gebruikt kan worden. Monta kan niet garanderen dat onze checkout module goed werkt in alle verschillende klantsituaties. Monta garandeert niet dat problemen die in een bepaalde sitatie ontstaan worden opgelost. Voor meer informatie zie Hoe gaan we om met problemen?. Het is niet verplicht om de Monta checkout te gebruiken. Het is ook mogelijk om helemaal geen verzender keuze aan te bieden in de webshop. Er wordt dan een vervoerder bepaald door Monta. Nadeel is dat de consument ook niet de mogelijkheid heeft om bijvoorbeeld een afhaalpunt te kiezen. Het is ook mogelijk om een andere checkout module te gebruiken of dat de klant zelf iets ontwikkelt. Hierbij moet dan wel ingeregeld worden dat de gekozen verzender in de koppeling wordt overgenomen, zodat Monta het pakket met de gekozen verzender verzend. Zie hiervoor Kopppeling - Order import - verzenderkeuze importeren. Hoe ziet deze module eruit? Hoe deze module eruitziet is een beetje verschillend per webshop platform. Op sommige platformen kan de klant ook aanpassingen doen. In de kern ziet de module er zo uit: WooCommerce In WooCommerce is er sprake van een dynamische weergave. Standaard wordt de default shipper getoond: Wanneer je een andere bezorgoptie wilt zien is dit de weergave: Voor ophaalpunten is dit de weergave: Shopify In Shopify is er sprake van de volgende weergave. Aanvullende verzendopties worden in het zelfde schema weergegeven als extra te selecteren opties. Denk hierbij aan: Pick-up punten (Te definiëren in instellingen, standaard 3), Avondlevering, Handtekening etc. Magento De Magento weergave heeft veel weg van de WooCommerce weergave: En heeft ook een apart venster voor ophaalpunten: Lightspeed De Lightspeed checkout is vrij gelimiteerd. Dit is een bekende weergave: BigCommerce Voor BigCommerce zijn op het moment van schrijven nog geen actieve klanten die de checkout gebruiken. Checkout beschikbaar bij platformen WooCommerce: Checkout WooCommerce Lightspeed Shopify: Montapacking Checkout Magento: Montapacking Checkout Bigcommerce Checkout Functionaliteiten Berekenen van verzendmethoden inclusief prijs Met deze functie berekent de app alle geschikte vervoerders die ingesteld staan in de montaportal en weergeeft deze in de webshop. Dit is afhankelijk van de adresgegevens en het product. Daarnaast is het mogelijk om prijzen, limitaties en kortingen mee te geven. Weergeven van verzendopties Met deze functie weergeeft de app alle ingestelde bezorgopties. Denk hierbij aan avondlevering, pick-up points, handtekening bij ontvangst etc. Voorbeeld uit Woocommerce: Weergeven van levertijden Met deze functie weergeeft de app de geschatte leverdatum per vervoerder. Deze informatie komt overeen met de getoonde informatie in de montaportal bij de berekening. Voorbeeld uit Shopify: Leverdag kiezen Deze functionaliteit biedt de consument de optie om de levering uit te stellen, er kan een datum geselecteerd worden en per datum zal worden berekend welke vervoerders en tijdvakken er beschikbaar zijn. Voorbeeld uit Woocommerce: Korting bij uitgestelde leverdag Het is mogelijk om korting in te stellen voor de consument voor bepaalde afleverdagen. Zo'n 70% van de consumenten kiest voor een uitgestelde leverdag als ze daarmee korting kunnen krijgen. Uitgestelde aflevering zorgt voor een efficiëntere logistieke verwerking: er is minder piekbelasting en er kan beter gepland worden. Hieronder sceenshots hoe de korting eruit ziet in de verschillende checkouts: Shopify: Magento: ) Lightspeed: ) Shopware: ) In de onderstaande tabel kun je gemakkelijk zien welke functionaliteiten in grote lijnen worden ondersteund door een CMS. Voor specifieke informatie kun je hier terecht: Shopify Checkout -Woocommerce Checkout - Lightspeed Checkout - BigCommerce Checkout- Magento Checkout Shopify WooCommerce Lightspeed BigCommerce Magento Afleverdatum weergeven Ja Ja Nee Onbekend Ja Aanvullende actie vereist? App nodig Plug-in nodig Checkout aanzetten via order-import in MP App nodig App nodig Standaard in CMS beschikbaar? Module of advanced abbonement nodig Ja Ja Ja Ja Verzendopties Ja Ja Ja* Onbekend Ja Pick-Up Points Ja Ja Ja Ja Ja 'Standard delivery' Ja Ja Nee Onbekend Ja Leverdag kiezen Nee Ja Nee Onbekend Ja Check product on SKU Ja Ja Nee Leading Stock Ja Nee Controleren op afmetingen (in de cms) Ja Nee *In Lightspeed worden niet alle verzendopties ondersteund. Kijk voor meer info in: Lightspeed Checkout Instellingen mogelijk Welke vervoerders beschikbaar zijn per land. Verzendkosten voor consument per land, dus ook naar afhaalpunten in het buitenland. Per vervoerder verschillende Shipper Options zoals: gratis levering vanaf, avondlevering, niet bij de buren afleveren, tekenen voor ontvangst, etc. Afwijkende verzendkosten vanaf een bepaald gewicht. Dit kan met het weegschaal knopje. Pick up Points Eigenschappen en bijzonderheden: Pickup points worden niet meegenomen in de gewichten/lengte calculatie. Die worden dus altijd getoond. Dit is bij elke checkout van toepassing. Leading Stock Met de optie leading stock kun je specificeren welke voorraadstanden moeten worden gebruikt bij het berekenen van de levertijd/verzendmethode Check Product on SKU Als de opties check product on sku aan staat, gaan we rekenen met de gewichten/afmetingen die in de MP bekend zijn. Aan de hand van die gegevens worden de beschikbare verzenders getoond. Controleren op afmetingen Bij de WooCommerce checkout is het mogelijk om in te stellen dat de checkout rekening houdt met de afmetingen van de producten om de verzender te selecteren. Als in, het is in de restapi ingebouwd, alleen moet er dan een product meegestuurd worden. En dit wordt alleen in woocommerce gedaan. Andere checkout modules houden hier dus geen rekening mee. Afleverdatum berekenen In de checkout berekent Monta de verwachte leverdatum. Dit doen wij op basis van de volgende parameters: Voorraad: Monta kijkt of er voorraad is van het artikel. Indien geen voorraad zal dit de verwachte afleverdatum beïnvloeden. Cutoff: Monta kijkt naar de afhaaltijden van de vervoerder om de inschatting te maken wanneer de order zal worden verzonden. Configuratie Voor de installatie van één van onze checkouts vragen we altijd de klant een google api key in te vullen. Deze is middels deze url te verkrijgen: https://developers.google.com/maps/documentation/javascript/get-api-key. Hoe gaan we om met problemen / aanpassingen vanuit klant? Shopify en Lightspeed zijn SaaS-oplossingen. De programmatuur is hierbij standaard en de checkout module werkt hierbij dan ook vlekkeloos. WooCommerce en Magento checkout zijn softwarepakketten die u zelf op een server installeert en onderhoud. Onze checkout module ondersteund de standaard WooCommerce en Magento installatie. Het kan echter zijn dat uw webshop aanpassingen heeft, bijvoorbeeld andere plugins, waardoor problemen ontstaan met de Monta checkout plugin. Het is voor Monta niet te doen om alle plugins van de wereld goed samen te laten werken. Daarom hebben we de programmacode vrij beschikbaar gemaakt op GitHub zodat de klant zelf een aangepast versie van de checkout kan (laten) maken om deze problemen op te lossen. Bij problemen met veelgebruikte plugins kunnen we natuurlijk kijken of we een oplossing kunnen bieden in onze standaardversie. Veel gestelde vragen Wat is de functie 'standard delivery'? Standard delivery is een optie die onder één noemer (standaard verzending) alle mogelijke vervoerders (te selecteren in de montaportal) laat zien; waar je bij andere vervoerders apart de vervoerders laat zien. Wij berekenen dan als de order binnen komt de meest geschikte vervoerder op basis van de informatie die bij ons bekend is. Pick-up points worden niet getoond Problemen met het tonen van pickuppoints worden mogelijk veroorzaakt door de google api key: De googlekey is niet correct ingesteld (het ontbreken van creditcard gegevens in je google account) De googlekey heeft niet al de correcte regels. Deze instellingen kunnen worden gedaan in de Montaportal onder: Home-> Settings -> Checkout options"
  },
  "Algemene-informatie/Dropshipment/index.html": {
    "href": "Algemene-informatie/Dropshipment/index.html",
    "title": "Dropshipment",
    "keywords": "Dropshipment Dropshipment is dat de leverancier van een klant zelf de orders verzend. Aangezien er dus geen voorraad van de leverancier aanwezig is, komen de orders in backorder. Het is natuurlijk mogelijk de backorder handmatig te verwijderen uit Montaportal en de dropshipper de orderinformatie te sturen zodat die de order kan gaan verwerken. Om dit handwerk te voorkomen zijn verschillende mogelijkheden. Hierin moet onderscheid gemaakt worden in: De dropshipper werkt ook met Monta, wat op twee manieren kan: De dropshipper heeft het fulfilment ondergebracht in een magazijn van Monta De dropshipper doet het fulfilmet zelf met de MontaWMS software De dropshipper werkt niet met Monta Ook kan de klant de wens hebben om de voorraad van de dropshipper mee te tellen in de voorraadkoppeling naar de webshop. De dropshipper werkt ook met Monta Orders Om dit op te zetten moet als eerste bij de klant een apart kanaal worden gemaakt voor de dropship orders. Dit kanaal moet worden gekoppeld aan het magazijn waar de voorraad ligt. Dit kan een magazijn zijn van Monta, die het fulfilment doet voor de dropshipper, of een eigen magazijn van de dropshipper als die MontaWMS gebruikt. Vervolgens kan op twee manier ingeregeld worden dat de orders worden omgezet naar die origin: Bij de klant kan worden ingesteld dat alle orders worden omgezet naar het magazijn waar de voorraad is. Bij de supplier kan het ID van het magazijn worden ingesteld waar de order naartoe omgezet worden worden. Het verschil is dat smaak 1 alleen werkt als er voorraad is van de producten in het andere magazijn. Bij smaakt 2 worden ook backorders omgezet naar het kanaal wat gekoppeld is aan dat magazijn. Smaak 1 kan ook als nadeel hebben dat alle orders worden omgezet naar het magazijn waar de voorraad is, terwijl dit soms alleen gewenst is voor orders van die supplier. Voorraad Via een groothandel koppeling kan voorraad van de dropshipper klant beschikbaar worden gemaakt worden voor de klant die het verkoopt. Bij het omzetten van de orders wordt dan ook de voorraad in het magazijn intern omgeboekt van de dropshipper naar de klant. Het dropship systeem bied ook de mogelijk om aan de dropshipper te laten zien hoeveel er in backorder staan van een product bij de klant die het verkoopt. Voor het geval de dropshipper achteraf inkoopt. De orderinformatie zelf krijgt de dropshipper pas de zien als de order is omgezet. De dropshipper werkt niet met Monta Orders Aangezien de dropshipper niet met Monta werkt, moeten de orders uit de backorders gehaald worden. En liefst moet ook automatisch de dropshipper geïnformeerd worden. Hiervoor zijn verschillende oplossingen: Automatisch orderregels van bepaalde producten verwijderen Individuele orders automatisch op shipped zetten en mailen naar de dropshipper Op vaste momenten alle orders handmatig op shipped zetten en mailen naar de dropshipper Op vaste momenten alle orders automatisch op shipped zetten en mailen naar de dropshipper Automatisch orderregels van bepaalde producten verwijderen Bij de split- and added products kan ingesteld worden dat bepaalde producten automatisch uit de orders verwijderd worden. Nadelen zijn: de dropshipper wordt niet automatisch geïnformeerd wordt over de order als een order alleen zulke producten heeft blijft een lege order over die wordt geblokkeerd Ondanks de nadelen kan dit een prima oplossing zijn in sommige situaties. Individuele orders automatisch op shipped zetten en mailen naar de dropshipper Er kan ingesteld worden dat orders van producten van de dropshipper automatisch op shipped worden gezet, en dat er een mailtje met de order informatie naar de dropshipper wordt gestuurd. Als een order deels ge-dropshipt moet worden, wordt deze gesplitst. Dit wordt toegepast op de orders als ze in backorder zouden gaan. Dus als de klant toch eigen voorraad heeft van de producten, gaat de order niet in backorder en worden ze niet op shipped gezet en naar de supplier gemaild. Dit kan door IT ingesteld worden. In tblPortalPurchaseSuppliers moeten de kolommen SetOrdersDropshipped en MailOrdersToSupplier op 1 gezet worden. Ook moet een e-mail template ingesteld worden met type OrderToSupplier. Dit template wordt gebruikt voor de e-mail naar de klant. Op vaste momenten alle orders handmatig op shipped zetten en mailen naar de dropshipper Als het om veel orders gaat, is het niet handig dat de dropshipper veel losse mailtjes binnenkrijgt. Daarom is het ook mogelijk om op vaste momenten meerdere orders tegelijk te verwerken. Op de supplier details pagina kan geklikt worden op de knop [Put all backorders from this supplier on shipped (dropship)]. Deze zet de orders van producten van die supplier automatisch op shipped. Hierbij wordt ook een Excel gegenereerd met alle productinformatie, de verstuurd kan worden naar de dropshipper. Op vaste momenten alle orders automatisch op shipped zetten en mailen naar de dropshipper In deze smaak wordt de voorgaande smaak geautomatiseerd. Dit kan op Montaportal ingesteld worden. De geplande taak SupplierDropshipper voert het uit. Voorraad Er zijn twee mogelijkheden om voorraad van de dropshipper beschikbaar te maken voor de klant. Een apart magazijn maken en daar de voorraad in importeren Een aparte Montaportal omgeving maken de voorraad delen met het groothandelsysteem Smaak 1 heeft als nadeel dat voorraad uit een ander magazijn ook wordt gerekend als beschikbare voorraad in het inkoopsysteem. Het inkoopsysteem zal dus niet de suggestie geven om de producten in te kopen omdat ze al op voorraad zijn. Terwijl de wens kan zijn om het inkoopsysteem juist te gebruiken om in te kopen bij de dropshipper."
  },
  "Algemene-informatie/Facturatie/(Interne)-Koppeling-tussen-Monta-en-Exact/index.html": {
    "href": "Algemene-informatie/Facturatie/(Interne)-Koppeling-tussen-Monta-en-Exact/index.html",
    "title": "(Interne) Koppeling tussen Monta en Exact",
    "keywords": "(Interne) Koppeling tussen Monta en Exact De koppeling tussen Exact en Monta doet het volgende: Klanten die in Exact aangemaakt zijn ook in Monta aanmaken Facturen die in Exact betaald zijn ook in GoMonta op betaald zetten Monta klant \"omhangen\" naar andere Exact klant IT kan dit regelen. [[Doelgroep: IT In tblRelaties de ExactAdministratieRelatieID's omwisselen In tblRelatieFactuurAdres de RelatieID's omwisselen In tblRelaties de bedrijfsnaam aanpassen. Let op: het is nog niet bevestigd of dit werkt. Maar recent heb ik (jvds) dit gedaan voor Klaas om Braumarkt om te hangen naar Grainvest. Ik zou nog terughoren van Klaas of het gewerkt heeft."
  },
  "Algemene-informatie/Facturatie/Facturatiemogelijkheden/Facturatie-planning/index.html": {
    "href": "Algemene-informatie/Facturatie/Facturatiemogelijkheden/Facturatie-planning/index.html",
    "title": "Facturatie planning",
    "keywords": "Facturatie planning Binnen gomonta is er een mogelijkheid om automatisch verkoop facturen te laten genereren. Er kan bijvoorbeeld ingesteld worden dat 's nachts de verkoopfactuur gegenereerd wordt, zodat je niet hoeft te wachten op het genereren van de verkoopfactuur, maar de verkoopfactuur direct kunt controleren. Instelmogelijkheden Zoals te zien is in het instellingen scherm kan een verkoopfactuur of een weekfactuur of een maandfactuur automatisch gegenereerd worden. Wanneer is dit handig Bij verkoopfacturen die relatief eenvoudig zijn, zal het na het automatisch genereren van de verkoopfactuur vaak voorkomen dat er geen missende tarieven zijn en kan de verkoopfactuur na controle definitief gemaakt worden. Ook kan het handig zijn bij verkoopfacturen die gebaseerd zijn op veel orders de verkoopfactuur al te laten genereren, om zo niet te hoeven wachten op het proces van verkoopfacturen genereren. Maar het is ook mogelijk om net voor het einde van de maand vast een verkoopfactuur te laten genereren om vast te checken of er missende tarieven zijn. Zodat in de korte periode dat de verkoopfacturen definitief gemaakt moeten worden er minder tijd besteed wordt aan het toevoegen van missende tarieven."
  },
  "Algemene-informatie/Facturatie/Facturatiemogelijkheden/index.html": {
    "href": "Algemene-informatie/Facturatie/Facturatiemogelijkheden/index.html",
    "title": "Facturatiemogelijkheden",
    "keywords": "Facturatiemogelijkheden Op deze pagina staan verschillende diverse facturatie opties binnen Monta beschreven. Er is meer beschikbaar dan op deze pagina beschreven staat. Tarief instellingen Value added service orders Het 'Value added service orders' vinkje bij het tabblad Outbound is bedoelt voor het uitsluiten van verpakkingsorders. Verpakkingsorders worden dan niet meegerekend bij de arbeid van orders (orders, lines en items). Weekendtoeslag Het is mogelijk om een toeslag te rekenen voor orders die op zaterdag of zondag verzonden worden. Er wordt rekening gehouden met orders die eigenlijk op een andere dag verzonden hadden moeten worden. De toeslag wordt gerekend als de geplande verzenddatum op zaterdag of zondag is en het ook daadwerkelijk op de geplande verzenddatum verzonden is. Je kunt deze toeslag in de tariefperiode instellen bij Outbound pick-pack kosten. Opslag kosten De opslag wordt elke week berekend in de nacht van woensdag op donderdag. Dat bleek een opslag hoeveelheid te geven die het weekgemiddelde het beste benaderd. Volume gewicht (bedrag) Volume gewicht fee is een fee die op item basis berekend wordt. Dit is een manier om de pick pack van grote producten duurder te maken dan de pick pack van kleine producten. De toeslag komt bovenop de ingevulde tarieven bij pick pack. Kijk ook even hieronder, bij volume gewicht factor, dat is eigenlijk de aanbevolen manier om met volume gewicht te werken. Volume gewicht factor Volume gewicht factor wordt gebruikt om zowel bij de Inbound, Retoruren als Outbound een factor toe te passen op de itemfee's. Hiermee kun je grote producten duurder maken en kleine producten goedkoper. Er wordt een factuurregel toegevoegd met de factor van het bedrag. Dus als je 20% korting wilt geven bij een volume gewicht categorie, moet je 0,8 invullen als factor. Verzender tarieven Het instellen van verzender tarieven kan op verschillende manieren. Standaard Standaard wordt er gebruik gemaakt van gewicht staffels. Valt het gewicht van het verzonden pakket binnen de staffel zal dat tarief gerekend worden. Zie het voorbeeld hieronder, een pakket van PostNL binnen NL van 7kg zal dus €5 kosten. Volume gewicht Het tarief kan ook berekend worden op basis van het volume gewicht van het verzonden pakket. Om dit te gebruiken moeten de volgende velden worden ingevuld: Gewicht Tot, Lengte, Breedte, Hoogte en Liters. Hieronder is te zien hoe dat ingesteld moet worden bij de verzender tarieven: Let op: Gewicht Van hoeft niet ingevuld te worden als je gebruikt maakt van volume gewicht facturatie Geen van de velden (Lengte, Breedte, Hoogte) mag leeg gelaten worden. Ze zijn verplicht bij het gebruik van volume gewicht. Als je de combinatie verzender en land hebt waarvan er bij 1 geen en 1 wel volume gewicht is ingevuld zal dit niet werken. Hij zal dan altijd diegene pakken waar geen volume gewicht is ingevuld. Hoe wordt het tarief dan berekend? In het kort: Eerst wordt er bij de verzender opgevraagd of ze het verzonden pakket al gemeten en gewogen hebben, als dat zo is pakken we de informatie van de verzender, is dat nog niet beschikbaar gebruiken we de gegevens die we binnen Monta zelf hebben. Voor een uitgebreide uitleg, zie onderstaand diagram: MontaMoney = GoMonta ↑ Volume gewicht sleutel Het factureren met een volume gewicht sleutel wordt alleen gebruikt als een verzender dit hanteert en het is aangegeven in de tariefsheet. De gehanteerde sleutel is per verzender verschillend en is ingesteld door IT. Het factureren van de volume gewicht sleutel werkt als volgt: Staat het vinkje 'Gebruik volume gewicht sleutel' aan, haal dan de volume gewicht sleutel op van de verzender. Het systeem controleert vervolgens of de afmetingen van de gebruikte drager of het grootste materiaal in de zending gebruikt moeten worden voor de verdere berekening. Het systeem gebruikt de gekozen afmetingen om de volgende formule uit te voeren: (=L* B *H in cm / Volume gewicht sleutel) Vervolgens wordt het resultaat van de formule vergeleken met het gewicht van het pakket. Hier wordt de grootste van de twee van gepakt. Dat wordt je volume gewicht. Het systeem gebruikt dat nieuwe (volume) gewicht om de rest van de tarieven te bepalen zoals dat normaal ook gaat. Let op! Als je de combinatie verzender en land hebt waarvan er bij 1 geen en 1 wel 'Gebruik volume gewicht sleutel' is aangevinkt zal dit niet werken. Er zal dan een error geschreven worden dat bij die combinatie alle volume gewicht sleutel vinkjes aangevinkt moeten worden. Daarnaast kan in de tariefsheet alleen het vinkje aangezet worden bij een verzender waarbij ook echt een volume gewicht sleutel is ingevoerd door IT. Toeslagen en boetes Bij Toeslagen/boetes is het tarief dat je invult, het percentage marge op de inkoopprijs. Wil je geen marge, dan vul je 0,00 in. Wil je bijvoorbeeld 8% marge, dan vul je 8,00 in. Let op! Toeslagen en boetes worden pas gefactureerd wanneer de facturen van de verzenders zijn ontvangen en ingelezen. Dit kan later zijn dan de porto wordt gefactureerd. All-in facturatie De all-in tarieven worden toegepast per verzonden pakket. Dit is in te stellen onder het kopje 'Vervoerders' (GoMonta - Verkooptarieven). Daar kan per verzender een verdeling ingesteld worden waaruit het all-in tarief bestaat. De verdeling zal bestaan uit Porto, Arbeid, Verzendverpakking en Opslag (optioneel). De som van deze verdeling zal het totaalbedrag zijn die de klant op zijn factuur ziet staan en ook zal moeten betalen per zending. Het ingestelde all-in tarief zal er als volgt uit zien (Arbeid: €1, Porto: €3, Drager: €1 - Totaal: €5): Het is belangrijk om deze verdeling goed in te vullen zodat de kosten op de juiste posten worden weggeschreven. Op de factuur zal dit er zo uit zien (grijze regels zal de klant niet zien): Let op! Als er bij een verzender tarief een all-in tarief is ingesteld zal dit bij alle andere verzender tarieven ook ingesteld moeten worden. Let op! Het gebruik van opslag bij all-in is optioneel. Als hier een tarief is ingesteld zal de opslag per order worden doorberekend en niet meer zoals op de gebruikelijke manier. Houd er rekening mee dat een tarief van 0 euro ook een ingesteld tarief is. Wil je dat de opslag niet all-in is, laat het veld all-in opslag dan helemaal leeg. RMA uitbetalingen De klant heeft in de MontaPortal ingesteld hoeveel de consument betaald voor zijn RMA zending. Deze betalingen doet de consument via het betaalsysteem Mollie. Bij het maken van de factuur geven wij deze bedragen terug aan de klant. Dit gaat als volgt bij het factureren: Wij maken een factuur aan voor de klant Op dat moment vragen we alle betalingen, binnen de periode van de factuur, voor die specifieke klant, op bij Mollie en maken hier een totaal bedrag van Vervolgens berekenen we alle transactiekosten die gemaakt zijn bij Mollie, die transactiekosten trekken we van het totaal bedrag af wat het uiteindelijke bedrag vormt wat we terug geven aan de klant Postonderzoeken uitbetalingen Postonderzoeken worden automatisch gefactureerd op een factuur. Postonderzoeken worden uitbetaald als er in GoMonta bij een postonderzoek een claimbedrag is ingevuld en de status Gesloten of Claim accepted heeft. Als een claim bedrag is gefactureerd kan deze in GoMonta niet meer worden aangepast. Export 16 is beschikbaar om per eorder te bekijken welk claim bedrag er is uitbetaald. Korting bij extra verzenddagen Voor magazijnen is het prettig als niet alle orders dezelfde dag verzonden hoeven te worden. Om dit te stimuleren is het mogelijk korting te geven op orders met extra verzenddagen. Extra verzenddagen kunnen op de volgende manier ingesteld worden bij orders: Bij het kanaal kan ingesteld worden dat alle orders van dat kanaal extra verzenddagen krijgen. Vanuit de koppeling kunnen extra verzenddagen worden meegegeven. Zie toelichting hieronder. Extra verzenddagen vanuit de koppeling Als de webshop door de consument wil laten kiezen voor extra verzenddagen moet het vanuit de koppeling worden meegegeven. Dit kan op twee manieren: via een verzenderkeuze mapping. via de Monta checkout. Zie checkout - functionaliteiten - korting bij uitgestelde leverdag. LET OP: de korting bij extra verzenddagen die bij de facturatie kan worden ingesteld werkt nog niet voor orders die via de Monta checkout binnenkomen. Dit omdat de orders met een uitgestelde verzenddag vanuit de Monta checkout altijd in Etransit komen omdat consument een specifieke afleverdag kiest. Er wordt aan gewerkt om ook in de checkout een 'datum range' optie te maken (bijv 2-5 werkdagen) waarbij de korting wel toegepast wordt. Tarief periode instellingen Tariefperiode per magazijn Het is mogelijk om voor een relatie per magazijn andere tarieven toe te passen. Dit doe je door een tariefperiode te koppelen aan een magazijn. Het koppelen doe je in GoMonta bij het aanmaken of aanpassen van een tariefperiode. Gebruik deze optie alleen als een klant in meerdere magazijnen ligt en verschillende tarieven hanteert. Voorbeeld: Een klant ligt in Breda en Den Bosch. In Breda kost het verwerken van een order 2 euro en in Den Bosch 2 euro en 50 cent. Status Een tarief periode kan vier verschillende statussen hebben. De statussen zijn: Open Afgewezen Geaccepteerd Gearchiveerd Een tarief periode kan pas gebruikt worden als hij de status 'Geaccepteerd' heeft. Een nieuw aangemaakte of pas aangepaste tarief periode zal de status 'Open' krijgen, waarna hij door iemand controleert en geaccepteerd moet worden. Het is erg belangrijk dat bij de controle goed wordt gekeken of de juiste tarieven zijn ingevuld. Mocht dit niet het geval zijn moet aan de tarief periode de status 'Afgewezen' worden gegeven, waarna er tarieven worden aangepast en opnieuw gecontroleerd. Is MontaWMS Wanneer het vinkje IsMontaWms is aangevinkt bij een sales invoice tarief periode, zal bij sales invoices die in die periode gemaakt worden ook worden opgeslagen dat het gaat om een MontaWMS sales invoice. De sales invoice is niet anders dan andere sales invoices, het enige verschil is dat als de financiële details naar het boekhoudpakket Exact worden doorgezet, dat 1 grootboek verschillend is. Waar bij reguliere sales invoices een deel van de omzet op arbeid (grootboek 8000) komt, zals bij een MontaWMS sales invoice die omzet op licenties (grootboek 8410) komen. Is MontaWms WarehouseOwner Wanneer een WMS klant vanuit zijn magazijn orders verzend van andere en/of meerdere relaties kan met de optie \"Is MontaWMS warehouse owner\" aangegeven worden. Als dit aan staat worden de orders van de verschillende relaties op 1 factuur gezet worden richting de betreffende WMS klant. De orders worden bij de verschillende relaties als gefactureerd gemarkeerd."
  },
  "Algemene-informatie/Facturatie/Factuur-aanmaken-IT-projecten/index.html": {
    "href": "Algemene-informatie/Facturatie/Factuur-aanmaken-IT-projecten/index.html",
    "title": "Factuur aanmaken IT projecten",
    "keywords": "Factuur aanmaken IT projecten Factuur aanmaken IT projecten Ga naar Kantoor -> Verkoopfactuur aanmaken: Vul de volgende gegevens in en klik op handmatig aanmaken: Klik Rechtsboven op Factuur bewerken: Pas het onderwerp naar behoren aan: Het onderwerp op factuurkopniveau is altijd: IT kosten. De omschrijving op de regel is variabel. Maak een nieuwe factuurregel aan (1) Plaats een omschrijving (2); Selecteer grootboek 8720; en voer het bedrag in. Druk vervolgens op toevoegen. Sla de factuur op: Maak de factuur en verstuur PDF: Genereer de PDF, klik op yes: Bij de volgende vraag, klik op NEE: (Anders komt de omschrijving van de factuurregel niet op de factuur terecht) Verwijder de specificaties in de bijlage en verstuur de factuur aan de klant. Voorbeeld Factuur:"
  },
  "Algemene-informatie/Facturatie/Probleemoplosser/index.html": {
    "href": "Algemene-informatie/Facturatie/Probleemoplosser/index.html",
    "title": "Probleemoplosser",
    "keywords": "Probleemoplosser Op deze pagina staan verschillende oplossingen van errors die op de facturen kunnen voorkomen. Errors op facturen Eorder already invoiced Oplossing: Klik op het slotje rechtsbovenin bij de factuur Er opent nu een scherm waarin het eorder id ingevuld moet worden om de eorder vrij te geven. Het eorder id is te vinden in de error. Klik op opslaan en maak de factuur opnieuw aan."
  },
  "Algemene-informatie/Facturatie/Transport-inkoop-facturen/index.html": {
    "href": "Algemene-informatie/Facturatie/Transport-inkoop-facturen/index.html",
    "title": "Transport inkoop facturen",
    "keywords": "Transport inkoop facturen Transport inkoopfacturen Voor het inlezen van transport inkoopfacturen die we krijgen van de verschillende verzenders wordt een software tool gebruikt. Bij de meeste verzenders is het inmiddels zo dat de bijlagen van de transport inkoopfacturen ingelezen kunnen worden, zodat de verzendkosten gematcht kunnen worden aan eorders. Inlezen van transport inkoopfacturen De tools die gebruikt worden bij het inlezen en verwerken van de transportinkoopfacturen worden hieronder toegelicht. In principe is alles gemaakt en bedacht door Haiko van der Velden en Remy van Strien met onderstaande taakverdeling:. Alles in T-SQL --> Remy Functionele ontwerpen --> Remy alles in C# gemaakt --> Haiko Techniek / tools die gebruikt worden om functionele ontwerp te realiseren --> Haiko ********** De informatie hieronder is meer van technische aard ********** Waar draaien de websites/services De transport inkoopfacturen website bestaat uit verschillende onderdelen die allemaal op de MP-WEB09 draaien. Jasper Verhaar heeft geholpen bij de recente migratie van de web07 naar web09 en onderhoud de MP-WEB09. toeslagservice.monta.nl Zou een service moeten zijn die voor TransportinkoopfacturenV2.monta.nl de instructies voor de toeslagen doorzet naar ??sqlgraph??, omdat die beter werkt met T-sql instructies. Hiermee worden de instellingen opgehaald voor de verwerking van de ingelezen inkoopfactuurregels. Devops: https://dev.azure.com/MontaDev/_git/MontaInkoopTransportServiceSolution?path=/MontaInkoopTransportService/ToeslagService transportinkoopfacturen.monta.nl Website voor de controle van de ingelezen inkoopfacturen, het verwerken van de kruisposten en hier moeten alle configuratieschermen komen voor de TPT voor alle acties die nu rechtstreeks in de DB worden uitvoerd. Inloggen op de website gaat via Azure Active Directory. Hierbij moet de gebruiker (via inheritance) de Gomonta Finance rol hebben. Iedereen met een IT rol heeft dit. Website: https://transportinkoopfacturen.monta.nl/ Devops: https://dev.azure.com/MontaDev/MontaTransportPurchaseTools transportinkoopfacturenv2.monta.nl Inlezen, transformeren en wegschrijven van de inkoopfacturen. Via de website worden de bestanden (.xlsx en .csv bestanden) per verzender ingelezen en vervolgens via deze service verwerkt en gematcht (veelal via TT code) aan een eorderid. Het resultaat wordt in de correcte tabellen op de Finance DB (SQL06) gezet. De belangrijkste tabellen hierbij zijn: tblInkoopDetail: bevat alle regels met de gematchte inkoopregels tblInkoopDetailTransportKruispostNoMatch: bevat alle regels met nomatch inkoopregels tblInkoop: bevat alle eorderid's van orders waarvoor we transportkosten verwachten en die dus gebruikt wordt voor het matchen met een samenvatting van enkele belangrijke ordergegevens voor rapportage doeleinde en KPI. Echter zijn er nog veel meer tabellen met allemaal instellingen, die nodig zijn bij het verwerkingsproces. Op de website log je in via je AD account, onduidelijk is of hier nog specifieke rechten voor nodig zijn. Website: https://transportinkoopfacturenv2.monta.nl/ Devops: https://dev.azure.com/MontaDev/MontaInkoopTransportServiceSolution transportinkoopfacturenwebservice.monta.nl Dit is de aparte service waarin Hangfire nu draait. Oorspronkelijk was dit onderdeel van Transportinkoopfacturen.monta.nl maar de taken die we schedulen hierin gingen dan alleen starten als ook de website een keer was geopend door iemand en dat was niet handig voor taken die welke dag moeten draaien. Toen heeft Haiko daar een aparte service voor gemaakt. Devops: https://dev.azure.com/MontaDev/InkoopTransportJobs Hangfire taken Rondom de transport inkoopfacuturen draaien een aantal periodieke taken. Deze worden uitgevoerd door hangfire. Een dashboard van de uitgevoerde taken is te zien via https://transportinkoopfacturen.monta.nl/hangfire/ en hier https://transportinkoopfacturen.monta.nl/Home/Jobs w.google"
  },
  "Algemene-informatie/Facturatie/index.html": {
    "href": "Algemene-informatie/Facturatie/index.html",
    "title": "Facturatie",
    "keywords": "Facturatie Hier is informatie te vinden over de facturatie."
  },
  "Algemene-informatie/Gamification/index.html": {
    "href": "Algemene-informatie/Gamification/index.html",
    "title": "Gamification",
    "keywords": "Gamification Binnen Monta wordt er gebruik gemaakt van een gamification systeem. Gamification is een project dat begin 2020 gebouwd is met een aantal doelen; Een leuke beloning/aardigheidje mogelijk maken voor logistieke medewerkers die een stapje harder lopen. Een manier om het verstrekken van bedrijfskleding bij nieuwe medewerkers te managen. Het opzetten van een systeem waar later ook ander typen beloningen/doelgroepen in mogelijk zijn Gouden montacoins Bij gamification kunnen collega's op verschillende manieren montacoins krijgen Door individueel uurwinnaar te zijn in een bepaalde activiteit zoals inbounden, picken, echecken etc. Door als team de dagprestatie te halen. De dagprestatie is een combinatie van outbound tijdigheid van 99,5% of hoger, tt01 op 0 en een joker percentage van 0,5% of lager. Ook krijg je soms random montacoins, gewoon om waardering te laten zien dat je aan het werk bent. En als je jarig bent, krijg je montacoins. Dan is er ook nog de mogelijkheid dat een vestigingsmanager coins kan uitdelen aan medewerkers die werkzaamheden doen die niet in het systeem gemeten worden en waar dan ook geen montacoins mee verdiend kunnen worden. 10% van het aantal montacoins dat op een vestiging verdiend is kan op deze manier extra uitgedeeld worden. Dit zijn allemaal gouden montacoins Zilveren montacoins Als je in dienst komt bij Monta, krijg je van HR zilveren montacoins. Deze kun je besteden om bedrijfskleding te bestellen in de montashop. Inzicht in je montacoins In de meeste software die gebruikt wordt in de magazijnen, is rechts bovenin te zien hoeveel coins je hebt. En er is ook te zien hoe je dat uur staat ten opzichte van de uurwinnaar. Door op de icoontjes te klikken, komt er een popup met informatie over de icoontjes. TV In alle vestigingen hangt een TV waarop te zien is wie de uurwinnaars zijn. Montashop Montacoins kunnen worden uitgegeven in de montashop. Bereikbaar via montashop.nl Om te kunnen bestellen op montashop.nl is het belangrijk dat je prive email adres is doorgegeven aan HR of aan je leidinggevende. Die kunnen dat email adres invullen in MontaMoney. Vervolgens kun je via montashop.nl een account aanmaken met datzelfde email adres: Je krijgt dan een email waarin een link staat om een wachtwoord aan te maken. Als dat gelukt is, kun je inloggen in de montashop en kun je met de montacoins die je gespaard hebt producten bestellen. Bij het bestellen kun je het afleveradres kiezen waar je de producten geleverd wilt hebben. Inzicht in montacoins historie Vestigingsmanagers kunnen in gomonta een stukje historie van montacoins zien. Gomonta --> kantoor --> gamification Dan kom je in een scherm dat gebruikt kan worden om coins uit te delen aan collega's binnen een vestiging die werkzaamheden doen die niet gemeten worden en die de vestigingsmanager toch wil belonen met montacoins. De melding die ingevuld kan worden komt dan ook op de gamification TV van die vestiging. Om in de historie van montacoins te komen, kan op het linkje zoals onderstaand gemarkeerd geklikt worden. Daarnaast is er ook een scherm in gomonta waar je per persoon kunt zien wat het montacoin saldo is en of er een email adres bekend is. Gomonta --> kantoor --> Montacoin transacties ********** De informatie hieronder is meer van technische aard ********** Technische informatie bij gamification RabbitMQ Rabbit MQ vormt een berichten bus tussen verschillende losstaande systemen. Het sturen van RabbitMQ berichten gebeurd in de MontaWebserviceREST. De berichten verlopen via de classe ContractProcessor.cs. Inloggen op de Rabbit MQ server kan via http://mp-rabbit01.montapacking.nl:15672/, de inlognaam en het wachtwoord staan in passwordstate. GamificationService De GamificationService die de RabbitMQ berichten verwerkt draait op de MP-Web10. In de GamificationService zit een klasse RowProcessService, welke de berichten uit RabbitMQ leest. Deze leest de berichten uit en zet deze in een aparte database. De database staat op de volgende plek: Server=MP-SQL06.montapacking.nl\\MSSQL;Database=Gamification Standaard hebben developers geen rechten op deze database. Mocht het echt nodig zijn, kunnen rechten worden gevraagd bij servicedesk. Voor de rest functioneert de GamificationService ook als API voor de resultaten. Hiervoor zitten drie controllers in waar je de informatie uit kan halen. Performance controller: Hier kan je de performance van het huidige uur, de huidige uur leiders, de record houder, de team prestatie van gisteren en de gebruiker geschiedenis opvragen. Company controller: Hier kan je opvragen hoeveel coins een vestiging kan uitgeven en heeft uitgegeven opvragen. Verder kan je hier coins uitreiken aan een medewerker vanuit een vestiging. Een vestigingsmanager kan 10% van het aantal verdiende coins in de vestiging uitdelen aan mensen die acties doen die normaliter niet met coins beloond worden. Denk aan een CS medewerker of iemand die oud papier opruimt. Het toekennen van deze extra coins zit in gomonta. https://gomonta.montapacking.nl/Office/Gamification/Index User controller: Hier haal je de transacties op. Deze zijn te zien in GoMonta -> Admin -> Montacoin transacties. Ook kan de huidige balans worden opgevraagd. Verder kan hier een transactie worden gedaan vanuit de webshop (order of coins uitreiken aan collega's), en zit hier een mogelijkheid in voor HR om coins te geven aan medewerkers. URL van de GamificationService is: http://servicegw.montapacking.nl/gamification/ Wanneer worden welke RabbitMQ berichten geplaatst Inbound: Bij elke inbound die wordt uitgevoerd. Echeck: Bij elke regel die geëchecked wordt. Picken: (Elke keer als je producten uit de stelling pakt. 1 pickactie voor 2 orders bij S kratten. Ook 1 pickactie voor 2 orders bij M karren.) Retouren: Bij elke retour regel. Koppelen: Bij elke koppel actie Coins (gold): Uiteindelijk worden de getelde acties van de medewerkers omgezet in coins. Elk uur krijgt de medewerker die het meeste koppelacties heeft x coins, zo ook voor de medewerker die de meeste echeck acties heeft, enzovoort. Dit is om individuele prestaties te belonen. Daarnaast worden elke dag coins toegekend aan teams binnen vestigingen die de doelstelling gehaald hebben qua outbound tijdigheid, tt01 op 0 en een laag joker percentage. Dit is om teamwork te belonen Verder wordt twee maal in het uur random coins toegekend aan medewerkers en kun je x coins krijgen als je jarig bent. Dit is gewoon om het leuk te maken De random coins worden als volgt gegeven: Van alle medewerkers, die een actie hebben uitgevoerd in het afgelopen half uur, wordt 1 persoon random gekozen. Hierbij maakt het niet uit hoeveel acties een persoon heeft gedaan. Coins (silver): Personeelszaken kan zilveren coins toekennen aan nieuwe medewerkers om te besteden aan bedrijfskleding. Dit toekennen van coins doet PZ in de tool montamoney. Monitor: Voor de gamification is een monitor ontwikkeld om de statistieken te tonen in het magazijn. Dit project staat in devops met de naam \"GamificationMonitor\". De resultaten van de gamificationmonitor zijn op de meeste vestigingen op een grote TV te zien. Dit is een TV met een raspberry PI erachter. Webshop: Collega's kunnen de coins die ze gespaard hebben besteden in een webshop www.montashop.nl. Producten worden ontwikkeld en besteld door Marije IJzerman (marije@montapacking.nl) en aangemaakt in de woocommerce webshop montashop.nl. De koppeling tussen montashop en montaportal is een gewone woocommerce koppeling, net zoals andere woocommerce webshops. In montashop.nl zit een stukje maatwerk tbv het inloggen van de gebruikers en het opvragen van het coinsaldo en het afboeken van de coins als er iets besteld is. Dit maatwerk in woocommerce roept bij montapacking de api rest.montapacking.nl/v0 aan. ​​​​​​​Hiervoor zijn credentials aangemaakt, die staan in de tabel tblMontaGamificationShopCredentials. Documentatie voor de Gamification webshop api is te vinden op S:\\8.0 Automatisering\\1.0 Software\\8.0.3 Webshops\\communicatiebestanden\\Gamification webshop REST api ​​​​​​​De hosting van montashop.nl wordt gedaan door vd Perk groep. contact: Marc Strootman – 06-26927726 Troubleshooting: De meest gestelde vraag is dat collega's niet kunnen inloggen. Marije pakt die vragen meestal op en vaak blijkt dan het prive email adres van de collega nog niet goed in montamoney te zijn ingevuld door de leidinggende die de medewerker aangemaakt heeft in montamoney. Soms vraagt een collega inzicht in hoeveel coins er verdiend zijn, als er twijfel is of het goed gegaan is. Meestal verwijzen we die vraag dan door naar de vestigingsmanager van die vestiging, die kan in gomonta een rapport oproepen waar de coin history te zien is. ( gomonta.montapacking.nl/Office/Gamification/Index ) Door op het coin totaal getal te klikken, komt de vestigingsmanager in een rapport waar history te zien is"
  },
  "Algemene-informatie/Glossary/index.html": {
    "href": "Algemene-informatie/Glossary/index.html",
    "title": "Glossary",
    "keywords": "Glossary Deze pagina geeft een overzicht van de termen die in de software gebruikt worden en wat ze betekenen. Naam (en) Naam (nl) Naam (de) Naam (fr) Technische naam in de programmacode Beschrijving Legacy (niet meer gebruiken) Shipping box? Verzendverpakking? ShippingBox De doos/verpakking waar een collo in verzonden wordt. Drager Channel Kanaal Channel Esetting Product Product Product Material, Materiaal Customer Klant Relation Webshopeigenaar. Iemand die zijn fulfilment heeft uitbesteed bij Monta of MontaWMS gebruikt. Relatie, Account Consumer Consument De ontvanger van een Eorder. Order number Ordernummer Auftragsnummer Numéro de commande ChannelOrderNumber Het ordernummer van een order van een kanaal (bijv. MP-1234). WebshopOrderID Order Order Auftrag Commande Eorder? Een order. Order reference Orderreferentie Auftragsreferenz Référence de la commande OrderReference De referentie van een order. Inbound forecast Inbound vooraanmelding InboundForecast(Line) Een groep producten die bij het magazijn geleverd gaan worden. De term wordt soms ook gebruikt voor een product/regel in zo'n groep. Inbound Ontvangst Inbound Een product wat ontvangen en ingeboekt is. Delivery? Levering Delivery? De bevestiging dat een inbound forecast bij het magazijn ontvangen is. Supplier Leverancier Supplier Een leverancier van de producten van een klant. Warehouse Magazijn Warehouse Een gebouw met magazijnlocaties waarop producten worden opgeslagen. Company? Bedrijf? Company? Een Monta BV waar meerdere magazijnen onder kunnen hangen. Vestiging Stock reservation Voorraadreservering StockReservation Wordt gemaakt bij een order om de voorraad te reserveren (order > voorraadreservering > pickbon). Bestelbon, bestelling"
  },
  "Algemene-informatie/Inbound/Handleiding-inbounden/index.html": {
    "href": "Algemene-informatie/Inbound/Handleiding-inbounden/index.html",
    "title": "Handleiding inbounden",
    "keywords": "Handleiding inbounden Hier staan informatieve videos en uitleg over het Inbound-proces. Wat is de Inbound? De inbound is een stukje van het logistieke proces, waar de producten van klanten in de Monta warehouses binnen komen. Daarbij is het belangrijk voor zowel onszelf als onze klanten om precies te weten hoeveel en welke producten er in onze warehouses liggen opgeslagen. Als inbounder ben jij een onmisbare schakel in het logistieke proces van Monta. Binnen Monta heeft alles wat met inbound te maken heeft de kleur geel. 1 Forecast en Inbounden 1.1 Pallet met producten De producten worden meestal met dozen vol op pallets afgeleverd. Je zet de pallet met producten die je moet inbounden aan de ene kant van het inbound-station en een lege pallet of rolcontainer aan de andere kant. Plaats een doos met producten op de inbound-tafel. Scan met je handscanner 1 van de producten uit de doos, plaats deze daarna weer terug in de doos. 1.2 Forecast Een forecast is eigenlijk een digitale lijst met wat een klant besteld en naar ons toegestuurd heeft. Wij weten nu precies hoeveel producten we van deze klant binnen krijgen. De klant heeft in dit voorbeeld 2 verschillende producten besteld, nu krijgen wij via de forecast te zien dat er 44 stuks van het ene en 48 stuks van het andere product aangeleverd zouden moeten zijn. 1.3 Geen forecast Heeft de klant geen forecast, vraag dan aan je leidinggevende wat je hiermee moet doen. Het verschilt per klant of er met of zonder forecast ingeboekt kan worden. 1.4 Plakbon Als er een plakbon bij de levering is dan scannen wij die gelijk in. Het product is nu gescand, we tellen het aantal wat geleverd is en checken de barcodes. De barcode staat in de pop up na de productnaam. 1.5 Barcode check Voor het checken van de barcode kijk je of de laatste 4 cijfers overeenkomen. 1.6 Maak inbound Het aantal klopt, nu boek je het aantal in wat je net gecheckt hebt. Klik dan op maak inbound. Komt het aantal niet overeen maar je klikt toch op maak inbound, dan verschijnt er een waarschuwing, met daarbij de vraag of dit daadwerkelijk klopt. Het kan namelijk voorkomen dat er daadwerkelijk meer is geleverd dan is aangemeld, maar het kan ook een fout zijn. Klopt het aantal daadwerkelijk, klik dan op ja, of op enter. Anders, kies nee, en pas het aantal aan Je krijgt een koppellabel (ook wel TT-label genoemd) uit de labelprinter die je op de doos of krat plakt. De doos leg je nu op de pallet voor ingeboekte producten. De krat plaats je bijvoorbeeld in een kar. De pallet of kar kan meegenomen worden, zodat het daarna op de daarvoor bestemde locatie gekoppeld kan worden in het magazijn. 2 Batch maken 2.1 Lotnummer en houdbaarheidsdatum Sommige producten werken ook met een batch. Deze producten hebben een lotnummer en een houdbaarheidsdatum. Deze gegevens kun je op het product vinden, zo niet ga naar je direct leidinggevende. Vul deze gegevens in en klik daarna op opslaan. Je ziet het lotnummer en de houdbaarheidsdatum nu staan in het scherm waar je ook het aantal producten invult. De batch is nu nog aan te passen. Mocht je dit niet willen, dan kan dit in GoMonta uitgezet worden. Deze instelling is te vinden onder Kantoor - Relatie -> Inbound -> Mag vooraangemelde batch bewerken. Deze instelling schakelt het dropdown veld uit als er een batch mee gegeven wordt aan de vooraanmelding. Het aantal klopt, nu boek je het aantal in wat je net gecheckt hebt. Klik dan op maak inbound. Je krijgt een koppellabel (ook wel TT-label genoemd) uit de labelprinter die je op de doos of krat plakt. De doos leg je nu op de pallet voor ingeboekte producten. De krat plaats je bijvoorbeeld in een kar. De pallet of kar kan meegenomen worden, zodat het daarna op de daarvoor bestemde locatie gekoppeld kan worden in het magazijn. 3 Crossdock & Fastlane 3.1 Backorder Crossdock of fastlane betekent dat een binnenkomend product al in backorder staat en gelijk weer de deur uitgaat. Bij dit voorbeeld worden er 44 producten ingeboekt, daarvan gaan er 43 naar de voorraad en 1 naar crossdock. 3.2 Orderformulier Dit enkele product houd je apart, je krijgt nu een orderformulier uit je printer. Dit formulier voeg je toe bij het product en leg je neer in een blauwe krat. Zo ga je verder tot de forecast compleet is, is dat niet zo geef het aan bij je leidinggevende. Het kan zijn dat er nog een nalevering komt van deze klant, of dat er een product verkeerd is ingeboekt. Als de forecast compleet is klik je op gereed, zo niet klik dan op volgende pakbon. 4 Mogelijke problemen Inbound 4.1 Overige vragen Mocht je nog met bepaalde vragen zitten neem dan contact op met je direct leidinggevende."
  },
  "Algemene-informatie/Inbound/Inbound-applicatie-schermen/index.html": {
    "href": "Algemene-informatie/Inbound/Inbound-applicatie-schermen/index.html",
    "title": "Inbound applicatie schermen",
    "keywords": "Inbound applicatie schermen Deze pagina geeft informatie over het verloop van de inbound-schermen. Inlogscherm Inloggen met de Montapas Wanneer de applicatie geopend wordt kun inloggen door de Montapas te scannen met de handscanner. Inloggen met gebruikersnaam en wachtwoord Een andere optie is het inloggen met gebruikersnaam en wachtwoord. Inbound overzicht Vooraangemeld Hierin staan de artikelen die door de leverancier van te voren aangemeld zijn. Ontvangen Hierin staan de artikelen die ingescant zijn door de inbound-medewerker. Volgende pakbon Met deze knop kan de inbound-medewerker de volgende pakbon selecteren, voor artikelen van een andere leverancier. pakbon scannen Dit is een overzicht van de gescande pakbonnen. Materiaal info Met deze knop kan de barcode van een artikel ingescand/ingevoerd worden om informatie weer te geven over het artikel. Print barcode Met deze knop kan de barcode van een artikel ingescand/ingevoerd worden en vervolgens uitgeprint. Open TT Overzicht van alle ingeboekte artikelen van een ploeg. RFID Met deze knop wordt het RFID overzicht weergegeven. Opmerking van vooraanmelding Met deze knop is het mogelijk om de opmerking van een vooraanmelding aan te passen. Deze knop opent een pop-up waarin de opmerking toegevoegd of bewerkt kan worden. Dit veld heeft een limiet van 500 karakters. Deze opmerking is ook in de Montaportal terug te vinden. Dit staat op de detail pagina van de desbetreffende vooraanmelding"
  },
  "Algemene-informatie/Inbound/Inkoopsysteem/index.html": {
    "href": "Algemene-informatie/Inbound/Inkoopsysteem/index.html",
    "title": "Inkoopsysteem",
    "keywords": "Inkoopsysteem De Montaportal bevat een inkoopsysteem. Dit systeem kan het volgende: Inkoopadvies maken, Inkoopadvies omzetten in inkooporder, Inkooporders per e-mail versturen naar de leverancier met een PDF en/of Excel, Inkooporders omzetten in inbound forecasts. Inkoopadvies maken Een inkoopadvies maken kan vanuit de voorraadprognose (Stock forecast) [1]. De voorraadprognose laat een lijst zien van alle producten, met de huidige voorraad, de gemiddelde verkoop en (daaruit volgend) hoe lang de voorraad nog strekt. Voor het berekenen van de gemiddelde verkoop kan gekozen worden hoe dit berekend moet worden [2]. Vanaf de eerste verkoop tot nu of gebaseerd op een bepaalde periode Op basis van het resterend aantal dagen kan een inkoopadvies gemaakt worden [3]. Als bijvoorbeeld gekozen wordt om voor de komende tien dagen in te kopen, komen producten met minder dan tien dagen resterende voorraad in het inkoopadvies. De aantallen in het inkoopadvies kunnen vervolgens aangepast worden. Er kan ook voor gekozen worden niet eerst een inkoopadvies te maken, maar direct een inkooporder. Ook kan ervoor gekozen worden een inkoopadvies toe te voegen voor alleen de aangevinkte producten. Inkoopadvies omzetten in inkooporder Opgeslagen inkoopadviezen zijn te vind in het scherm inkoopadviezen [1]. Hier kan het aantal te bestellen nog aangepast worden [2]. Ook kan de leverancier gekozen worden. Hier wordt automatisch de standaardleverancier van het product gekozen. Bij elk getal en kolomkop is uitleg op te vragen door er met de muis overheen te gaan [3]. Inkoopadviezen kunnen omgezet worden naar een inkooporder door ze goed te keuren [4]. Goedgekeurde inkoopadviezen worden gegroepeerd per leverancier. Het is ook mogelijk bij een product een \"inkoopadvies notitie\" in te stellen. Deze wordt zichtbaar met een waarschuwingsicoontje in het inkoopadvies [5]. Door met de muis over het waarschuwingsicoontje te gaan kan de notitie gelezen worden. De goedgekeurde inkooporders van een leverancier kunnen omgezet worden in een inkooporder in het scherm inkooporders. Inkooporders per e-mail versturen en inbound forecast maken De gemaakte inkooporder kan per mail verstuurd worden naar de leverancier [1]. Het standaard template voor deze e-mail is aan te passen bij Algemeen > Instellingen > Communicatie van montaportal. Wanneer de datum bekend is dat de producten geleverd gaan worden, kan de inkooporder omgezet worden in een inbound forecast [2]. Nieuwe inkoopmodule: Monta heeft een inkoopsysteem die voor alle klanten beschikbaar is. Dit inkoopsysteem kan ook een advies uitdraaien op basis van de verkoophistorie met wat een klant moet inkopen. LETOP, Het inkoopsysteem is nog in ontwikkeling. niet alles wat in deze documentatie staat is al live Nog in ontwikkeling (5-06 Niels de Cock) : Het inkoopsysteem Het Monta Inkoopsysteem is een krachtige en geïntegreerde oplossing die is ontworpen om inkoopprocessen te stroomlijnen en de efficiëntie te verbeteren. Of je nu een kleine onderneming bent die net begint met het automatiseren van inkoopactiviteiten, of een groot bedrijf dat op zoek is naar een geavanceerd inkoopsysteem, Monta is ontworpen om aan jouw behoeften te voldoen. Het inkoopsysteem heeft meerdere functionaliteiten die over verschillende pagina's heen zijn verspreid. Onderstaand is een overzicht van alle pagina's met uitleg en functionaliteiten te vinden op deze pagina's Om een inkooporder te plaatsen moet de klant de volgende flow doorlopen: Inkoop Dashboard Het inkoopdashboard heeft het doel: Vraag beantwoorden; Wat in te kopen? Menu: Het dashboard valt onder het menu item: Binnenkomend -> Inkoopdashboard Het Inkoopdashboard is een pagina binnen het inkoopsysteem van Monta en biedt verschillende functionaliteiten. Het dashboard is het startpunt voor het maken van een inkooporder. Het Inkoopdashboard biedt dus een overzichtelijke en gebruiksvriendelijke manier om inkoopinformatie te bekijken en te analyseren. Door het gebruik van filters en de mogelijkheid om gedetailleerde informatie op te vragen, kan de gebruiker snel en efficiënt inzicht krijgen in de inkoopprocessen van het bedrijf. Het dashboard bevat de volgende onderdelen: Periode: Dit geef een overzicht met de setting die worden gebruikt voor de berekening van het inkoopadvies. Monta® baseert de inkoopadviezen op basis van een bepaalde periode. De klant kan deze periode aanpassen in het dashboard. De gebruiker kan de gewenste periode aangeven en de gebruikte periode bekijken. Inkoop statistieken: Dit geeft een overzichtelijk beeld van wat moet worden ingekocht. Ook geeft het een gemakkelijke manier om naar andere pagina’s te navigeren. Producten overzicht: Dit geeft een overzicht van alle producten, met daarbij de gegevens hoeveel dagen resterende stock er nog is. Gesorteerd op Minste dagen. Inkoop Module: Module waarmee je een inkoop(advies) kan starten. Gemeten dat instellingen achter een tandwieltje mogen komen omdat deze minimaal gebruik worden. Inkooporder: Concept Wanneer een inkooporder nog niet definitief is, en wordt aangemaakt, kom je op de concept pagina. Dit is een pagina waarop je de inkooporder kan maken; aanpassen en goedkeuren. Een concept inkooporder kan op drie manieren worden gemaakt: Vanuit een inkoopadvies Vanuit een inkoopadvies gebaseerd op een selectie van artikelen Handmatige inkooporder Product overzicht: Hierin is een overzicht te zien van welke producten ingekocht gaan worden. Inkoopoverzicht: Dit geeft een overzichtelijke summary van de inkooporder. Hier is ook te zien of de minimale en Franco waardes bereikt zijn. Product kiezer: Dit is een veld waarmee je handmatig producten kan toevoegen aan de inkooporder. Inkoopoverzicht Dit scherm geeft een overzicht van alle inkooporders. Zowel de concepten als de definitieve inkooporders. Ondersteunende pagina's Productpagina: Op de product pagina is data toe te wijzen aan producten die je kan gebruiken tijdens het maken van een inkooporder. (Multi) leverancier toewijzen aan producten: Op de productpagina, of via een import, is het mogelijk om een leveranier toe te voegen aan een product. Dit is van belang om bij de inkooporders op levernacier te kunnen inkopen. Mogelijkheid om meerdere leveranciers toe te voegen aan één product middels dropdown: Overige functionaliteiten op pagina: Minimum voorraad per magazijn instellen: Met deze functie kunnen gebruikers de minimumvoorraad instellen voor elk magazijn waarin het product wordt opgeslagen. Dit is op de product detailpagina te wijzigen. Minimale/Maximale inkoophoeveelheid product: Het is nu mogelijk om een min en max in te stellen per product. Weergave verkoopinformatie en geschiedenis: De totale verkooptrend weergeven in percentages: Deze functie toont de totale verkooptrend in percentages, waarbij de groei wordt vergeleken met dezelfde maand vorig jaar en de afgelopen 28 dagen vergeleken met dezelfde 28 dagen vorig jaar. Wordt vermoedelijk in grafiek weergegeven. Omlooptijd inzichtelijk maken: Hiermee kunnen gebruikers de omlooptijd van het gehele assortiment en per product bekijken, en trends in een grafiek bekijken. Deze grafiek is te vinden in de Montaportal. De totale seizoen factor weergeven in percentages: Met deze functie wordt de totale seizoen factor weergegeven in percentages, waarbij de groei wordt vergeleken met een maand geleden en de afgelopen 28 dagen vergeleken met de 28 dagen daarvoor. Servicelevel per product: “% uit voorraad leverbaar” inzichtelijk maken van het gehele assortiment en per product. En in een grafiek om trends te zien. % uit voorraad leverbaar = hoe vaak is een product uit voorraad is geweest terwijl je het had kunnen verkopen Leverancier pagina Op de leverancierpagina kunnen leveranciers worden beheerd en toegevoegd."
  },
  "Algemene-informatie/Inbound/index.html": {
    "href": "Algemene-informatie/Inbound/index.html",
    "title": "Inbound",
    "keywords": "Inbound Inbound betreft de goederen die bij het magazijn geleverd worden. Flowchart Deze flowchart beschrijft het inboundproces. graph TD; subgraph klant product_info[Maakt productinformatie aan in Montaportal] --> po_advice[Maakt inkoopadvies op Montaportal] --> po_create[Maakt inkooporder op Montaportal] --> place_po[Stuurt inkooporder naar leverancier] inbound_forecast[Maakt inbound forecast aan] inbound_forecast_ok_klant[Inbound forecast goedkeuren] end subgraph leverancier supp_po_delivery_date[Bevestigd leverdatum en aantallen] --> supp_ship[Verstuurt goederen naar magazijn] end subgraph magazijn lvr[Levering registreren] --> ib[Product inbounden] --> inbound_forecast_check{Klopt het aantal met de forecast?} -- yes --> inbound_forecast_ok_magazijn[Inbound forecast wordt automatisch goedgekeurd] ib --> kopp[Voorraad koppelen op locatie] inbound_forecast_check -- no --> inbound_forecast_ok_klant end place_po --> supp_po_delivery_date supp_po_delivery_date --> inbound_forecast supp_ship --> lvr style po_advice stroke-dasharray: 5 5 style po_create stroke-dasharray: 5 5 style lvr stroke-dasharray: 5 5 Productinformatie Voordat Monta producten van de klant (webshopeigenaar) op voorraad kan nemen (inbounden) moet Monta beschikken over de productinformatie. Productinformatie bestaat minimaal uit: SKU, omschrijving en één barcode. Productinformatie kan op drie manieren bij Monta beschikbaar komen: Automatisch via een koppeling Handmatig op Montaportal​ meerdere producten tegelijk importeren met een Excel import Handmatig producten stuk voor stuk invoeren op Montaportal Barcodes Zie Voorraadbeheer - Barcodes voor meer informatie. Food/THT Bij een product dat als Food gemarkeerd is, wordt bij de inbound de batch en THT geregistreerd. Het is de verantwoordelijkheid van de klant om in de gaten te houden welke THTs bijna verlopen. Hiervoor zijn rapporten in de Montaportal (het is ook mogelijk die automatisch te mailen). Food producten kunnen niet verstuurd worden als ze geen batch hebben of als de THT datum van de batch verstreken is. Orders komen dan in blocked. Bij een product kunnen ook THT periodes ingesteld worden voor inbound en outbound. THT periode inbound: aantal dagen voordat de THT bereikt is dat het niet meer mag worden geinbound. THT periode outbound: aantal dagen voordat de THT bereikt is dat het niet meer verstuurd mag worden. THTs die bijna over de datum gaan kan de klant afboeken door ze te bestellen. Dit kan met onderstaande knop op de Montaportal. In het geval van een terugroepactie kan de klant een export maken welke batch verstuurd is in welke orders. Dit kan met het Excel knopje bij de batch op de product details pagina op Montaportal. Inkoopadvies en inkooporder Montaportal Klanten kunnen op de Montaportal vanuit de stock forecast een inkoopadvies maken. Dit kan evt per leverancier. Dit inkoopadvies kan nog aangepast worden en dan omgezet worden in een inkooporder. De inkooporder kan vanuit de Montaportal gemaild worden naar de leverancier. Als de leverdatum bekend is kan de inkooporder omgezet worden naar een inbound forecast. Zie inkoopsysteem. Inbound forecasts Een klant is verplicht bij ons aan te geven als producten bij ons geleverd gaan worden. Dit kan door middel van een \"inbound forecast\". Een inbound forecast kan op meerdere manieren gemaakt worden. Op Montaportal Via een koppeling Op ​Montaportal vanuit een purchase order Bij het maken van een inbound forecast geeft de klant op welke aantallen van welke producten op welke datum geleverd gaan worden. Per klant kan ingesteld worden of er ge-inbound mag worden zonder forecast en of er meer producten ge-inbound mogen worden dan in de inbound forecast staan. Inbound forecasts verwijderen Hert is mogelijk om een prouductregel van een forecast te verwijderen. Dit kan op een paar manieren in Montaportal, zolang er nog niks van dit product is verwerkt. Dit ios aangetoond door de status \"Nothing yet\". Deze pagina is te vinden op Binnenkomend->Vooraanmeldingen->view details. Je kan een regel indivudueel verwijderen door de regel te bewerken, en dan op \"verwijder: te klikken. Je kan ook in bulk verwijderen. Als er nog niks van de vooraanmelding is verwerkt staat er onder aan de pagina een knop 🗑 Verwijder. Deze knop verwijdert alle geselecteerde regels. . Als er al wel wat verwerkt is, maar een deel nog niet, dan staat er de knop 🗑 Verwijder alles met status 'Nothing yet'. Deze knop verwijderd dan alle geselecteerde regels waarvan de status Nothing yet is, maar laat alle andere geselecteerde regels staan. . Levering registeren Het is mogelijk om te registreren dat de levering bij het magazijn is binnengekomen. Dit kan met de scanner. Hierbij kan ook aangegeven worden hoeveel dozen en pallets er zijn ontvangen. Deze optie kan ingeschakeld worden bij het magazijn. Hiermee ziet de klant sneller dat de levering in het magazijn is ontvangen, nog voordat de producten ingeboekt worden. Producten inboeken (inbounden) Zie ook Handleiding inbounden. Bij het inboeken van producten worden de volgende stappen doorlopen. Inbound forecast kiezen Pakbon inscannen Barcode producten inscannen (als niet gevonden dan kan een onbekende inbound gemaakt worden) Aantal invullen Afmetingen en gewicht invullen Optioneel is het mogelijk om een foto te maken van het product. Bij de klant moet ingeschakeld worden worden deze knop beschikbaar komt. Crossdock Koppellabel wordt geprint (niet bij crossdock). Het is ook mogelijk om een krat te scannen. De producten worden op de krat geboekt ipv een koppellabel. Melding/instructie In GoMonta kan bij producten een inboundinstructie ingesteld worden, deze wordt als melding getoond bij het inbounden van het product. Crossdocken Als er backorders zijn van het product dat geinbound is, dan kunnen die meteen door naar de outbound (Echeck). Na het scannen van het product en het invullen van het aantal wordt aangegeven hoeveel producten er gecrossdockt kunnen worden. Er moet een kar of krat gescand worden waar de producten ingelegd worden. Of er kan een papieren crossdock bon geprint worden. Dit kan alleen voor orders die geschikt zijn. Een order is geschikt voor crossdocken als hij uit één product bestaat (met één of meer items). Echeck toevoegproducten tellen hierbij niet mee. Aantal te crossdocken Het kan zijn dat maar een deel van het te inbounden aantal gecrossdockt kan worden. Dit heeft er mee te maken dat alleen S en HM orders gecrossdockt kunnen worden. Als er andere (M, L) backorders zijn die eerder verstuurd moeten worden, moet eerst voorraad voor die orders in het warehouse gelegd worden. Crossdock annuleren Dit kan in GoMonta. De orders gaan dan terug in backorder en de producten moeten opnieuw ingeboekt worden. B2b orders crossdocken Het is mogelijk om grote backorders meteen vanuit de crossdock te verzamelen op een locatie. Hiervoor moet in GoMonta een magazijnlocatie worden toegewezen aan de order. Crossdock in of uitschakelen De mogelijkheid om te crossdocken is standaard ingeschakeld. Indien gewenst kan per magazijn het crossdocken worden uitgeschakeld door in GoMonta bij Magazijn Inbound Instellingen het schuifje om te zetten. Barcodestickers printen Als de producten niet (correct) voorzien zijn van (scanbare) barcodestickers, is er bij de inbound een optie om alsnog correcte barcode stickers te printen, zodat de producten verder in het proces wel correct te identificeren zijn dmv een barcode scan. Het printen van de barcod​​estickers wordt geregistreerd zodat dit aan de klant gefactureerd kan worden. Inbound banner Het is mogelijk om bij de inbound een A4 vel te laten printen met informatie over het product. Deze kan op de pallet bevestigd worden om deze makkelijker te kunnen herkennen in het magazijn. Het printen van de inbound banner kan ingeschakeld worden per klant. Mobiele inbound Een mobiele inbound is bijv een laptop met de inbound applicatie. Dan hoeft er geen koppellabel geprint te worden, maar kan meteen de locatie gescand worden waar het op gekoppeld kan worden. Een inbound station kan als mobiele inbound gemarkeerd worden. Inbounden met de scanner Het is ook mogelijk om te inbounden met de scanner. Dan hoeft er geen koppellabel geprint te worden, maar kan er meteen op locatie gekoppeld worden. Bij inbound met de scanner kan er niet gecrossdockt worden. Inbounden met mutaties Als er een aantal product ingeboekt moet worden die niet vanuit een levering binnengekomen zijn, kunnen deze met positieve mutaties ingeboekt worden. Om dit in GoMonta te doen is echter veel handwerk. Daarom is het ook mogelijk om te inbounden met mutaties. Er hoeft dan alleen een product gescand te worden en er wordt een kopellabel geprint. De inbounds worden niet zichtbaar op Montaportal. Onbekende inbounds Het is mogelijk om producten die (nog) niet bekend zijn toch in te boeken. Bij de inbound moet dan een omschrijving ingevuld worden en dan wordt het product alsnog aangemaakt. Bij een klant is ook in te stellen dat hierbij verplicht een foto gemaakt moet worden. De klant krijgt een waarschuwing op de Montaportal en kan het product accepteren als nieuw product of samenvoegen met een bestaand product. Deze werkwijze heeft als voordeel dat er geen onbekende producten blijven rondslingeren op de vloer. Per klant is in te stellen of onbekende inbounds zijn toegestaan. Als een onbekende inbound per ongeluk gedaan is kan deze ongedaan gemaakt worden door de inbound te verwijderen. Inbound ongedaan maken (verwijderen) Het is ook mogelijk om een inbound te verwijderen zo lang de voorraad nog op de locatie staat waar het is gekoppeld. Verkeerde inbound forecast gekozen Als bij de inbound het product op de verkeerde forecast is ingeboekt kan dit op de Montaportal gecorrigeerd worden. Het product kan verplaatst worden naar een andere forecast. Inbounden op krat / papierloos inbounden Het is ook mogelijk producten die ge-inbound worden te koppelen aan een krat. De \"koppelaar\" scant de krat, waarvanuit de producten gekoppeld worden op locatie. Als de krat leeg is \"meld\" de koppelaar deze af, w​​aarbij het systeem kan controleren of de producten correct gekoppeld zijn. Quarantaine inbound Producten kunnen oo​​k direct geinbound worden als quarantaine voorraad, bijvoorbeeld als geconstateerd wordt dat de producten beschadigd zijn. Koppelen Nadat het product geinbound is moet het op locatie gekoppeld worden. Dit kan: In GoMonta Met de scanner door het koppellabel te scannen Koppelen met de scanner gaat door eerste het koppellabel of de krat te scannen en daarna de locatie waar het op gekoppeld moet worden. Controles Gewone voorraad mag alleen op niet-quarantaine locaties gekoppeld worden. Quarantaine voorraad mag alleen op quarantaine locaties gekoppeld worden. Er mag maar één product of batch op een locatie gekoppeld worden, tenzij multiproduct ingesteld staat. Zie voorraadbeheer - Multiproductlocaties. Hierbij wordt ook gekeken naar de fysieke voorraad. Omdat een order die klaarstaat om gepickt te worden geannuleerd kan worden. Als er dan een ander product gekoppeld is zou een multiproduct locatie ontstaan. Bij een magazijnlocatie kan ingesteld zijn dat alleen producten van een bepaalde supplier gekoppeld mogen worden. Bij een magazijnlocatie kan ingesteld zijn dat alleen een bepaald product gekoppeld mag worden. Locatie/zone suggestie Op het koppellabel wordt een locatie geprint waar het product bijgeplaatst kan worden (als het al ergens ligt). Als het nog niet ergens ligt kan per klant een zone ingesteld worden waar het product geplaatst moet worden. Dit wordt dan op het koppellabel geprint. Op de scanner worden ook de locaties getoond waar het product al ligt. Alternatieve tekst zone suggestie Als een product nog niet gekoppeld is op een magazijnlocatie en er geen zonesuggestie ingesteld staat voor de betreffende klant is het mogelijk een tekst in te stellen dat op het koppellabel getoond wordt. Dit kan in GoMonta bij de relatie ingesteld worden onder het kopje Inbound: Openstaande orders Het is mogelijk om een \"B\" te laten printen op het koppellabel als er backorders zijn van een ge-inbound product (en crossdocken is niet mogelijk omdat het bijvoorbeeld M orders zijn). De producten kunnen dan dicht bij de echeck gelegd worden zodat ze snel weer gepickt kunnen worden als de order uit backorder komt. Dit kan ingeschakeld worden in GoMonta bij Inbound instellingen \"Print TT01 backorder label\". ABC advies Op het koppellabel wordt een A, B of C getoond wat aangeeft wat de omloopsnelheid van het product is. Vaak verkopende product (A) moeten op goed bereikbare locaties in het magazijn gelegd worden. Zie R en D update - ABC tool. Zoekwoorden: i ,in ,inb ,inbo ,inbou ,inboun ,inbound"
  },
  "Algemene-informatie/Koppelingen/1.-Koppelingen-dataflow/Dataflow-Information/index.html": {
    "href": "Algemene-informatie/Koppelingen/1.-Koppelingen-dataflow/Dataflow-Information/index.html",
    "title": "Dataflow Information",
    "keywords": "Dataflow Information Purchase order export Momenteel kunnen wij (voor nu alleen ExactOnline) in montaportal aangemaakte inkoopordes exporteren naar platformen. Het is van belang dat de klant een referentie meegeeft in de inkooporder. Dit is benodigd voor de andere dataflows. Als dit niet wordt gedaan, worden er dubbele inkooporders ge�mporteerd uit de platformen. Daarnaast wordt er pas een planning aangemaakt wanneer een inbound forecast wordt aangemaakt. Er zijn te veel scenario's waar rekening gehouden moet worden als er producten zijn zonder inbound forecast. Voor de purchase order export wordt er een request gedaan voor de suppliers (bij ExactOnline ook een aparte request voor de account items). Voor de benodigde settings, zie de \"Dataflow Settings\" pagina voor meer informatie. Suppliers waar wij een match hebben gevonden, worden opgeslagen in tblRelatieSystemConnectionDataFlowSupplierMatch. Verder wordt er ook gekeken op basis van de \"SupplierTitle\", als de supplier al een entry heeft in de volgende database tabel tblPortalPurchaseSuppliers. Indien deze nog niet bestaat, wordt een nieuwe entry aangemaakt."
  },
  "Algemene-informatie/Koppelingen/1.-Koppelingen-dataflow/Dataflow-Settings/index.html": {
    "href": "Algemene-informatie/Koppelingen/1.-Koppelingen-dataflow/Dataflow-Settings/index.html",
    "title": "Dataflow Settings",
    "keywords": "Dataflow Settings Product match Import Purchase Price Hidden: als je de inkoopprijzen importeert bij import purchase price (voor rapportages), zorgt deze instelling ervoor dat deze onzichtbaar wordt voor Montaportal gebruikers. Overwrite barcodes: hiermee sta je toe dat barcodes overschreven worden door de koppeling. Dus wanneer je een barcode wijzigt in de webshop, wijzigt deze ook in de Montaportal, met als gevaar dat producten met oude barcodes niet meer verwerkt kunnen worden in het magazijn. Can import product sizes: hiermee sta je toe dat productafmetingen kunnen worden geïmporteerd vanuit de koppeling. Standaard meten en wegen we nieuwe producten in onze magazijnen. Auto remove first zero in barcodes: Hiermee worden de 1e voorloopnullen in barcodes automatisch verwijderd. Image Import: hiermee sta je toe dat de standaard productafbeelding kan worden geïmporteerd vanuit de koppeling. Dit zal o.a. gebruikt worden op de RMA pagina. Dit is mogelijk bij de volgende koppelingen: Magento Shopify WooCommerce CCVShop BigCommerce Exact LightspeedEcom MyOnlineStore Shopware (Staff functie) Import product information: hiermee worden extra productvelden zoals descriptions uitgelezen (Staff functie) Import supplier information: hiermee worden de suppplier gegevens opgehaald Dit is mogelijk bij de volgende koppelingen: ExactOnline Order Import Origin mapping: de tekst die hier wordt ingevuld moet overeen komt met die origin in Magento/Amazon om alleen orders van die origin te importeren. Do Not import OrderLine Description: soms geeft een order een orderline description mee aan een materiaal, die gebruiken we in de Montaportal en op de pakbon. Met deze instelling gebruiken we de originele omschrijving van het materiaal. DenyOrderWithUnknownShipperCodes: Orders met shipperCodes die niet bekend zijn in shipper mapping van klant negeren. Let op : Een lege waarde wordt niet genegeerd, die orders komen dus wel door. (Staff functie) Use Shipping Document As Pro Forma Invoice When Needed: met deze instelling gebruiken we de pakbon als pro forma invoice wanneer die ontbreekt in de order en nodig is om de order buiten de EU te verzenden, met als risico dat de douane de order terugstuurt. Shipping document is used as pro forma because a pro forma is required for this order and only a shipping document is given and the option was given to use the shipping document in this situation (Staff functie) Do not change Shipper to Cancelled When Deletion Request not possible: wanneer een order geannuleerd wordt vanuit de webshop maar de order al in de pickstroom zit, zetten we de vervoerder normaal gesproken op \"cancelled\" zodat de order niet verstuurd kan worden. Met deze instelling doen we dat niet, en versturen we dus alsnog de geannuleerde order. (Staff Functie) Re Use webshop OrderID allowed: met deze instelling kan een OrderID opnieuw gebruikt worden, dit kan echter alleen bij een FTP-koppeling (Staff functie) UpdateWhenAlreadyExistsAndPlatformSupportsIt: Hiermee is het mogelijk om wijzigen en annuleringen binnen te halen. (Staff functie) Backorder Handling: Zie onderstaande tabel voor de mogelijkheden en uitleg wat de mogelijkheden doen. Vul in de database '1' in het kolom. Opties Naam Uitleg 0 OrdersShipped Order volledig uitleveren (Default) - Order blijft in backorder staan tot alle producten op voorraad zijn. Dit is onze default 1 AllowSplit Deellevering toestaan - Versturen wat aanwezig is, de rest in backorder laten staan. Dit heet 'Auto split backorders' 2 NoBackOrders Geen backorders leveren - Versturen wat aanwezig is, de rest annuleren Hieronder een overzicht van de platformen die deze functionaliteit wel/niet ondersteunen: Platform Update orders AFAS Nee Amazon Vendor Central Ja Amazon Ja BigCommerce Ja Bol.com Ja CCV Shop Nee Channable Ja ChannelEngine Ja Colect Nee Exact Online Ja FTP Tabular (CSV / Excel) Ja FTP XML Ja Le New Black Nee Lightspeed eCommerce Ja Magento 2 Ja ManoMano Nee Mirakl Ja MyOnlineStore (Mijnwebwinkel) Ja Plug&Pay Ja PrestaShop Nee Shopify Ja Shopware Nee Sylius Nee WooCommerce Nee tblRelatieSystemConnectionDataFlowOrderImportSettingsShippers: Tabel voor het mappen van shippers voor de order import. Hier kun je per relatiesystemconnection een shipper naam vanuit het platform mappen met een shipper vanuit Monta. Je kunt ook een esetting kan toevoegen aan deze mapping. Wanneer je dit doet zal hij het kanaal wijzigen op basis van de gekozen shipper. Order Update Esetting: alleen van orders van dit kanaal wordt de status teruggekoppeld naar de webshop. AllowMultipleShippedOrderUpdates: Als deze setting op 'true' staat zorgt deze ervoor dat dubbele order updates met de status 304(shipped) toegestaan zijn. Deze staat standaard uit. Order update statusses only: (FTP) Stock update Exclude stock in transit: met deze instelling worden producten die al wel in het magazijn liggen maar nog niet in een stelling zijn gelegd niet meegenomen in de webshopvoorraad. Klik hier voor uitgebreide uitleg: Voorraad die nog niet bij ons in de stellingen is gelegd ligt kan bij ons op een zogenaamde transitlocatie liggen. Deze voorraad is standaard wel al beschikbaar in de webshop, aangezien deze binnen enkele uren wel in de stellingen komt te liggen om gepickt te kunnen worden. Je kunt er ook voor kiezen deze voorraad niet beschikbaar te maken in de webshop, aangezien het gevaar bestaat dat de order te laat komt wanneer de voorraad niet op tijd in de stellingen komt te liggen. Update split product stock: bij bundels sturen we normaal gesproken de voorraadstand van het aantal bundels dat gemaakt kan worden met de producten in de bundels. Zet je deze instelling uit dan sturen we een voorraadstand van 0. Bundels kunnen hier worden ingesteld: https://www.montaportal.nl/ProductRules/ProductRules?page=0 DoNotSubtractStockReserverationsForOrdersOfConfiguredEsettingsIDs: voor meerdere esettings iets niet uitvoeren ;). Weet niet precies wat de instelling nu inhoudt, maar eerst kon het alleen maar voor 1 esetting, nu voor meerdere. Dat kan dan door één of meerdere esettings in te vullen in kolom EsettingsIds. De kolom esettingsId nu niet meer gebruiken. StockType: Kies het type voorraad die je wilt importeren. Je kunt kiezen uit \"Financiele voorraad\" en \"Beschikbare voorraad\". Dit is aan te passen vanuit het Monta portal bij de koppelingdetails onder 'Instellingen > Configureer voorraadtype'. Inbound update WaitUntilInboundForecastGroupApproved: De inbounds worden pas doorgegeven als alle inbounds van de inboundforecastgroup op approved zijn gezet. WaitUntilInboundForecastApproved : Een inbound wordt pas doorgegeven als de inboundforecast daarvan op approved is gezet. Purchase order export De Purchase order export dataflow heeft zelf momenteel geen settings tabel. Echter, de product match heeft wel twee settings die benodigd zijn voor de purchase order export: (Staff functie) Import product information (Staff functie) Import supplier information De purchase order export is afhankelijk van de External supplier ID"
  },
  "Algemene-informatie/Koppelingen/1.-Koppelingen-dataflow/Intervallen-per-koppeling/index.html": {
    "href": "Algemene-informatie/Koppelingen/1.-Koppelingen-dataflow/Intervallen-per-koppeling/index.html",
    "title": "Intervallen per koppeling",
    "keywords": "Intervallen per koppeling Interval Veel van onze koppelingen draaien op een x interval. Dit interval kan verschillen per koppeling; per platform. Het verschilt wordt vaak veroorzaakt door het max aantal requesten die we mogen doen richting het platform. Hieronder is een overzicht te zien van alle intervallen. overzicht platform Dataflow Interval (in minuten) Amazon Full stock update to Amazon 1440 Amazon Order import from Amazon 30 Amazon Order status update to Amazon 30 Amazon Product match Amazon 120 Amazon Stock updates to Amazon for products with changed stock 15 Bigcommerce Full stock update to BigCommerce 1440 Bigcommerce Import orders from BigCommerce 5 Bigcommerce Order update to BigCommerce 15 Bigcommerce Product match BigCommerce 1440 Bigcommerce Product match Changed for BigCommerce 30 Bigcommerce Stock updates to BigCommerce for products with changed stock 15 Bol Changed Product Match Bol.com 30 Bol Full stock update to Bol.com 720 Bol Order import from Bol.com 5 Bol Order status update to Bol.com 5 Bol Product match Bol.com 60 Bol Stock updates to Bol.com for products with changed stock 15 CCV shop Full stock update to CCVShop 1440 CCV shop Import orders from CCV Shop 15 CCV shop Import product information from CCV Shop 720 CCV shop Order status shipped update to CCVShop 15 Channable Full stock update to Channable 1440 Channable Changed stock update to Channable 15 Chananble Import orders from Channable 15 Channable Import product information from Channable 120 Channable Order status shipped update to Channable 15 CCV shop Stock updates to CCVShop for products with changed stock 15 Lightspeed Changed Product Match Lightspeed Ecommerce 30 Lightspeed Full stock update to Lightspeed eCommerce 1440 Lightspeed Order import Lightspeed Ecommerce 15 Lightspeed Product match Lightspeed ecommerce 120 Lightspeed Stock updates to Lightspeed ecommerce for products with changed stock 15 Lightspeed Stock updates to Lightspeed ecommerce for products with changed stock 15 LeroyMerlin Order status shipped update to LeroyMerlin 15 Magento Changed Product Match Magento 30 Magento Create refunds in Magento2 15 Magento Full stock update to Magento2 1440 Magento Import orders from Magento2 15 Magento Order status update to Magento2 15 Magento Product import from Magento2 60 Magento Product match Magento2 120 Magento Stock updates to Magento2 for products with changed stock 15 Magento Stock updates to Magento2 from inbounds only 15 MyOnlineStore Changed Product Match MyOnlineStore 30 MyOnlineStore Changed stock update to MyOnlineStore 15 MyOnlineStore Full stock update to MyOnlineStore 1440 MyOnlineStore Product Match MyOnlineStore 120 Prestashop Changed Product Match PrestaShop 30 Prestashop Full stock update to PrestaShop 1440 Prestashop Import orders from PrestaShop 15 Prestashop Order updates to PrestaShop 15 Prestashop Product match PrestaShop 120 Prestashop Stock updates to PrestaShop with changed stock 15 Shopify Changed Product Match Shopify 30 Shopify Full stock update to Shopify 1440 Shopify Import orders from Shopify 5 Shopify Import product information from Shopify 720 Shopify Order status shipped to Shopify 5 Shopify Product match Shopify 120 Shopify Stock updates to Shopify for products with changed stock 5 Shopware Changed Product Match Shopware 30 Shopware Full stock update to Shopware 1440 Shopware Import orders from Shopware 15 Shopware Order updates to Shopware 15 Shopware Product match Shopware 120 Shopware Stock updates to Shopware for products with changed stock 15 woocommerce Changed Product Match Woocommerce 30 woocommerce Full stock update to WooCommerce 1440 woocommerce Order import from Woocommerce 5 woocommerce Order status shipped update to WooCommerce 15 woocommerce Product match WooCommerce 120 woocommerce Stock updates to WooCommerce for products with changed stock 15"
  },
  "Algemene-informatie/Koppelingen/1.-Koppelingen-dataflow/Shippercode-en-Origin-(kanaal)-mappen/index.html": {
    "href": "Algemene-informatie/Koppelingen/1.-Koppelingen-dataflow/Shippercode-en-Origin-(kanaal)-mappen/index.html",
    "title": "Shippercode en Origin (kanaal) mappen",
    "keywords": "Shippercode en Origin (kanaal) mappen Verzendcode mappen: Bij de meeste koppelingen importeren wij de verzender code vanuit de webshop mee. Het is mogelijk om op basis van de verzendercode die Monta importeert een actie te ondernemen. 1. Verzender aanpassen: We kunnen op basis van de verzendercode die Monta® importeert de gewenste verzender binnen de order plaatsen. Zo kunnen we dus de code koppelen aan één bepaalde verzender. LET OP! Alles vanaf haakje openen ( wordt genegeerd door onze koppelingen, dit om meerdere vergelijkbare codes gemakkelijk aan 1 vervoerder te kunnen koppelen. Dit kan worden ingesteld in de backend van Monta in de tabel: tblRelatieSystemConnectionDataFlowOrderImportSettingsShippers 1.1 VerzenderOptie toevoegen Het is mogelijk om aan de bovenstaande mapping ook een verzender optie toe te voegen. Een voorbeeld hiervan kan zijn \"PostNL Avondlevering\" Dit kan worden ingesteld in de backend van Monta in de tabel tblRelatieSystemConnectionDataFlowOrderImportSettingsShipperOptions. 2. Kanaal aanpassen Het is ook mogelijk om op basis van de verzendcode in de order een kanaal te selecteren. De order wordt dan op een andere esetting geplaatst dan de standaard. (Usercase: Dit kan bijvoorbeeld interessant zijn bij Afhaalorders. Door de verzendcode afhalen te mappen naar een kanaal die automatisch op verzonden komt te staan zal monta deze order niet versturen, maar kan de order wel via de RMA worden aangemeld) Dit kan worden ingesteld in de backend van Monta in de tabel: tblRelatieSystemConnectionDataFlowOrderImportSettingsShippers Origin (kanaal) mappen Bij sommige koppelingen importeert monta een origin mee. De origin (Ook wel kanaal genoemd) is de bron van de bestelling. Verschillende origines maken het mogelijk verschillende instellingen zoals lay-out pakbon engewenste verladers. 1. Kanaal aanpassen Op basis van de gevulde waardes origin kan je de order op een ander kanaal laten binnenkomen dan de standaard. Dit kan worden ingesteld in de backend van Monta in de tabel: tblRelatieSystemConnectionDataFlowOrderImportSettingsOrigins Je kan binnen 1 koppeling meerdere mappings hebben naar verschillende origins. (Usercase: Bij magento kan je op 1 backend meerdere voorkanten hebben. Bijvoorbeeld bij meerdere talen. Je wilt deze talen op verschillende kanalen binnen monta laten binnenkomen omdat je dan met de pakbonnen en emails hier rekening mee kan houden) Standaard importeert monta in de default esetting. Als hij een match vindt in bovenstaande tabel, dan zal hij de order in een andere esetting importeren. Het is ook in te stellen dat wanneer er geen overeenkomende mapping is, dat hij de order niet importeert. Dit is te doen door de default esetting te verwijderen in de volgende tabel\": tblRelatieSystemConnectionDataFlowOrderImportSettings"
  },
  "Algemene-informatie/Koppelingen/1.-Koppelingen-dataflow/index.html": {
    "href": "Algemene-informatie/Koppelingen/1.-Koppelingen-dataflow/index.html",
    "title": "1. Koppelingen dataflow",
    "keywords": "1. Koppelingen dataflow Bij Monta hebben we standaard koppelingen die voor al onze klanten werken. Op deze manier kunnen we de bedrijfszekerheid van de koppelingen garanderen. Er zijn een aantal standaard onderdelen die onze koppelingen hebben. Welke onderdelen de koppelingen precies hebben is afhankelijk van de type koppelingen. Algemene onderdelen De meeste koppelingen bevatten de volgende onderdelen. Afhankelijk van het platform kan je zien welke onderdelen de koppeling precies bevat. Productimport (producten vanuit webshop in Monta omgeving) Product Match (producten vanuit webshop gekoppeld met de producten in de Monta omgeving) Stockupdate (Voorraad die bij Monta ligt wordt verstuurd naar webshop) Order import (Orders worden in Monta geïmporteerd) Order status update (Orderstatus wordt naar webshop doorgestuurd) Refund update (Van retouren met de status \"Please refund\" wordt een refund gemaakt in de webshop waarmee de consument zijn geld terugkrijgt) Letop: Niet alle koppelingen hebben alle onderdelen! Productimport De product import importeert de producten uit de shop en plaatst deze informatie in de Montaportal. afhankelijk van het platform worden verschillende gegevens geïmporteerd. Product match De nieuwe koppeling draait naast een Product Information Import ook een Product Match. De Product Import importeert de producten uit de webshop en plaatst deze in de Montaportal. De Product Match koppelt de producten die bij Montapacking bekend zijn met de producten die in de webshop staan. Dit heeft als voordeel dat de voorraadupdate nu per product kan worden uitgezet. Wel belangrijk hierbij is dat er NOOIT 2 producten in de webshop mogen zijn met twee keer dezelfde barcode. De productmatch doet de match op basis van eerst de SKU en daarna de barcode. Als één van de twee overeenkomt zal hij de match maken. Order Import De order import haal de ordergegevens van de webshop binnen. De meeste koppelingen filteren hierbij op de status PAID en PROCESSING. We halen dus de openstaande en betaalde orders binnen. Alle andere orders zullen niet worden meegenomen in de Orderimport. Bekijk per koppeling welke statussen we binnenhalen, en of het mogelijk is om deze statussen uit te bereiden met andere statussen. Verzenderkeuze importeren In de order kan meegegeven worden met welke verzender Monta de order moet verzenden. Dit kan op twee manieren: met een mapping en 'hardcoded'. Verzenderkeuze mapping In een aantal systemen kan de klant zelf verzendopties aanmaken. Deze krijgen dan een code of nummer. In de instellingen van de order import kan deze code of dit nummer 'gemapt' worden naar een Monta verzender. Bij de mapping kunnen ook verzendopties worden toegevoegd. En kan een aantal extra verzenddagen worden ingesteld (zie Outbound - Geplande verzenddatum). De volgende platformen kunnen de verzenderkeuze importeren met een mapping: AFAS, Amazon Vendor, BigCommerce, CCVShop, Exact Online, Excel/CSV over FTP, Lightspeed eCom, Magento, PrestaShop, Shopify, Shopware, Silius, WooCommerce, Leroy Merlin. Harcoded verzenderkeuze import Sommige platformen hebben 'vaste' verzendopties. Bijvoorbeeld Bol.com. Ook kunnen er in webshopsystemen plugins geïnstalleerd worden die bepaalde verzendopties aanbieden. Het importeren van deze verzendopties gebeurd automatisch zonder dat er iets voor ingesteld hoeft te worden, als wij dit ondersteunen voor het betreffende platform/de betreffende plugin. Zie hiervoor de documentatie van het betreffende platform. Order Update De order Update koppelt aan de webshop terug dat een order is verzonden. Dit doet hij samen met de track&trace informatie. Welke informatie precies wordt verstuurd is te vinden bij de koppelingen uitleg. Stock Update Monta is leidend als het gaat om de voorraadstand. Alle voorraad wordt door Monta geteld en opgeboekt in het magazijn. Het is mogelijk om deze voorraadstand naar de webshop te sturen. Dit kan door middel van 2 verschillende flows. Full stockupdate Deze flow stuurt 1 keer per dag alle voorraadstanden van alle producten naar de shop. Changed StockUpdate: Deze stuurt gedurende de dag alle voorraadstanden die bij veranderd. Alle voorraad is op Relatieniveau. Dit betekend wanneer een klant meerdere koppelingen heeft, en er bij 1 koppeling een order komt; dat de voorraadstand bij alle koppelingen wordt geupdate. Refund update Monta kan via de koppeling zorgen dat de consument het aankoopbedrag van een retour terugkrijgt. De retour moet dan op de opvolgactie \"Please refund\" gezet worden. Er wordt dan in de webshop een credit gemaakt. De webshop maakt dan via de payment provider een refund. Stock mutation update Enkele koppelingen hebben een StockMutaion dataflow. Deze stuurt de voorraadstand van enkel de volgende mutaties: Mutation: Breuk of kwijt. (Geen opboeking, die lopen via de FullStock) Transfer: Omboeking naar ander matriaal of andere Batch Unknown return: Retouren zonder vooraanmelding Purchase order export Monta kan de aangemaakte MontaPortal inkooporders exporteren naar Exact Online. Deze inkooporders kunnen weer verder verwerkt door de Inbound forecast import en Inbound update."
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/Amazon/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/Amazon/index.html",
    "title": "Amazon",
    "keywords": "Amazon Koppeling algemeen Standaard onderdelen Bij Monta hebben we standaard koppelingen die voor al onze klanten werken. Op deze manier kunnen we de bedrijfszekerheid van de koppelingen garanderen. De koppeling van Amazon bevat de volgende onderdelen: Product match Stock updates Order import Order status update Full stock update Deze onderdelen noemen we dataflows en zijn afhankelijk van elkaar in te stellen en te activeren. Meer informatie van deze dataflows kun je hier vinden Speciale onderdelen: Speciale onderdelen zijn onderdelen van een koppeling die wel bestaan, maar die actief worden aangeboden. Dit is vaak omdat dit óf instabiele koppelingsonderdelen zijn; óf omdat hier data over heen gaat die extra aandacht nodig heeft. Mocht er interesse zijn in een speciaal onderdeel, neem dan contact op met Monta IT. Er bestaat ook een koppeling met de Vendor Amazon. Import orders from Amazon Vendor Order status shipped update to Amazon Vendor Full stock update to Amazon Vendor Changed stock update to Amazon Vendor Koppeling maken Om de koppeling te maken moet er contact zijn met een Medewerker van Monta. We zullen daarbij vragen naar een aantal gegevens die we nodig hebben om een koppeling te maken. Voor Amazon moeten wij weten welke marketplace (land) gekoppeld moet worden. Om de koppeling te maken kan het volgende document worden gebruikt: AmazonDeveloperRegistration.pdf Instellingen Binnen de koppeling kan je verschillende instellingen maken. Naast deze koppeling specifieke settings zijn er ook een aantal dataflow settings (Dit zijn settings die voor alle koppelingen gelden) Dataflow instellingen FAQ Hieronder zijn staan onderwerpen waar vaak onduidelijkheid over is bij deze koppeling. Geen bekende onderwerpen"
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/Bigcommerce/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/Bigcommerce/index.html",
    "title": "Bigcommerce",
    "keywords": "Bigcommerce Koppeling algemeen Standaard onderdelen Bij Monta hebben we standaard koppelingen die voor al onze klanten werken. Op deze manier kunnen we de bedrijfszekerheid van de koppelingen garanderen. De koppeling van BigCommerce bevat de volgende onderdelen: Order Import (Importeert statussen: 11: Awaiting Fulfillment en 5: Cancelled) Product Match (Incl. Product informatie import) Changed Stock Update Full Stock Update Order Update (Zet orderstatus naar 2: Shipped) Changed Product Match (Letop: Dit onderdeel wordt niet standaard aan de koppeling toegevoegd. ) Deze onderdelen noemen we dataflows en zijn afhankelijk van elkaar in te stellen en te activeren. Meer informatie van deze dataflows kun je hier vinden Speciale onderdelen: Speciale onderdelen zijn onderdelen van een koppeling die wel bestaan, maar die niet actief worden aangeboden. Dit is vaak omdat dit óf instabiele koppelingsonderdelen zijn; óf omdat hier data over heen gaat die extra aandacht nodig heeft. Mocht er interesse zijn in een speciaal onderdeel, neem dan contact op met Monta IT. Deelleveringen: De koppeling van Bigcommerce ondersteunt geen deelleveringen update. De order wordt op verzonden gezet wanneer de originele order wordt verzonden. Orderwijzigingen: Met de instelling UpdateWhenAlreadyExistsAndPlatformSupportsIt kunnen we orderwijzigingen en annuleringen importeren. Koppeling maken Om de koppeling te maken moet er contact zijn met een Medewerker van Monta. We zullen daarbij vragen naar een aantal gegevens die we nodig hebben om een koppeling te maken. Ga naar LINK NAAR KOPPELING MAKEN PAGINA om de benodigde gegevens te bekijken. Instellingen Deze koppeling heeft (nog) geen koppeling specifieke settings. Er zijn ook een aantal dataflow settings (Dit zijn settings die voor alle koppelingen gelden) Deze kun je hier vinden: Dataflow instellingen Checkout Module Deze koppeling ondersteund onze universele checkout. Meer informatie over de module en configuratie kun je hier vinden: Bigcommerce checkout FAQ Hieronder zijn staan onderwerpen waar vaak onduidelijkheid over is bij deze koppeling."
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/Bol.com/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/Bol.com/index.html",
    "title": "Bol.com",
    "keywords": "Bol.com Dataflows Bij de bol koppeling hebben we de volgende dataflows beschikbaar: Changed Stock Update Product Match (Letop: deze Productmatch bevat geen product import) Full stock update Order Import Order Update Return Forecast Import Refund Create (Letop: Dit onderdeel wordt niet standaard toegevoegd ana de koppeling) Changed Product Match (Letop: Dit onderdeel wordt niet standaard toegevoegd ana de koppeling) Deze koppeling beschikt over dataflow instellingen. Meer informatie hierover is te vinden via Dataflow instellingen Bijzonderheden Order import Annuleringen binnenhalen: Bij deze koppeling is het mogelijk om annuleringen binnen te halen. Dit is in te stellen in de Dataflow settings van de koppeling. LETOP: Het is niet mogelijk om wijzigingen binnen te halen. Productinformatie: Letop: Binnen bol worden er vaker producten aangemaakt onder een andere barcode dan dat er fysiek op het product staan. Onze klanten doen dit zodat ze beter vindbaar zijn in Google en Bol. Het is echter van belang dat de Barcode in monta overeen komt met de barcode die fysiek op het product staat. De combinatie van die twee kan ervoor zorgen dat de productmatch de producten niet aan elkaar kan koppelen. Let hierop."
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/CCV-Shop/Koppeling-maken-CCV-Shop/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/CCV-Shop/Koppeling-maken-CCV-Shop/index.html",
    "title": "Koppeling maken CCV Shop",
    "keywords": "Koppeling maken CCV Shop Vraag aan de klant de Base URL, Client ID & Client Secret. Deze kun je in de backend van CCV Shop aanmaken: Mijn Webshop / Instellingen / API Instellingen. Als deze instellingen niet zichtbaar zijn, kan het zijn dat de klant de API App moet installeren uit de CCV Shop Appstore. Maak de platform Settings aan in de tblRelatieSystemConnectionPlatformCCVShopSettings en onthoud de ID / CCVShopPlatformSettingsID Maak de relatiesystemconnections aan in tblRelatieSystemConnections. Dit zijn de dataflows die ondersteund worden: 53 Product Information Import - CCV Shop 54 Order Import - CCV Shop 55 Changed Stock Update - CCV Shop 57 Order Update - CCV Shop 62 Full Stock Update - CCV Shop en noteer de RSCID's die je hebt aangemaakt. Maak de type settings aan voor elke dataflow die je wilt gebruiken. Zowel de Stock update (62) als de Changed (55) kunnen in tblRelatieSystemConnectionTypeStockUpdateCCVShopSettings Maak de dataflow settings aan voor elke dataflow die je wilt gebruiken. Vergeet hier de tblRelatieSystemConnectionDataFlowOrderUpdateStatussesOnly niet. Zorg dat je geen ProductMatchRelatieSystemConnectionID meegeeft, in de tblRelatieSystemConnectionDataFlowStockUpdateSettings. Anders werkt hij niet aangezien CCV geen selling products optie heeft."
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/CCV-Shop/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/CCV-Shop/index.html",
    "title": "CCV Shop",
    "keywords": "CCV Shop Dataflows 53 Product Information Import - CCV Shop 54 Order Import - CCV Shop 55 Changed Stock Update - CCV Shop 57 Order Update - CCV Shop 62 Full Stock Update - CCV Shop Deze koppeling beschikt over dataflow instellingen. Meer informatie hierover is te vinden via Dataflow instellingen Instellingen Order Import OrderStatusToImport= Definieer hier de order statussen die geimporteerd moeten worden. Standaard is dit 1. ImportUnpaidOrders = Wanneer deze optie aan staat kun je ook onbetaalde orders importeren. OnlyImportUnpaidIfMatchesStatus = Met deze instelling kun je een definitie mee geven die je wilt importeren als de betaalstatus unpaid is. Bijvoorbeeld betaalmethode 'op rekening' CardTextAttrOptionName = Instellingen Product Information ImportOnlyMontapackingInCategory = Importeer alleen producten met categorie 'montapacking' ImportVariants = Importeer ook varianten van producten Koppeling maken Om de koppeling te maken moeten er een aantal stappen worden doorlopen. Meer informatie hierover is te vinden op: Koppeling maken CCV Shop"
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/Exact-Online/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/Exact-Online/index.html",
    "title": "Exact Online",
    "keywords": "Exact Online Dataflows: Inbound Forecast Import Order Import (Filter op status open) Inbound Update Order Update Changed Stock Update Full Stock Update: Loopt nu via queue items van alle materialen. Hierdoor worden bij groot assortiment niet iedere keer alleen van de 1e 300 producten een stockupdate verstuurd. Nu gaat na crash (bijvoorbeeld too many request) de full stock verder met de volgende producten uit de queue. (Letop: Exact Online bevat geen product import). Instellingen Inbound forecast Import: OnlyFromSetWarehouse = Met deze instelling aan importeren we alleen purchase orders van het ingestelde magazijn in de platform-settings. Bij Inboundforecastimportsettings is het mogelijk om in te stellen dat wij regels importeren die op een later moment aan de inkooporder in Exact toegeveogd worden. Voeg hierbij het RelatieSystemConnectionID toe en geef bij DisableUpdate; False in. Order Import: DeliveryStatussen : Standaard is hier de status 12 ingevuld(open). Mogelijke aanvullingen zijn; 20 = Partial, 21 = Complete, 45 = Cancelled. UsePlannedShipmentDate : Standaard haalt Monta de geplande verzenddatum niet mee. Als je deze instelling aanzet haalt monta deze data wel mee, en zal de gewenste leverdatum worden gebruikt in de order. ImportOrdersAsB2b = Standaard importeerd monta alle orders als B2C. Wanneer je deze instelling aanzet zal de order worden gemarkeerd als B2B. Verzendopties importeren De \"verzendmethode beschrijving\" wordt uitgelezen en kan gemapt worden aan een verzender met evt. opties. Order Update. Shipping Method terug sturen naar Exact. om de Shipping Method terug te kunnen sturen naar Exact moet de guid ingesteld worden in tblRelatieSystemConnectionDataFlowOrderImportSettingsShippers want bij de order update wordt gecheckt naar de guid in dit table, als het ingesteld is dan wordt de guid naar Exact gestuurd anders blijft dit property leeg bij default. Bijzonderheden DE en NL versie koppeling Voor Exact Online is het mogelijk om voor NL of DE een nieuwe koppeling te maken, door in de popup bij het aanmaken van de koppeling voor NL of DE te kiezen in de dropdown. De urls en de credentials voor de Exact Online omgeving voor NL en DE staan in passwordstate. Orderwijzigingen: Met de instelling UpdateWhenAlreadyExistsAndPlatformSupportsIt kunnen we orderwijzigingen en annuleringen importeren. Financiele voorraadstanden Sommige exact online omgevingen hebben de financiele stock nodig ipv de beschikbare voorraad. Hiervoor hebben we een mogelijkheid ingebouwd, dit is echter nog geen instelling. Dit moet worden gedaan door iemand van monta IT. [[Doelgroep: IT De instelling moet in de code worden gedaan op line: 60 in code https://dev.azure.com/MontaDevelopment/Montapacking/_git/RelatieSystemsConnector?path=/RelatieSystemsConnector/Platforms/ExactOnline/ExactOnlineStockUpdateType.cs Inbound Update goedkeuren Koppelen na goedkeuring in de montaportal het aantal terug die zijn ingeboekt in het magazijn. Dit kan dus verschillen met wat er is vooraangemeld (zowel positief als negatief). Als de inbound forecast niet overeen komt met de inbound dan moet deze door de klant handmatig worden goedgekeurd. API-snelheidslimieten: Exact online heeft strenge snelheidslimieten, die de werking beperken met het aantal verzoeken dat de koppeling gedurende een bepaalde periode mag verzenden. Elke limiet heeft een specifiek gedrag wanneer deze wordt overschreden. Minuutlimiet - uw app kan 60 API-aanroepen doen, per bedrijf, per minuut. Dagelijkse limiet - uw app kan 5.000 API-aanroepen doen, per bedrijf, per dag. Het kan dus zijn dat de koppeling in sommige gevallen over zijn limiet heengaat, met name bij een groot assortiment. Houdt hier rekening mee bij het besluit voor het koppeling via Exact Online. WarehouseID: Bij het aanmaken van de koppeling is het verplicht om een magazijnID in te vullen. Het magazijnID is te vinden in een salesorder in Exact Online via: Exact online Dataflows: Inbound Forecast Import Order Import (Filter op status open) Inbound Update Order Update Changed Stock Update Full Stock Update: Loopt nu via queue items van alle materialen. Hierdoor worden bij groot assortiment niet iedere keer alleen van de 1e 300 producten een stockupdate verstuurd. Nu gaat na crash (bijvoorbeeld too many request) de full stock verder met de volgende producten uit de queue. (Letop: Exact Online bevat geen product import). Instellingen Inbound forecast Import: OnlyFromSetWarehouse = Met deze instelling aan importeren we alleen purchase orders van het ingestelde magazijn in de platform-settings. Bij Inboundforecastimportsettings is het mogelijk om in te stellen dat wij regels importeren die op een later moment aan de inkooporder in Exact toegeveogd worden. Voeg hierbij het RelatieSystemConnectionID toe en geef bij DisableUpdate; False in. Order Import: DeliveryStatussen : Standaard is hier de status 12 ingevuld(open). Mogelijke aanvullingen zijn; 20 = Partial, 21 = Complete, 45 = Cancelled. UsePlannedShipmentDate : Standaard haalt Monta de geplande verzenddatum niet mee. Als je deze instelling aanzet haalt monta deze data wel mee, en zal de gewenste leverdatum worden gebruikt in de order. ImportOrdersAsB2b = Standaard importeerd monta alle orders als B2C. Wanneer je deze instelling aanzet zal de order worden gemarkeerd als B2B. Verzendopties importeren De \"verzendmethode beschrijving\" wordt uitgelezen en kan gemapt worden aan een verzender met evt. opties. Order Update. Shipping Method terug sturen naar Exact. om de Shipping Method terug te kunnen sturen naar Exact moet de guid ingesteld worden in tblRelatieSystemConnectionDataFlowOrderImportSettingsShippers want bij de order update wordt gecheckt naar de guid in dit table, als het ingesteld is dan wordt de guid naar Exact gestuurd anders blijft dit property leeg bij default. Bijzonderheden DE en NL versie koppeling Voor Exact Online is het mogelijk om voor NL of DE een nieuwe koppeling te maken, door in de popup bij het aanmaken van de koppeling voor NL of DE te kiezen in de dropdown. De urls en de credentials voor de Exact Online omgeving voor NL en DE staan in passwordstate. Orderwijzigingen: Met de instelling UpdateWhenAlreadyExistsAndPlatformSupportsIt kunnen we orderwijzigingen en annuleringen importeren. Financiele voorraadstanden Sommige exact online omgevingen hebben de financiele stock nodig ipv de beschikbare voorraad. Hiervoor hebben we een mogelijkheid ingebouwd, dit is echter nog geen instelling. Dit moet worden gedaan door iemand van monta IT. [[Doelgroep: IT De instelling moet in de code worden gedaan op line: 60 in code https://dev.azure.com/MontaDevelopment/Montapacking/_git/RelatieSystemsConnector?path=/RelatieSystemsConnector/Platforms/ExactOnline/ExactOnlineStockUpdateType.cs Inbound Update goedkeuren Koppelen na goedkeuring in de montaportal het aantal terug die zijn ingeboekt in het magazijn. Dit kan dus verschillen met wat er is vooraangemeld (zowel positief als negatief). Als de inbound forecast niet overeen komt met de inbound dan moet deze door de klant handmatig worden goedgekeurd. API-snelheidslimieten: Exact online heeft strenge snelheidslimieten, die de werking beperken met het aantal verzoeken dat de koppeling gedurende een bepaalde periode mag verzenden. Elke limiet heeft een specifiek gedrag wanneer deze wordt overschreden. Minuutlimiet - uw app kan 60 API-aanroepen doen, per bedrijf, per minuut. Dagelijkse limiet - uw app kan 5.000 API-aanroepen doen, per bedrijf, per dag. Het kan dus zijn dat de koppeling in sommige gevallen over zijn limiet heengaat, met name bij een groot assortiment. Houdt hier rekening mee bij het besluit voor het koppeling via Exact Online. WarehouseID: Bij het aanmaken van de koppeling is het verplicht om een magazijnID in te vullen. Het magazijnID is te vinden in een salesorder in Exact Online via:"
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/FTP/CSV-over-FTP/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/FTP/CSV-over-FTP/index.html",
    "title": "CSV over FTP",
    "keywords": "CSV over FTP CSV over FTP Het is mogelijk om bij monta data via CSV over FTP uit te wisselen. Monta heeft een standaard koppeling om deze data uit te wisselen. De bestanden kunnen op de server van de klant, of op de server van Monta worden geplaatst. Onderdelen koppeling: De koppeling van Monta heeft een aantal standaard dataflows: Import product information from CSV or Excel files from FTP CSV with stock of products with changed stock to FTP CSV with stock of all products to FTP Order status shipped CSV to FTP Import orders from CSV or Excel files from FTP Import inbound forecasts from CSV or Excel files from FTP Beschikbare data: Per dataflow kan bepaalde data worden uitgewisseld. Hieronder is per dataflow aangegeven welke data er kan worden uitgewisseld. Product informatie import * Klant plaatst data op server. Column type Supported column names Sku SKU, Sku, sku Description Name, Description, Article_Description, NAME Barcode EAN, Ean, Barcode, EANcode, CeEan, secondarybarcode, EAN2, PrimaryBarcode, SecondaryBarcode Sell price Price, Sell price Purchase price Purchase price, Cost, Costprice, inkoopprijs, Price_manufacturer, PurchasePrice Supplier product code Supplier product code, Supplier sku, SupplierProductCode Supplier title Supplier, Manufacturer Image URL Image, ImageUrl Minimum stock Minimum stock, MinStock CustomField CustomField HSCode HS_code, douanecode CountryOfOrigin Country_of_origin, country_of_manufacture Order Import * Klant plaatst data op server. Column type Supported column names WebshopOrderID WebshopOrderId, Ordernumber, order_number, OrderNumber, bestelnummer, deliveryname, ShipmentRefNo, Ordernummer, order_Number Reference Klant order nummer, marketplace_order_id, Sales order nummer, OrderHumanNumber, Reference, MagentoReferentie, Referentie OrderedDateTime Orderdate Origin storeid, PurchasedWebsite, Origin, webshop_name, Dropshipper ShippingAddressCompany ShippingCompany, CompanyName, bedrijfsnaam, shipping_company ShippingAddressFirstName ShippingFirstName, FirstName, first_name, shipping_firstname ShippingAddressMiddleName ShippingMiddleName ShippingAddressLastName ShippingLastName, last_name, tav, deliverycontactname, LastName, Klant, shipping_lastname ShippingAddressStreetOrAddress1 ShippingAddress1, ShippingStreet, deliveryaddress, Street, Adres, address, adres, shipping_street ShippingAddressHouseNumberOrAddress2 ShippingAddress2, ShippingHouseNo, HouseNumber, Huisnummer, shipping_street2 ShippingAddressHouseNumberAdditionOrAdress3 ShippingAddress3, ShippingHouseNoAddition, HouseNumberExt, shipping_street3 ShippingAddressPostalCode ShippingPostalCode, ShippingPostcode, deliveryzipcode, Zipcode, Postcode, zip, postcode, shipping_postcode ShippingAddressCity ShippingCity, deliverycity, City, Plaats, city, woonplaats, shipping_city ShippingAddressState ShippingState, shipping_region ShippingAddressCountry ShippingCountry, deliverycountry, Country, Landcode, country_name, Land, shipping_country_id ShippingAddressEmail ShippingE-Mail, ShippingEmail, Email, shipping_email, CustomerEmail ShippingAddressPhone postnl_mobile_phone_number, ShippingPhone, Mobiel, Telefoon, shipping_telephone InvoiceAddressCompany InvoiceCompany, BillingCompany, bedrijfsnaam, billing_company InvoiceAddressFirstName InvoiceFirstName, BillingFirstName, billing_firstname InvoiceAddressMiddleName InvoiceMiddleName, BillingMiddleName InvoiceAddressLastName InvoiceLastName, BillingLastName, billing_lastname InvoiceAddressStreetOrAddress1 InvoiceAddress1, BillingAddress1, BillingStreet, InvoiceStreet, adres, billing_street InvoiceAddressHouseNumberOrAddress2 InvoiceAddress2, BillingAddress2, BillingHouseNo, InvoiceHouseNo, billing_street2 InvoiceAddressHouseNumberAdditionOrAdress3 InvoiceAddress3, BillingAddress3, BillingHouseNoAddition, InvoiceHouseNoAddition, billing_street3 InvoiceAddressPostalCode InvoicePostcode, BillingPostcode, postcode, billing_postcode InvoiceAddressCity InvoiceCity, BillingCity, woonplaats, billing_city InvoiceAddressState InvoiceState, BillingState, billing_region InvoiceAddressCountry InvoiceCountry, BillingCountry, Land, billing_country_id InvoiceAddressEmail InvoiceE-Mail, BillingE-Mail, BillingEmail, InvoiceEmail, email, billing_email InvoiceAddressPhone InvoicePhone, BillingPhone, billing_telephone OrderInvoiceDebtorNumber Debtornummer, CustomerID DeliveryDateRequested postnl_delivery_date, delivery_date_requested ShippingDeadline Uiterlijke_verzenddatum AllowedShipperCode ShipperInfo, ShippingMethod, Shippercode, IsPickupLocation, ShippingOptionsShipperCode ShipperOptionCode postnl_type InvoicePaymentMethod PaymentMethod, payment_method_title InvoiceShippingTotalExclTax ShippingCost InvoiceTotalInclTax GrandTotal, order_grand_total InvoiceTotalTax TotalTax, order_tax_amount OrderLineSku ArticleSKU, ItemSKU, SKU, productsku, ProductCode, Artikelcode, order_item_sku, item_sku OrderLineQuantity OrderedQty, ItemOrdered, Aantal, amount, Colli, product_quantity, item_qty OrderLineDescription ItemName, order_item_name, item_name OrderLineReference Sales order regel nummer InvoiceLinePriceExTax line_price_excl_VAT InvoiceLinePricePerPieceExTax ItemPrice, item_price, unit_price_excl_VAT InvoiceLinePriceInclTax line_price_incl_VAT ShippingDocumentUrl ShippingDocumentUrl SurprisePackCodeOrder giftwrap SurprisePackCodeLine GiftWrapDesign MontacheckoutData montapacking_montacheckout_data, monta_montacheckout_data B2B B2b, B2B Currency currency, Currency, order_order_currency_code InvoiceLineTaxPercentage TaxPercent, item_tax_percent InvoiceTotalDiscount order_discount_amount, TotalDiscount ProductWeight Weight, ProductWeight ProductLength Length, ProductLength ProductWidth Width, ProductWidth ProductHeight Height, ProductHeight CountryOfOrigin CountryOfOrigin, Transport_Country_Of_Origin HsTariefCode HsTariefCode, StatisticalCode InvoiceLinePricePerPieceIncTax unit_price_incl_VAT Shipper option \"DHL Parcel Connect Harmonised ID\" for shipper \"DHL Parcel Connect Pickup Point\" Packingstationcode Shipper option \"DHL Parcel Connect ID (Van Parcelshop or Packstation)\" for shipper \"DHL Parcel Connect Pickup Point\" DHLPCID Shipper option \"DHL Parcel Connect PostNummer - Verplicht bij PackStation naar Duitsland\" for shipper \"DHL Parcel Connect Pickup Point\" Postnumber Shipper option \"Code van servicepunt\" for shipper \"DHL (servicepunt)\" DHLPickup Shipper option \"ID van de DPD parcelstore waar het pakket klaargelegd moet worden om door de consument opgehaald te worden\" for shipper \"DPD parcelstore\" DPDparcelshopNummer Shipper option \"Code/ID van het pickup point van Pakjegemakt\" for shipper \"Pakje gemak van PostNL\" PakjeGemakBE_PickupPointCode Shipper option \"Retail ID van pakjegemak voor BE\" for shipper \"Pakje gemak van PostNL\" PakjeGemakBE_PickupPointRetailID Orderwijzigingen: Met de instelling UpdateWhenAlreadyExistsAndPlatformSupportsIt kunnen we orderwijzigingen en annuleringen importeren. Order Update Monta plaatst file op server Information in file: WebshopOrderID Status barcode ShipperName Trackign link Shipper Stock update full Monta plaatst file op server Informations in File: SKU Stock StockForecasted Stock Update changed * Monta plaatst file op server Information in file: SKU Stock In dit gedeelte van de koppeling zijn er ook een aantal instellingen/ keuzes beschikbaar: Settings: Add primary barcode: no/yes Forecasted stock in separate column: no/yes Allow negative stock: no/yes Inbound forecast * Klant plaatst file op server Column type Supported column names Reference POnumber, Reference Comment Comment ExpectedDeliveryDate ExpectedDeliveryDate SupplierCode SupplierCode SupplierName SupplierName Sku Sku, SKU Quantity Quantity, Qty, Quantitiy IncludeInWebshopStock IncludeInStock, IncludeInWebshopStock"
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/FTP/XML-over-FTP/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/FTP/XML-over-FTP/index.html",
    "title": "XML over FTP",
    "keywords": "XML over FTP Het is mogelijk om bij monta data via XML over FTP uit te wisselen. Monta heeft een standaard koppeling om deze data uit te wisselen. De bestanden kunnen op de server van de klant, of op de server van Monta worden geplaatst. Monta heeft een vast format voor de XML bestanden. Als de klant een eigen format heeft, kunnen aan de klant van Monta XSLT bestanden ingesteld worden om het format van de klant te vertalen naar het Monta format en andersom. Onderdelen koppeling De koppeling van Monta heeft een aantal standaard dataflows: Import product information from XML or Excel files from FTP (Product import) Import orders from XML or Excel files from FTP (Order import) Order status update XML to FTP (order update) XML with stock of all products to FTP (Full stockupdate) XML with stock of products with changed stock to FTP (Changed stock update) Import inbound forecasts from XML or Excel files from FTP (Vooraanmeldingen) Import inbound updates from XML or Excel from FTP (Terugkoppeling vooraanmeldingen) Return Received updates (Terugkoppeling retour) Beschikbare data binnen dataflows Per dataflow kan bepaalde data worden uitgewisseld. Hieronder is per dataflow aangegeven welke data er kan worden uitgewisseld. Product Import |Column type|Supported | |--|--| |Products | Product | | Sku| Sku | |Barcodes | Barcode | | Supplier code | SupplierCode | | Delete | Delete | ProductInformationImport.xml *Klant plaatst op server Order Import *Klant plaatst op server Order.xml Met de instelling UpdateWhenAlreadyExistsAndPlatformSupportsIt kunnen we orderwijzigingen en annuleringen importeren. Verzenderkeuze importeren In AllowedShipperCodes in de XML kan de klant één of meer codes aangeven waarmee de order verzonden mag worden. Deze codes moeten gemapt worden in de order import instellingen. Order Update OrdersUpdated.xml Order Full Stock StockUpdates_FullStock_Voorbeeld.xml Changed Stock DD_SM20221116115032571.xml Inbound forecasts *Klant plaatst op server InboundsForecast.xml Inbound updates InboundsUpdated.xml Return Received Updates ReturnReceived_Example.xml"
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/FTP/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/FTP/index.html",
    "title": "FTP",
    "keywords": "FTP FTP De FTP server is extern te benaderen via: ftp://[username]:[ww]@orders.montaportal.nl/[folder]/[subfolder] Voordat de server kan worden benaderd moeten de Ip adressen van de klant worden toegestaan. Let ook op dat je de juiste poort achter de url zet, indien je niet gebruik maakt van poort 21. Dataflows Order import Via XML is het mogelijk om annuleringen en wijzigingen binnen te halen bij de koppeling."
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/IT's-Perfect/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/IT's-Perfect/index.html",
    "title": "IT's Perfect",
    "keywords": "IT's Perfect IT's perfect is een ERP systeem voor Fashion. Klanten sluiten hun webshop aan op IT's perfect en IT's perfect stuurt de orders weer door naar Monta. Dit gaat via een XML over FTP koppeling. Zie Koppelingen - XML over FTP voor meer informatie. IT's Perfect koppeling maken 2 Esettings (B2C en B2B) en Montaportal maken RelatieSystemConnectionID's Jacky Luxury opschrijven: PII 10683, OI 10678, OU 10679, FSU 10686, RRU 10685, IFI 10682, IU 10681 Mappen Jacky Luxury kopiëren en prefix van aanpassen in FTP op extern bureaublad FTP gebruiker Jacky Luxury kopiëren en prefix aanpassen en nieuw wachtwoord instellen RelatieSystemConnectionTypes met PlatformID 9 opschrijven (PI 61, OI 32, OU 35, FSU 67, RRU 65, IFI 51, IU 45) RelatieID Jacky Luxury en nieuwe klant opschrijven: 27668 -> 27794 EsettingID's opschrijven: 4979 & 4980 -> 5221 & 5222 RelatieSystemConnections aanmaken met disabled op true RelatieSystemConnectionID's nieuwe klant opschrijven: 12212, 12213, 12215, 12216, 12217, 12218, 12219 -> 12249 t/m 12255 DataFlows aanmaken met nieuwe RelatieSystemConnectionID's PlatformFtpSettings kopiëren en relatiesystemconnectionID's, prefixes en relatieID aanpassen Type Inbound/OrderStatusUpdate FtpXmlSettings aanmaken DataflowOrderImportSettingsOrigins van Jacky Luxury kopiëren Configmappen kopiëren naar \\montapacking.nl\\dfs\\Appdata\\RelatieSystemConnections FAQ 1. backorders Een backordersplits kan worden gemaakt op 2 momenten: Bij het importeren Achteraf in de Montaportal of echeck. Deze twee manieren worden ook verschillend afgehandeld. Bij het importeren: Als je wilt dat Monta® nooit de backorder vasthoudt dan kan Monta® de Backorderhandeling aanzetten. Dit betekent dat we bij het importeren de niet voorradige orderlines verwijderen uit de orders. Vervolgens zetten we na het verzenden van de order de verzonden orderlines op afgehandeld in Itsperfect. De overige orderlines komen op backorder in Itsperfect, en daar creëren ze een nieuwe order voor deze producten zodra er voorraad is. Als er tijdens het importeren blijkt dat we helemaal geen van de artikelen kunnen versturen wordt de gehele order geannuleerd in ITsperfect. Achteraf in de Montaportal of echeck. Als je in de Montaportal of via de echeck een backorder maakt is het van belang dat de -1 order wordt verwijderd. Monta® zet de verzonden orderlines op afgehandeld in Itsperfect. De overige orderlines komen op backorder in Itsperfect, en daar creëren ze een nieuwe order voor deze producten zodra er voorraad is. Als we een -1 order versturen dan wordt dit nooit teruggekoppeld richting ItsPerfect. 2. Verwijderde orders Als een deel van de order niet op voorraad stuurt Monta® de 0 terug via de Backorderhandeling. Want als we de producten die wel op voorraad zijn verstuurd hebben, sturen we een bericht naar ITSP met de verzonden producten. ITSP ziet dan de producten die er niet in zitten en die worden dan ook bij ITSP geannuleerd. Als een order helemaal niet verzonden wordt, omdat ze in Montaportal verwijderd worden, stuurt Monta® de order met aantal 0 in de regels."
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/Lightspeed-ECOM/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/Lightspeed-ECOM/index.html",
    "title": "Lightspeed ECOM",
    "keywords": "Lightspeed ECOM Dataflows Order Update Full Stock Update Changed Stock Update Product Match (Incl. Product Import) Order Import Changed Product Match (Letop: Dit onderdeel wordt niet standaard toegevoegd aan de koppeling) Deze koppeling beschikt over dataflow instellingen. Meer informatie hierover is te vinden via Dataflow instellingen Bijzonderheden Order Import Gewenste leverdatum Gewenste leverdatum wordt mee geïmporteerd uit het veld deliverydate. De Lightspeed orderimport haalt altijd de annuleringen van orders op. Verzenderkeuze importeren Shipper mapping In Lightspeed kan de klant verzenders aanmaken. Zo'n verzender krijgt een ID. Deze ID staat in de URL als je de verzendmethode in Lightspeed opent, zie screenshot. Bij dit ID kan een shipper mapping aangemaakt worden. Lightspeed heeft ook plug-ins die verzendmethodes aanmaken. In dit geval moet de plug-in een ID aanmaken en plaatsen in het veld shipment_id. Deze kunnen we dan ook mappen. Ondersteunde (geteste) plug-ins: shipping-by-zipcode-shipments Monta checkout plugin Gekozen opties in de Monta checkout plugin worden geimporteerd. PostNL Plug-in De postNL plugin zorgt ervoor dat klanten in de checkout van de shop PostNL shipperopties en pick-up point kan importeren. Monta ondersteund de PostNL Plugin, waarin we een aantal opties ondersteunen: Ochtendlevering: Order in de ochtend leveren. Pickup Point (PAK): Leveren op pickup points Avondlevering: Order in de avond leveren. Niet bij de buren: Order mag niet bij de buren afgeleverd worden. Parcel Machine: Order moet worden geleverd in een Parcel box (kluisje bij winkels b.v.) SameDay: De order moet dezelfde dag nog geleverd worden. Brievenbuspakje: Order in een brievenbuspakje indien mogelijk. Paazl Plugin De Paazl plugin zorgt ervoor dat klanten in de checkout van de shop PostNL pick-up point kan importeren. Monta ondersteund de Paazl Plugin, waarin we een aantal opties ondersteunen: Pickup points B2B of B2C Een consument kan selecteren in Lightspeed of ze privé of zakelijk zijn. Wanneer de consument aangeeft een zakelijke klant te zijn dan zal de order worden geimporteerd als B2B. Als de consument aangeeft een prive klant te zijn dan zullen we de order importeren als B2C. Lighspeed omnichannel: LETOP monta kan niet koppelen met lightspeed omnichannel. Monta kan enkel koppelen met lighspeed ECOM. Instellingen order import ImportPickupOrders= Dan zet hij de order standaard op wordt afgehaald wanneer de orderstatus Processing awaiting pickup is. ImportCustomerCommentAsOrderReference = Als je deze instelling aanzet zullen we de customer commend in lightspeed importeren als Referentie in Monta. UpdateWhenAlreadyExistsInOrigin= Wordt niet meer gebruikt! Dit kan worden ingesteld in de dataflow settings. SupplierTitlesFilter = Hier kan je supplieer titles invoeren (meerder scheiden met komma's). Wanneer deze overeenkomt dan zullen we deze orderline importeren. Als de supplier niet overeenkomt dan zullen we deze orderline niet importeren. CustomStatusIds = Het is mogelijk om custom statussen te importeren via de koppeling. Dit kunnen ook meerdere statussen zijn door komma gescheiden. Deze instelling overschrijft de normale statussen niet, de standaard statussen blijven we importeren. ImportAwaitingPayment = Als je deze instelling aanzet importeren we ook de order met de betaalstatus 'Awaiting Payment\". Orderwijzigingen: Met de instelling UpdateWhenAlreadyExistsAndPlatformSupportsIt kunnen we orderwijzigingen en annuleringen importeren. Order Update Do Notify Shipped = Als deze aan staat dan zal de monta Lightspeed de trigger geven om de consument een 'Verzonden' mail te sturen vanuit lightspeed. Als deze instelling uitstaat zal er geen mail worden verstuurd uit lightspeed. DoNotifyTrackingCode = Dit is een vinkje in lightspeed die je met de koppeling aan of uit kan zetten per orderudpate. Deze instelling in lightspeed zorgt ervoor dat de trackingcode meegestuurd wordt in de verzendbevestiging vanuit lightspeed. Checkout Voor lightspeed is er een checkout module beschikbaar. Meer informatie hierover is te vinden via Checkout informatie"
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/Magento-2/Koppeling-maken-Magento/Aanmaken-Api-Keys/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/Magento-2/Koppeling-maken-Magento/Aanmaken-Api-Keys/index.html",
    "title": "Aanmaken Api Keys",
    "keywords": "Aanmaken Api Keys ##Aanmaken API Keys Stap 1: Ga naar de beheeromgeving van uw Magento 2 webshop. Stap 2: Kies voor Integraties. Stap 3: Kies voor Toevoegen van nieuwe integratie. Stap 4: Vul velden in bij Integratie info. Naam: Montapacking E-mailadres: Eigen Email adres Stap 5: Klik op API. Stap 6: Vink de volgende rechten aan en klik op opslaan. Alle rechten die te maken hebben met producten; orders; voorraad en fulfilment. Stap 7: Activeer de integratie. Stap 8: Geef Integratie Details door aan Montapacking. Samen met het baseURL"
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/Magento-2/Koppeling-maken-Magento/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/Magento-2/Koppeling-maken-Magento/index.html",
    "title": "Koppeling maken Magento",
    "keywords": "Koppeling maken Magento Benodigde gegevens Api Keys Magento2 Om de koppeling te maken heb ik een aantal api Keys nodig. Zou jij de volgende gegevens naar mij door willen sturen: Base url Gebruikers sleutel Consumer geheim Toegangstoken Toegangstoken geheim Tijdens het aanmaken van de api kun je ons bepaalde rechten toekennen. Wij hebben lezen en schrijven rechten nodig voor alles wat te maken heeft met voorraad; producten; fulfilment en orders. Informatie over het aanmaken van Api Keys in magento2 Opbouw Magento omgeving Om te zorgen dat wij enkel de juiste orders ophalen hebben we een overzicht nodig van hoe jullie je Magento hebben opgebouwd. Wij moeten weten wat de verhouding is tussen Website, store en storeview. Kun je een screenshot sturen van deze pagina, en de bijbehorende ID-nummer naar mij sturen? Attributen name Om de koppeling juist te kunnen mappen heb ik een attributen name van het barcodeveld binnen Magento nodig. Dit kan bijvoorbeeld zijn EAN. Letop, dit is hoofdletter gevoelig. Koppeling maken De koppeling kan gedeeltelijk via de montaportal worden gemaakt. Ga naar Koppelingen > Available > Magento2 Maak de koppeling aan via de montaportal met de gegevens van hierboven: Vervolgens moet een Monta medewerker de koppeling verder instellen. Neem contact op met Monta. Koppeling instellen in backend Nadat de koppeling is aangemaakt via de Montaportal moeten er een aantal instellingen worden gedaan: EAN code attributen name In tblRelatieSystemConnectionTypeProductMatchMagentoSettings Mappen in welke atribute veldnaam de EAN code staat: Letop dit veld is hoofdletter gevoelig. In het geval van meerdere shops: In magento is het mogelijk om meerdere shops te hebben. Normaal gesproken komen alle kanalen van Magento binnen in 1 esetting. Naast deze optie zijn er ook nog 2 andere opties: Bepaalde source of store selecteren, al het andere negeren Meerdere stores mappen naar meerdere esettings. 1. Bepaalde source of store selecteren, al het andere negeren In PlatformMagentoSettingskan je een bepaalde webshop selecteren. Als je deze hier invuld dan worden alle andere stores niet meegenomen in de koppeling. De websiteID en eventueel Source en StoreID invullen. 2. Meerdere stores mappen naar meerdere esettings In tblRelatieSystemConnectionDataFlowOrderImportSettings de depault Esetting naar NULL zetten. Hiermee zullen de orders niet in 1 standaard esetting belanden, maar zullen ze gebruik maken van DataflowOrderImportSettingsOrigings. in DataflowOrderImportSettingsOrigings de Origin mapping toevoegen, aangeven naar welke esetting dit moet. Gebruik hierbij de opbouw \"website - store - storeview\" met de formatting zoals in dit voorbeeld. In Dataflow productmatch settings een Regel toevoegen: Veelvoorkomende foutmeldingen X failed with the following message: Gebruiker is niet gemachtigd tot %resources Wanneer dit voorkomt, moet de gebruiker van de API de volgende optie aanzetten: ‘Allow OAuth Access Tokens to be used as standalone Bearer tokens’ Om dit aan te zetten moeten de volgende stappen worden doorlopen: Ga in je Magento 2 admin omgeving naar 'Stores' en kies hier voor 'Configuration'. Ga vervolgens naar 'advanced' en kies hier voor 'Oauth'. Onder het tabje 'Access Token Options' selecteer je 'Allow OAuth Access Tokens to be used as standalone Bearer Tokens'."
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/Magento-2/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/Magento-2/index.html",
    "title": "Magento 2",
    "keywords": "Magento 2 Dataflows Import orders Product import (Vervangen door de Product Match) (Letop: Dit onderdeel wordt niet standaard aan de koppeling toegevoegd. Order status update (multi colli; update returnlabel) Stock updates Full stock update Product match (Incl Product import) [[Doelgroep: IT Speciale onderdelen: Speciale onderdelen zijn onderdelen van een koppeling die wel bestaan, maar die actief worden aangeboden. Dit is vaak omdat dit óf instabiele koppelingsonderdelen zijn; óf omdat hier data over heen gaat die extra aandacht nodig heeft. Create refunds in Magento2 Stock updates to Magento2 from inbounds only Changed Product Match Magento Instellingen Product match Barcode Attributen Name = Normaal gesproken halen we de barcode (barcode; EAN) niet binnen met de koppeling, omdat er geen standaardveld voor is binnen Magento. In Magento kan het zijn dat dit veld wel is aangemaakt als [customField]. Door de naam van dit veld in te vullen kunnen we deze gegevens wel importeren. Vul de (veld)naam van het attribuut in. SecondaryBarcodeAttributeName = Standaard halen we de secondary barcode (Tweede barcode) niet binnen met de koppeling, omdat er geen standaardveld voor is binnen Magento. In Magento kan het zijn dat dit veld wel is aangemaakt als [customField]. Door de naam van dit veld in te vullen kunnen we deze gegevens wel importeren. Vul de (veld)naam van het attribuut in. SupplierCodeAttributeName = Standaard halen we de supplier code (Leverancierscode) niet binnen met de koppeling, omdat er geen standaardveld voor is binnen Magento. In Magento kan het zijn dat dit veld wel is aangemaakt als [customField]. Door de naam van dit veld in te vullen kunnen we deze gegevens wel importeren. Vul de (veld)naam van het attribuut in. SupplierProductCodeAttributeName = Standaard halen we de Supplier Product Code (Artikelnummer van leverancier) niet binnen met de koppeling, omdat er geen standaardveld voor is binnen Magento. In Magento kan het zijn dat dit veld wel is aangemaakt als [customField]. Door de naam van dit veld in te vullen kunnen we deze gegevens wel importeren. Vul de (veld)naam van het attribuut in. DoNotImportDisabledProducts = Standaard halen we alle productinformatie in de webshop binnen. Wanneer deze instelling wordt aangezet zullen de Disabled producten niet worden meegenomen in de import. DoNotImportConfigurableProducts = Standaard halen we alle productinformatie beschikbaar in de webshop binnen. Wanneer deze instelling wordt aangezet zullen de configurable producten niet worden meegenomen in de import. Meer informatie over configurable producten Een configureerbaar product ziet er uit als een enkel product met vervolgkeuzelijsten met opties voor elke variatie. Elke optie is eigenlijk een afzonderlijk eenvoudig product met een unieke SKU, waardoor het mogelijk is om de voorraad voor elke productvariant bij te houden. U zou een soortgelijk effect kunnen bereiken door een eenvoudig product te gebruiken met aangepaste opties, maar zonder de mogelijkheid om de voorraad voor elke variatie bij te houden. PurchasePriceAttributeName = Standaard halen we de Purchase Price (inkoopprijs) niet binnen met de koppeling, omdat er geen standaardveld voor is binnen Magento. In Magento kan het zijn dat dit veld wel is aangemaakt als [customField]. Door de naam van dit veld in te vullen kunnen we deze gegevens wel importeren. Vul de (veld)naam van het attribuut in. SellPriceAttributeName= Standaard halen we de Sell Price (verkoopprijs) niet binnen met de koppeling, omdat er geen standaardveld voor is binnen Magento. In Magento kan het zijn dat dit veld wel is aangemaakt als [customField]. Door de naam van dit veld in te vullen kunnen we deze gegevens wel importeren. Vul de (veld)naam van het attribuut in. Order import ImportVirtualOrders = Met deze instelling is het mogelijk om volledig virtuele orders te importeren. (Virtuele producten of digitale goederen vertegenwoordigen niet-tastbare items zoals lidmaatschappen, services, garantiesm abonnementen en digitale downloads van boeken, muziek, video's en andere producten.)_ ImportVirtualProducts = Onze koppeling haalt normaal gesproken de virtuele producten uit een order. Met deze instelling is het mogelijk om virtuele producten te importeren in de order. (Virtuele producten of digitale goederen vertegenwoordigen niet-tastbare items zoals lidmaatschappen, services, garanties of abonnementen en digitale downloads van boeken, muziek, video's of andere producten.)_ ImportInvoices = Deze instelling maakt het mogelijk om de invoice (factuurgegevens) mee te importeren. RequestedDeliveryDateFieldName = Standaard halen we de Requested Delivery Date(Gewenste afleverdatum) niet binnen met de koppeling, omdat er geen standaardveld voor is binnen Magento. In Magento kan het zijn dat dit veld wel is aangemaakt als [customField]. Door de naam van dit veld in te vullen kunnen we deze gegevens wel importeren. Vul de (veld)naam van het attribuut in. De gewenste afleverdatum is de datum waarop je wenst dat een order wordt afgeleverd. Monta bepaalt wanneer de order wordt verzonden om datum te behalen. ShippingDeadlineFieldName = Standaard halen we de Shipping Deadline (Uiterlijke verzenddatum) niet binnen met de koppeling, omdat er geen standaardveld voor is binnen Magento. In Magento kan het zijn dat dit veld wel is aangemaakt als [customField]. Door de naam van dit veld in te vullen kunnen we deze gegevens wel importeren. Vul de (veld)naam van het attribuut in. De Uiterlijke verzenddatum is de datum waarom je wenst dat een order wordt verzonden. De klant bepaalt de uiterlijke verzenddatum, anders wordt de order overdue. ShopUsesBundledProducts = Het is mogelijk om in Magento bundels aan te maken. Met deze instelling wordt het mogelijk om deze gegroepeerde producten tijdens het importeren op te splitsen in de onderliggende producten. (Het is ook mogelijk om de bundels aan te maken in de Montaportal) DropshipFilterFieldName= Het is mogelijk om in Magento bij de Order Line een veld te definiëren. Wanneer dit veld is gevuld met de tekst 'Dropshipment' dan zal deze orderline worden overgeslagen in de order import. (Staff Functie) FilterOnSyncExcludedProducts = In Magento kan er op product Niveau een veld worden aangemaakt genaamd [sync excluded]. Deze kan True, False of NULL zijn. Door deze instelling aan te zetten wordt het mogelijk om op Order line-niveau hierop te filteren. Als de waarde [sync excluded] op True staat zullen we deze order line niet importeren. Wanneer het veld op False / NULL staat zullen we de line wel importeren. LETOP: INVULLEN IN PLATFORMSETTINGS, EN NIET BIJ ORDER IMPORT SETTINGS SurprisePackFieldName = Een optie om een surprisepack optie uit de extenstion attributes van een Magento orderregel te halen. Hier in moet de key/naam van de extension attribute waar de suprisepack option in zit, ingevuld worden. Meer informatie over Sync exclude producten De klant moet op orderregel niveau een nieuwe attribuut aanmaken. Dit attribuut kunnen we uitlezen in de koppeling. Vervolgens krijg je de volgende attributen mee in de order: ![image.png](../../../../Attachments/image-36513078-2001-4e7b-9fb0-db5c023cf4a1.png) (Staff Functie) DoNotUseParentLineAsLineItem Standaard importeren we de parent lines; maar je kan child lines met bijvoorbeeld kleurnummers hebben. Deze child lines kunnen we dan ook importeren. ReferenceFieldName = Het is mogelijk om in Magento bij de Order custom velden te definiëren. Voor het doel om een reference bij de order te importeren kan de veldnaam die hiervoor gebruikt wordt in Magento in deze instelling ingevuld worden OriginFieldName = Het is mogelijk om in Magento bij de Order Line custom velden te definiëren. Vul de naam van het attribuut in om de waarde van dit veld op te halen. Als de order een waarde heeft die overeenkomt met de naam van het attribuut, wordt deze waarde ingevuld als origin van de order. InvoiceDebtorNumberFieldName = Het is mogelijk om in Magento bij de Order Line custom velden te definiëren. Vul de naam van het attribuut in om de waarde van dit veld op te halen. Als de order een waarde heeft die overeenkomt met de naam van het attribuut, wordt deze waarde ingevuld als invoicedebtornumber van de order. Wijzigingen en annuleringen binnenhalen: = Bij deze koppeling is het mogelijk om wijzigen en annuleringen binnen te halen. Dit is in te stellen in de Type settings van de koppeling. Verzendopties importeren De verzendmethode van de order wordt uitgelezen en kan gemapt worden aan een verzender met evt opties. PostNL plugin Als er Magento PostNL plugin gebruikt wordt om verzendopties te kiezen, worden deze ook geïmporteerd. Monta checkout plugin Als de Monta checkout plugin gebruikt wordt om verzendopties te kiezen, worden deze ook geïmporteerd. Order update De orderupdate van Magento meld alle colli en bijbehorende TT info terug naar Magento in de \"tracks\". CustomerNotified = Wanneer deze instelling aanstaat zal Monta een trigger geven aan Magento om de klant een mail te sturen. Deze mail moet geconfigureerd zijn in Magento. DisableNotesWithTrackAndTrace = Standaard plaatst Monta de Track&Trace van de vervoerder in het notitieveld van Magento. Als deze instelling aan staat dan zetten we de Track&Trace niet meer in de notities. AddTrackAndTraceLink = Standaard stuurt Monta alleen de [Track&Trace Code]. Als je deze instelling aanzet, dan sturen we in het veld [Tracknumber] de [Track&Trace Code] en de [Track&Trace Link]. AddTrackAndTraceLinkWithoutCode = Standaard stuurt Monta alleen de [Track&Trace Code]. Als je deze instelling aanzet, dan sturen we In het veld [Tracknumber] alleen de [Track&Trace Link]. Stock update DontUpdateStockToNotInStock = In Magento heb je een vinkje genaamd [Stock to not in stock]. Als je deze aan zet geef je aan dat het product niet op voorraad is. Door deze instelling aan te zetten zorg je ervoor dat Monta geen stock update doet bij de producten waarvan [Stock to not in stock] op True staat. (Staff Functie) MissiOn = Als deze instelling aanstaat in Magento doet zowel Monta als Magento voorraadreserveringen voor orders. Hierdoor wordt er dus 2 keer afgeboekt. Door deze instelling aan te zetten doen wij geen reservering meer. Koppeling maken Om de koppeling te maken moeten er contact zijn met een Medewerker van Monta. We zullen daarbij vragen naar een aantal gegevens die we nodig hebben om een koppeling te maken. Ga naar koppeling maken om de benodigde gegevens te bekijken. Bijzonderheden Deelleveringen: Als een (Monta®)-order volledig is verstuurd koppelen we naar het platform terug dat de gehele order is verzenden. De koppeling kijkt hierbij niet naar het aantal of de Lines die zijn verzonden. Dit doen we op deze manier omdat er vaak verzendkosten e.d. uit de order wordt verwijderd. Door de order dan volledig op verzonden te zetten, zonder te controleren op de Lines, blijven deze orders niet open staan op het platform. Wanneer er echter een gesplitste order is in Monta® kijken we bij de eerst verstuurde orders wel naar de order Lines. Dit om verwarring op de platformen te voorkomen. Dit resulteert in de volgende situaties: Order volledig verstuurd = Order volledig verzonden gezet op platform, zonder controle op Lines. Order gesplitst, 1 vd 2 verstuurd = Orderregels worden op verzonden gezet op platform, overige regels blijven open staan. Order gesplitst, 2 vd 2 orders verstuurd = Order volledig verzonden gezet op platform, zonder controle op Lines. Orderlines aangepast op origine order = Order volledig verzonden gezet op platform, zonder controle op Lines. [[ Doelgroep: IT Uitzondering: Het is eventueel ook mogelijk om hardcoded in de koppeling een relatieID toe te voegen. Dit zorgt ervoor dat monta wel de deelleveringen per line terugstuurd. In de toekomst zal dit een instelling worden in de koppeling. ]]"
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/MijnWebWinkel/Koppeling-maken-MijnWebWinkel/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/MijnWebWinkel/Koppeling-maken-MijnWebWinkel/index.html",
    "title": "Koppeling maken MijnWebWinkel",
    "keywords": "Koppeling maken MijnWebWinkel Vraag aan de klant de Merchant token. Monta is geen erkende verzendpartner, de klant moet dus een algemene token genereren. 1) Platform settings Maak de platform Settings aan in de tblRelatieSystemConnectionPlatformMyOnlineStoreSettings en onthoud de ID / MyOnlineStorePlatformSettingsID 2) Relatie System Connections Maak de relatiesystemconnections (inactief) aan in tblRelatieSystemConnections. Dit zijn de dataflows die ondersteund worden: | ID | DESCRIPTION| |--|--| |29|Product Information Import - MyOnlineStore (Mijnwebwinkel) | |31|Order Import - MyOnlineStore (Mijnwebwinkel) | |33|Order Update - MyOnlineStore (Mijnwebwinkel) | |132|Product Match - MyOnlineStore (Mijnwebwinkel) | |133|Full Stock Update - MyOnlineStore (Mijnwebwinkel) | |134|Changed Stock Update - MyOnlineStore (Mijnwebwinkel) | |146|Changed Product Match - MyOnlineStore (Mijnwebwinkel) | en noteer van de nieuwe regels die je hebt aangemaakt het ID. Dit is nu het RelatieSystemConnection ID (RSCID). ###3) RSC Type settings Maak de type settings aan voor elke dataflow die je wilt gebruiken. Ga hiervoor naar de tabellen: Product Match: tblRelatieSystemConnectionTypeMyOnlineStoreSettings en tblRelatieSystemConnectionTypeProductMatchMyOnlineStoreSettings Product Information Import:tblRelatieSystemConnectionTypeProductInformationImportMyOnlineStoreSettings Order Import:tblRelatieSystemConnectionTypeMyOnlineStoreSettings Order update:tblRelatieSystemConnectionTypeMyOnlineStoreSettings Full Stock Update: tblRelatieSystemConnectionTypeStockUpdateMyOnlineStoreSettings Changed Stock Update: tblRelatieSystemConnectionTypeStockUpdateMyOnlineStoreSettings Changed Product Match:tblRelatieSystemConnectionTypeMyOnlineStoreSettings ###4) Dataflow settings Maak de dataflow settings aan voor elke dataflow die je wilt gebruiken. Vergeet hier de tblRelatieSystemConnectionDataFlowOrderUpdateStatussesOnly niet. ###5) Maak een backgroundjob aan Dit kan met de volgende query: insert into tblBackgroundJob(SecondaryId, JobId, JobGuid, BackgroundJobTypeId, CustomerId, Created, MachineName) values('MyOnlineStore',{PK van tblRelatieSystemConnectionPlatformMyOnlineStoreSettings}, NEWID(), 1, {Relatie-id van de klant}, GETDATE(), 'MP-WEB08')"
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/MijnWebWinkel/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/MijnWebWinkel/index.html",
    "title": "MijnWebWinkel",
    "keywords": "MijnWebWinkel Dataflows ID DESCRIPTION 29 Product Information Import - MyOnlineStore (Mijnwebwinkel) 31 Order Import - MyOnlineStore (Mijnwebwinkel) 33 Order Update - MyOnlineStore (Mijnwebwinkel) 132 Product Match - MyOnlineStore (Mijnwebwinkel) 133 Full Stock Update - MyOnlineStore (Mijnwebwinkel) 134 Changed Stock Update - MyOnlineStore (Mijnwebwinkel) 146 Changed Product Match - MyOnlineStore (Mijnwebwinkel) Deze koppeling beschikt over dataflow instellingen. Meer informatie hierover is te vinden via Dataflow instellingen Koppeling maken Om de koppeling te maken moeten er een aantal stappen worden doorlopen. Meer informatie hierover is te vinden op: Koppeling maken MijnWebWinkel"
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/Mirakl/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/Mirakl/index.html",
    "title": "Mirakl",
    "keywords": "Mirakl Mirakl Mirakl is een Frans cloudgebaseerd e-commercesoftwarebedrijf met een gezamenlijk hoofdkantoor in Parijs, Frankrijk en Somerville, Massachusetts. Het levert online marktplaatssoftware aan retailers, fabrikanten en groothandels. Monta heeft een koppeling met Mirakl voor de volgende platformen Fonq Brico Privé Eprice Fnac Blokker Decathlon De api key kan op de volgende wijze verkregen worden: Orderwijzigingen: Met de instelling UpdateWhenAlreadyExistsAndPlatformSupportsIt kunnen we orderwijzigingen en annuleringen importeren."
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/Plug&Pay/Koppeling-maken/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/Plug&Pay/Koppeling-maken/index.html",
    "title": "Koppeling maken",
    "keywords": "Koppeling maken Benodigde gegevens Description BaseUrl: https://api.plugandpay.nl/v2/ RelatieId ApiKey Hierna dient er nog een orderimport dataflow toegevoegd te worden: tblRelatieSystemConnectionTypes Zoek hier het ID op van de orderimport dataflow van Plug&Pay De relatieconnection gaan we dan aanmaken via: tblRelatieSystemConnections Hier maken we een nieuwe entry en geven we het RelatieID en TypeID in en zetten we de kolom Disabled op True. tblRelatieSystemConnectionTypeOrderImportPlugAndPaySettings Maak ten slotte de dataflow instellingen aan in tblRelatieSystemConnectionDataFlowOrderImportSettings en vergeet het DefaultEsettingsID niet in te vullen."
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/Plug&Pay/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/Plug&Pay/index.html",
    "title": "Plug&Pay",
    "keywords": "Plug&Pay Dataflows: Order Import (Letop, Deze koppeling heeft enkel de order import) Deze koppeling beschikt over dataflow instellingen. Meer informatie hierover is te vinden via Dataflow instellingen Orderwijzigingen: Met de instelling UpdateWhenAlreadyExistsAndPlatformSupportsIt kunnen we orderwijzigingen en annuleringen importeren. Bijzonderheden Aanmaken api gegevens Er is een update gedaan in de Plug&Pay en de klant kan nu zelf de gegevens aanvragen. Dat kan je doen via de instellingen > integraties > ontwikkelaars. Het is daar mogelijk een API sleutel toe te voegen."
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/Prestashop/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/Prestashop/index.html",
    "title": "Prestashop",
    "keywords": "Prestashop Dataflows Order Import Product Match (Incl. Product import) Changed Stock Updates Order Update Full Stock Update Changed Product Match (Letop: Dit onderdeel wordt niet standaard toegevoegd aan de koppeling) Deze koppeling beschikt over dataflow instellingen. Meer informatie hierover is te vinden via Dataflow instellingen Instellingen Order Import Wijzigingen en annuleringen binnenhalen: Bij deze koppeling is het mogelijk om wijzigen en annuleringen binnen te halen. Dit is in te stellen in de dataflow settings van de koppeling. Order Import Order retrieve StateIDS: Met deze instelling is het mogelijk orders te importeren met andere orderstatussen naast de default. Instelling is te vinden in de Type settings."
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/Shopify/Achteraf-betalen-configureren/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/Shopify/Achteraf-betalen-configureren/index.html",
    "title": "Achteraf betalen configureren",
    "keywords": "Achteraf betalen configureren Korte instructies: Configureer in Shopify dat bij het fulfillen van een order het order automatisch ge'capture'ed wordt. Let op: als stap 2 gedaan is zonder eerst stap 1 voltooid te hebben, dan worden de orders fulfilled, zonder dat de klant kan betalen. De 'achteraf betalen partij' weet dan niet dat ze dan bij de consument het bedrag moeten gaan claimen. Zet 'tblRelatieSystemConnectionTypeOrderImportShopifySettings.ImportOrdersWithFinancialStatusAuthorized' op true. Volledige instructies: Monta kan orders importeren die achteraf door de consument betaald worden. Een derde partij neemt dan de betaling op zich (AfterPay, Klarna, etc.). Dit zijn orders met de 'financial_status' authorized. Let op: orders die via PayPall of een creditcard betaald worden hebben ook deze status. Om die er uit te filteren haalt Monta enkel orders op waarbij het 'gateway' veld (deels) overeenkomt met één van de volgende termen: SprayPay, IN3, Billink, Klarna, Riverty, AfterPay, Credit Click. Zodra een order met deze status verzonden is, moet de desbetreffende derde partij hier van op de hoogte gesteld worden. Dit wordt gedaan door de order te 'capture'-en. Het 'capturen'-en van een order moet door Shopify gedaan worden zodra Monta het order fulfilled. Hier wordt uitgelegd hoe dit in Shopify geconfigureerd kan worden. Dit proces bestaat uit 2 stappen: Zet de payment capture settings in Shopify op MANUAL (Settings > Payments > Payment capture (Manage) > Manually > Save Workflow aanmaken (afhankelijk van de wensen) Bijvoorbeeld: If Fulfillment created / order fulfilled > then Capture Payment Voor een uitgebreide documentatie van deze functie kan de officiële help van Shopify geraadpleegd worden: https://help.shopify.com/en/manual/shopify-flow/reference/actions/capture-payment Om deze orders in Monta te importeren moet bij de RelatieSystemsConnector de volgende setting op true gezet worden: tblRelatieSystemConnectionTypeOrderImportShopifySettings.ImportOrdersWithFinancialStatusAuthorized"
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/Shopify/Koppeling-maken-Shopify/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/Shopify/Koppeling-maken-Shopify/index.html",
    "title": "Koppeling maken Shopify",
    "keywords": "Koppeling maken Shopify Om de koppeling met Shopify te maken moeten er een aantal stappen worden doorlopen. Locatie aanmaken in Shopify: Om alles goed te laten verlopen is het van belang dat je in de Shopify omgeving een nieuwe locatie aanmaakt. Deze locatie moet Monta heten. De producten die hier komen te liggen moeten worden toegewezen aan de Monta locatie. [[Hier een link van de informatiepagina van shopify(https://help.shopify.com/nl/manual/locations/assigning-inventory-to-locations) Ieder product SKU, Barcode en omschrijving: Om de producten te importeren in de Montaportal is het van belang dat alle producten, in de Shopify omgeving, een SKU, omschrijving en barcode hebben. De SKU moet uniek zijn voor ieder product. De barcode moet de code zijn die fysiek op het product staat. Zou jij dit kunnen aanvullen in het Shopify account en mij een terugkoppeling kunnen geven wanneer dit gelukt is? Koppeling Shopify Hierna kun je in je eigen Shopify omgeving de Monta connector app installeren. Door deze app te installeren kun je gemakkelijk en snel de koppeling met ons maken. Deze app zal je doorsturen naar het Montaportal. Hier zal hij vragen welke onderdelen je gebruik van wilt maken. Laat daarbij alle vinkjes aan staan. Nadat je de koppeling hebt gemaakt kun je contact opnemen met ons om deze koppeling te activeren. Koppeling handmatig maken via Postman Om de koppeling te maken heb ik een aantal api Keys nodig. Meer informatie over het aanmaken van api keys is te vinden via deze link: Generate private API credentials (Vanaf stap 4) Om de koppeling te kunnen maken heb je de volgende gegevens nodig van de klant: • Voorbeeld url • Consumer key • Consumer secret Tijdens het aanmaken van de api kun je ons bepaalde rechten toekennen. Wij hebben lezen en schrijven rechten nodig voor alles wat te maken heeft met voorraad; producten; fulfilment en orders. Rechten: read_fulfillments, write_fulfillments, read_products, write_products, read_product_listings, read_orders, write_orders, read_all_orders, read_locations, read_inventory, write_inventory"
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/Shopify/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/Shopify/index.html",
    "title": "Shopify",
    "keywords": "Shopify Dataflows Full stock update Order status shipped Stock updates Import orders Product match (Incl. Product informatie import) Webhooks Voor de orders en producten worden bij het aanmaken van nieuwe koppelingen nu ook webhooks aangemaakt bij Spotify. Dit gaat om de order create/update/cancel en product create/update webhooks. [[Doelgroep: IT Speciale onderdelen Speciale onderdelen zijn onderdelen van een koppeling die wel bestaan, maar die niet actief worden aangeboden. Dit is vaak omdat dit óf instabiele koppelingsonderdelen zijn; óf omdat hier data over heen gaat die extra aandacht nodig heeft. Mocht er interesse zijn in een speciaal onderdeel, neem dan contact op met Monta IT. Create refunds in Shopify Instellingen Er zijn een aantal instellingen die we kunnen doen bij een Shopify koppeling. Product match Enable/disable Product Information Import= Met deze setting zet je de Product informatie import aan of uit. Automatically enable/disable stock update for new linked products= Wanneer de productmatch een nieuwe link maakt (meer uitleg) dan staat de stockupdate standaard niet aan. Dit omdat we willen voorkomen dat we voorraadstanden van \"0\" gaan sturen richting de shop. Met deze instelling kan je instellen dat de stockupdate wel standaard aan wordt gezet bij een nieuwe link. Je geeft dus eigenlijk aan dat we bij alle nieuwe producten standaard de stockupdate aanzetten. ImportExtraProductInfo= Hiermee kunnen extra attributen worden ingeladen, zoals de HS code en Land van herkomst. Order import Shippers Mappen = Het is bij shopify mogelijk om verzenders aan te maken in de checkout. Deze verzenders hebben dan hun eigen shippercode. Deze code kunnen we vervolgens mappen naar een vervoerder van Monta. Op die manier kan de consument de gewenste vervoerder selecteren. Deny orders with unknown shipper codes = In het verlengde van ShippersMappen is het ook mogelijk om alle orders waarbij de shippercode niet bekend is bij monta te negeren. De orders met een onbekende shippercode zullen dan niet worden geïmporteerd. OrderUpdate Notify Customer= Als je deze instelling aanzet dan geeft monta Shopify de trigger om een mail te sturen naar de consument. UpdateReturnTTcode= Als je deze instelling aanzet dan stuurt monta de Retour TT die is gegenereerd bij de outbound (aparte instelling) mee richting shopify. Orderwijzigingen: Met de instelling UpdateWhenAlreadyExistsAndPlatformSupportsIt kunnen we orderwijzigingen en annuleringen importeren. Speciale instellingen Order Import [tblRelatieSystemConnectionTypeOrderImportShopifyIgnoreTags]= Het is in Shopify mogelijk om bepaalde tags toe te voegen aan een Order. Met deze instelling is het mogelijk om bepaalde tags, ingesteld in Shopify, te negeren bij de orderimport. [HasPostNLPlugin]: Als de klant een PostNL plugin gebruikt kan je deze instelling aanzetten. Dan kunnen we vervolgens de shippercodes gebruiken bij het importeren van de order. [OnlyOrdersWithShippingMethodFilter] = Alle orders waarbij een shipper meekomt die niet in de dataflow settis is gemapt worden niet meegenomen. [ExtraFulfillmentStatus]= Hier kan je andere orderstatussen instellen; waardoor je meerdere order statussen kan importeren. Dit is een komma gescheiden lijst. Mogelijke waardes zijn: shipped = 1, partial = 2, unshipped = 3, any = 4, unfulfilled = 5 [OverrideOrderNumberWithColumnName]= Je kan een custom veld aanmaken in shopify. Dit veld kan je vervolgens mappen naar het order nummer in monta. Dus wanneer aan overschrijven we het standaard ordernummer(veld) met de test in deze custom kolom. [OverrideClientNumberWithColumnName]= Voor het order invoice debtor nummer kan je een custom veld aanmaken. [OverrideOrderNumberWithNameString]= Als je deze instelling aanzet dan krijg je de gehele orderID uit shopify inclusief alle prefix instellingen. [GiftWrappingCode]= Hiermee kan je aangeven dat je een suprisepack instelling wilt gebruiken. [GiftWrappingNoteName]=' Hierin kan je de tekst plaatsen die we gebruiken bij de instelling 'Suprise pack'. Daarmee kan je bijvoorbeeld deze tekst op een verzendlabel laten afdrukken. Deze instelling gaat altijd in combinatie met [GiftWrappingCode]. [UseCheckLocation]= Als je deze instelling aanzet kijken we bij de Order import naar de locatie die door shopify is geselecteerd. Standaard importeren we gewoon alle orders, ongeacht of er door shopify is gekozen dat de order op locatie monta staat. Situaties bij deze instelling: - Orderlines volledig op locatie Monta: Order wordt geïmporteerd. - Orderlines volledig op locatie \"klant\": Order wordt niet geïmporteerd. - Orderlines gedeeltelijk op locatie Monta en Klant: Order wordt volledig geïmporteerd. Als deze instelling niet aan staat halen wij altijd de order op. [ImportPOSOrders] = Shopify heeft een POS (kassa)systeem. Als je deze instelling aanzet dan importeren we deze orders ook richting de Montaportal. Full Stockupdate / Changed Stockupdate: Includes stock in transit = Standaard updaten we de voorraadstand inclusief de voorraad in transit. Het is mogelijk om deze voorraad niet mee te sturen in de stockupdate. (Stock in transit: Voorraad die al wel is ingeboekt, maar nog niet op locatie gelegd). Stock from warehouses = In sommige gevallen is het mogelijk dat voorraad verdeeld is over verschillende magazijnen. Standaard sturen we de voorraadstand van alle magazijnen. Het is echter mogelijk om de voorraad van een specifiek magazijn te sturen. Dan moet deze instelling worden aangepast. Stock for origin = Het is mogelijk om voorraad de alloceren (reserveren) voor een bepaald origin (kanaal). Met de instelling Stock for originzal alleen de voorraad van een bepaalde origin worden teruggekoppeld naar de site. Koppeling maken Om de koppeling te maken moeten er een aantal stappen worden doorlopen. Meer informatie hierover is te vinden op: Koppeling maken Shopify Bijzonderheden Wijzigingen en annuleringen binnenhalen Bij deze koppeling is het mogelijk om wijzigen en annuleringen binnen te halen. Dit is in te stellen in de Type settings van de koppeling. Tags Je kunt in Shopify tags meegeven aan een order. Hiermee kun een waarde meegeven die gemapt kan worden met een origin in de Montaportal. De mapping hiervoor moet je instellen in de tabel tblRelatieSystemConnectionDataFlowOrderImportSettingsOrigins. Je kunt ook andere waarden meegeven in die tags, maar daar doen wij niks mee. Let op twee zaken bij de tags: Wanneer je meerdere waardes invoert, die mappen met meerdere origins aan onze kant, weten wij niet naar welke origin we moeten mappen. We blokkeren dan de order met reden dat er meerdere origins zijn aangegeven in de tags. Gebruik in je waardes geen spaties of komma's, daar splitten wij namelijk de waardes op. Fraudepreventie Shopify heeft een ingebouwde fraude analyse. Zie https://help.shopify.com/en/manual/orders/fraud-analysis#fraud-recommendations. Als deze fraude analyse risico's vind, waarbij de aanbeveling is om de order te annuleren of te onderzoeken, dan wordt de order in Montaportal geblokkeerd met de reden: \"Shopify recommendation\". Voorraadkoppeling Shopify houd zelf 'gereserveerde voorraad' bij voor orders, maar dit wordt overschreven door de Monta voorraad koppeling. Dit werkt als volgt: een nieuwe order is geplaatst in Shopify, de beschikbare voorraad in Shopify wordt lager de order wordt geïmporteerd in Monta en afgeboekt van de voorraad, omdat order een voorraadreservering krijgt of wordt klaargezet om te picken de voorraadkoppeling stuurt de nieuwe voorraadstand naar Shopify, maar dit levert geen wijziging op omdat de voorraad in Shopify ook al niet meer beschikbaar was. Let op dat dit mis kan gaan bij het cancellen van orders. Standaard staat hierbij een vinkje ingeschakeld dat de voorraad weer opgeboekt moet worden. Dit vinkje moet de gebruiker dus uit schakelen. Anders wordt er voorraad opgeboekt die er niet is, want het was door de voorraadkoppeling van Monta al afgeboekt. Zie https://help.shopify.com/en/manual/orders/cancel-delete-order#cancel-an-order. Bundels Naast de standaard bundelfunctionaliteiten van Shopify en Monta kan de klant ook zelf in shopify de programmatuur bouwen om bundels te maken. Als deze bundels via het format van Monta wordt aangeleverd kunnen we deze uitlezen. In de properties van een order moeten de SKUs die in de bundels zitten worden meegestuurd, via het volgende format:"
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/Shopware/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/Shopware/index.html",
    "title": "Shopware",
    "keywords": "Shopware Dataflows Order Import Order Update Full Stock Update Changed Stock Update Product Match (Incl. Product import) Changed Product Match (Letop: Dit onderdeel wordt niet standaard toegevoegd aan de koppeling) Deze koppeling beschikt over dataflow instellingen. Meer informatie hierover is te vinden via Dataflow instellingen Route van de Order: Monta haalt alle orders binnen met de betaal-status Paid en Authorized en order-status Open. Zodra monta de order heeft geimporteerd zullen we de status wijzigen naar Inprogress. De orders zullen worden verstuurd voor Monta. In de orderupdate van Shopware zetten we de \"delivery status\" op \"shipped\". Daarnaast zetten we de order-status op \"completed\". Dit laatste is ook uit zetten door deze instelling op false te zetten. Instellingen SetOrderToCompleted = Standaard zetten we de order-status op \"completed\". Dit is ook uit zetten door deze instelling op false te zetten. Installatie: Navigeer in je Shopware admin omgeving naar Instellingen > Integraties > Kies voor \"integratie aanmaken\" Vul een herkenbare naam in en selecteer bij rollen \"content\" (let op: laat het vinkje \"beheerder\" uit staan!) Koppieer de gegenereerde toegangs-id en veiligheidssleutel en gebruik deze voor de installatie op de Montaportal."
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/Template/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/Template/index.html",
    "title": "Template",
    "keywords": "Template Koppeling algemeen Standaard onderdelen Bij Monta hebben we standaard koppelingen die voor al onze klanten werken. Op deze manier kunnen we de bedrijfszekerheid van de koppelingen garanderen. De koppeling van bevat de volgende onderdelen: KOPPELINGSONDERDELEN TOEVOEGEN Deze onderdelen noemen we dataflows en zijn afhankelijk van elkaar in te stellen en te activeren. Meer informatie van deze dataflows kun je hier vinden Speciale onderdelen: Speciale onderdelen zijn onderdelen van een koppeling die wel bestaan, maar die actief worden aangeboden. Dit is vaak omdat dit óf instabiele koppelingsonderdelen zijn; óf omdat hier data over heen gaat die extra aandacht nodig heeft. Mocht er interesse zijn in een speciaal onderdeel, neem dan contact op met Monta IT. SPECIALE KOPPELINGSONDERDELEN TOEVOEGEN Koppeling maken Om de koppeling te maken moet er contact zijn met een Medewerker van Monta. We zullen daarbij vragen naar een aantal gegevens die we nodig hebben om een koppeling te maken. Ga naar LINK NAAR KOPPELING MAKEN PAGINA om de benodigde gegevens te bekijken. Instellingen In de koppeling kan je verschillende instellingen maken. LINK NAAR INSTELLINGPAGINA Naast deze koppeling specifieke settings zijn er ook een aantal dataflow setting's (Dit zijn settings die voor alle koppelingen gelden) Dataflow instellingen Checkout Module Deze koppeling ondersteund onze universele checkout. Meer informatie over de module en configuratie kun je hier vinden: 'Link naar checkout pagina' FAQ Hieronder zijn staan onderwerpen waar vaak onduidelijkheid over is bij deze koppeling."
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/Webhooks/Json-voorbeelden/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/Webhooks/Json-voorbeelden/index.html",
    "title": "Json voorbeelden",
    "keywords": "Json voorbeelden Stock update [ { \"Sku\": \"\", \"Barcodes\": [ \"\", \"\" ], \"WebshopStock\": 0, \"WebshopStockForecasted\": 0, \"QuarantaineStock\": 0, \"FinancialStock\": null, \"Created\": \"2022-11-14T16:57:30.5269083+01:00\", \"ReservedStock\": 0, \"StockPicking\": null } ] ##Inbound update [ { \"Type \": \"Inbound\", \"Created \": \"0001-01-01T00:00:00\", \"InboundGroupReference \": null, \"InboundForecastGroupReference \": null, \"InboundForecastGroupComment \": null, \"InboundForecastGroupId \": null, \"InboundForecastGroupSupplierCode \": null, \"Sku \": null, \"Barcodes \": [], \"BatchName \": null, \"Quantity \": 0, \"Quarantaine \": false, \"InboundForecastComment \": null, \"InboundForecastReference \": null, \"ReturnedEorderWebshopOrderId \": null } ] ##Order update [ { \"QueueItemId \": 0, \"MontaEorderId \": 0, \"WebshopOrderId \": null, \"Reference \": null, \"Origin \": null, \"InternalWebshopOrderId \": null, \"ConsumerDetails \": null, \"Quarantaine \": false, \"Ordered \": null, \"Received \": \"0001-01-01T00:00:00 \", \"Backorder \": false, \"Blocked \": false, \"BlockedMessage \": null, \"UpdateCauseCode \": null, \"Shipped \": false, \"Deleted \": false, \"Queued \": false, \"Picking \": false, \"Returned \": false, \"StatusCode \": null, \"DeliveryStatusId \": null, \"DeliveryStatusDescription \": null, \"ShipperId \": null, \"ShipperCode \": null, \"PlatformShipperCode \": null, \"ShipperDescription \": null, \"TrackAndTraceCode \": null, \"TrackAndTraceLink \": null, \"PartialShipmentParentOrSelfWebshopOrderId \": null, \"PartialShipmentParentOrSelfInternalWebshopOrderId \": null, \"AllPartialShipmentsShipped \": false, \"CreationSystemId \": 0, \"ShippedDateTime \": null, \"EstimatedDeliveryFrom \": null, \"EstimatedDeliveryTo \": null, \"ShipperOptions \": [], \"Lines \": [], \"LinesDeleted \": [], \"LinesDeletedFromSplit \": [], \"Colli \": [], \"Events \": [], \"ImportedFromRelatieSystemConnectionId \": null, \"ParentOrderImportedFromRelatieSystemConnectionId \": null, \"ProductSerials \": [] } ] ##Stock mutation [ { \"Type \": 0, \"Sku \": null, \"Barcodes \": null, \"BatchName \": null, \"Quantity \": 0, \"Quarantaine \": false, \"Created \": \"0001-01-01T00:00:00 \", \"Description \": null, \"LogDescription \": null, \"MutationCode \": null, \"WebshopStock \": null } ] ##Return received [ { \"MontaReturnId \": 0, \"ForecastCode \": null, \"Created \": \"0001-01-01T00:00:00 \", \"ReturnedPartialShipmentParentOrSelfWebshopOrderId \": null, \"ReturnedOrderWebshopOrderId \": null, \"ReturnedOrderConsumerDetailsInvoiceDebtorNumber \": null, \"ReturnedOrderReference \": null, \"ReturnedOrderOrdered \": null, \"ReturnedOrderOrigin \": null, \"ReturnedOrderShipperCode \": null, \"MontaCauseId \": null, \"MontaCauseTypeCode \": null, \"MontaCauseDescription \": null, \"CustomerCauseCode \": null, \"CustomerCauseDescription \": null, \"Comment \": null, \"Lines \": [] } ]"
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/Webhooks/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/Webhooks/index.html",
    "title": "Webhooks",
    "keywords": "Webhooks Dataflows Order Update Order update [ { \"QueueItemId \": 0, \"MontaEorderId \": 0, \"WebshopOrderId \": null, \"Reference \": null, \"Origin \": null, \"InternalWebshopOrderId \": null, \"ConsumerDetails \": null, \"Quarantaine \": false, \"Ordered \": null, \"Received \": \"0001-01-01T00:00:00 \", \"Backorder \": false, \"Blocked \": false, \"BlockedMessage \": null, \"UpdateCauseCode \": null, \"Shipped \": false, \"Deleted \": false, \"Queued \": false, \"Picking \": false, \"Returned \": false, \"StatusCode \": null, \"DeliveryStatusId \": null, \"DeliveryStatusDescription \": null, \"ShipperId \": null, \"ShipperCode \": null, \"PlatformShipperCode \": null, \"ShipperDescription \": null, \"TrackAndTraceCode \": null, \"TrackAndTraceLink \": null, \"PartialShipmentParentOrSelfWebshopOrderId \": null, \"PartialShipmentParentOrSelfInternalWebshopOrderId \": null, \"AllPartialShipmentsShipped \": false, \"CreationSystemId \": 0, \"ShippedDateTime \": null, \"EstimatedDeliveryFrom \": null, \"EstimatedDeliveryTo \": null, \"ShipperOptions \": [], \"Lines \": [], \"LinesDeleted \": [], \"LinesDeletedFromSplit \": [], \"Colli \": [], \"Events \": [], \"ImportedFromRelatieSystemConnectionId \": null, \"ParentOrderImportedFromRelatieSystemConnectionId \": null, \"ProductSerials \": [] } ] Full Stock Update Return Received Update Return received [ { \"MontaReturnId \": 0, \"ForecastCode \": null, \"Created \": \"0001-01-01T00:00:00 \", \"ReturnedPartialShipmentParentOrSelfWebshopOrderId \": null, \"ReturnedOrderWebshopOrderId \": null, \"ReturnedOrderConsumerDetailsInvoiceDebtorNumber \": null, \"ReturnedOrderReference \": null, \"ReturnedOrderOrdered \": null, \"ReturnedOrderOrigin \": null, \"ReturnedOrderShipperCode \": null, \"MontaCauseId \": null, \"MontaCauseTypeCode \": null, \"MontaCauseDescription \": null, \"CustomerCauseCode \": null, \"CustomerCauseDescription \": null, \"Comment \": null, \"Lines \": [] } ] Changed Stock update Stock update [ { \"Sku\": \"\", \"Barcodes\": [ \"\", \"\" ], \"WebshopStock\": 0, \"WebshopStockForecasted\": 0, \"QuarantaineStock\": 0, \"FinancialStock\": null, \"Created\": \"2022-11-14T16:57:30.5269083+01:00\", \"ReservedStock\": 0, \"StockPicking\": null } ] Inbound Update Inbound update [ { \"Type \": \"Inbound\", \"Created \": \"0001-01-01T00:00:00\", \"InboundGroupReference \": null, \"InboundForecastGroupReference \": null, \"InboundForecastGroupComment \": null, \"InboundForecastGroupId \": null, \"InboundForecastGroupSupplierCode \": null, \"Sku \": null, \"Barcodes \": [], \"BatchName \": null, \"Quantity \": 0, \"Quarantaine \": false, \"InboundForecastComment \": null, \"InboundForecastReference \": null, \"ReturnedEorderWebshopOrderId \": null } ] Stock Mutations Update Stock mutation [ { \"Type \": 0, \"Sku \": null, \"Barcodes \": null, \"BatchName \": null, \"Quantity \": 0, \"Quarantaine \": false, \"Created \": \"0001-01-01T00:00:00 \", \"Description \": null, \"LogDescription \": null, \"MutationCode \": null, \"WebshopStock \": null } ] webhook_dataflows.txt ##Webhook koppelingen aanmaken 1. Zoek de IDs op van de koppeling die je wilt gaan maken --> Zoek in de database de benodigde type id's op via de volgende query: SELECT TOP (1000) [ID] ,[Description] ,[PlatformID] ,[DataFlowID] ,[ExecutionInterval] FROM [Monta_Backend].[dbo].[tblRelatieSystemConnectionTypes] where platformid = 11 ###2. Maak de connections in tblrelatiesystemconnections --> Vul het relatieid in --> Vul het connectiontypeid in --> Vul true in bij disabled --> Zoek het aangemaakte ID op ###3. Maak de dataflowsettings aan --> Zoek de juiste dataflowsettingstabel op en vul daar het in stap 2 aangemaakte id in met de gewenste instellingen. ###4. Maak de platformsettings aan (tblRelatieSystemConnectionPlatformWebhookSettings) --> Vul het relatiesystemconnectionid van stap 2 in --> Vul de door de klant aangeleverde URL inclusief eventuele accountgegevens in en vul dit aan met het relatieid Als het om een orderstatusupdate gaat kan je meerdere statussen instellen door in de tabel \"[tblRelatieSystemConnectionDataFlowOrderUpdateStatussesOnly]\" meerdere records aan te maken met verschillende planningcodes. De beschikbare planningcodes zijn te vinden in tblEorderPlanningCode"
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/Woocommerce/Woocommerce-ondersteunde-plugins/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/Woocommerce/Woocommerce-ondersteunde-plugins/index.html",
    "title": "Woocommerce ondersteunde plugins",
    "keywords": "Woocommerce ondersteunde plugins Plugins Op deze pagina zijn alle plugins bekend bij monta te zien. Deze plugins ondersteund monta voor bepaalde klanten. Letop: Het is geen garantie dat dit altijd zal werken! Paazl: Verzendmethodes importeren Octolize: Verzendmethodes importeren Als de klant de plugin Octolize gebruikt voor het aanmaken van verzendopties dan zal Monta ipv het verzend method_id de verzend method_title importeren. In deze titel staat namelijk de code die de klant heeft aangemaakt. Voorbeeld: Letop: Als de klant de verzendmethode aanpast dan moet de verzendmapping ook worden aangepast. https://octolize.com/product/flexible-shipping-pro-woocommerce/ Shipment-Tracking: Verzenddetails richting woocommerce: Als de klant Shipment-Tracking gebruikt om de verzendgegevens te verwerken in Woocommerce dan is hiervoor een instelling in de orderupdate. Zie order update instellingen. https://woocommerce.com/products/shipment-tracking/?quid=27c4439f820a675148f22b1339a33560"
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/Woocommerce/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/Woocommerce/index.html",
    "title": "Woocommerce",
    "keywords": "Woocommerce Dataflows Refund Create (Letop: Dit onderdeel wordt niet standaard toegevoegd aan de koppeling) Full Stock Update Changed Stock Update Order Import Order Update Product Information Import (Vervangen door de Product match) Product Match (Incl. Product informatie import, EAN mapping benodigd) Changed Product Match (Letop: Dit onderdeel wordt niet standaard toegevoegd aan de koppeling) Deze koppeling beschikt over dataflow instellingen. Meer informatie hierover is te vinden via Dataflow instellingen [[Doelgroep: IT Technische tekening Dataflows: Instellingen: Order Import: Check on Products without SKU: Met deze instelling aan zal import orderregels zonder SKU overslaan Check on virtual product: Normaal zal Monta altijd alle producten in de order importeren. Als Deze instelling aanstaat zal Monta tijdens het importeren van de orders controleren of een product is gemarkeerd als virtueel product. Als dat zo is dan zal Monta deze niet importeren. OrderImportStatuses: Standaard halen we bij woocommerce orders met de status processing op. Je kan per koppeling instellen via de kolom \"OrderImportStatuses\" in tabel \"TypeOrderImportWooCommerceSettings\" welke additionele statussen we binnen moeten halen. Mogelijke statussen: 0 = processing 1 = on-hold 2 = pending 3 = completed 4 = failed 5 = cancelled 6 = refunded DeliveryDateMetaKey= Standaard importeren we de gewenste leverdatum niet mee uit WooCommerce. Het is in Woocommerce mogelijk om een MetaKey aan te maken met deze datum erin. Door in deze instelling het veldnaam te plaatsen zullen we deze datum wel mee importeren met de order. IgnoreOrderLineWhenMetaKeyContains = In Woocommerce heb je de mogelijkheid om aan een product een metaKey te handen. Door de metaKey bij deze instelling in te voeren zal dit product in de order niet worden geïmporteerd. Shipper mapping: Het is bij Monta mogelijk om de verzendopties van woocommerce naar de juiste verder bij monta te mappen. Dit is iets dat door Monta-IT moet worden ingericht. Standaard importeert monta de method_id. Dit ID kan vervolgens naar de juiste vervoerder worden gemapt. Echter zit hier wel een uitzondering in. Wanneer de Method_ID: flexible_shipping_single of flate-rate bevat, dan zullen we de Method_Title uitlezen. Dit maakt het voor de klant mogelijk om meerdere verschillende Flat-Rate/ShippingRates te mappen. Order update HasShipmentTrackingPlugin: De notes zijn velden van de Woocommerce order. Standaard zet onze koppeling hier in de Track en Trace informatie. Wanneer de klant gebruik maakt van de shipment tracking plugin (zie 'ondersteunde plugins') heeft, dient deze instelling aangezet te worden zodat de tt-info in de plugin specifieke velden gezet kan worden. Product Match Barcode FieldName : Standaard is er in Woocommerce geen veld beschikbaar voor de Barcode. Daarom zal onze koppeling uit default de SKU van woocommerce importeren in de SKU en Barcode bij monta. Het is daarmee van belang dat de SKU gelijk is aan de Barcode van het artikel. Echter is er in Woocommerce wel de mogelijkheid om een extra veld aan te maken voor de Barcode. Door de naam van het veld in te voeren in deze instelling zullen we ipv de SKU te plaatsen, dit veld uitlezen en gebruiken als barcode. Barcode Atribuutnaam onbekend: Het is mogelijk om de attribuut naam op te zoeken via postman door een request te doen richting woocommerce. Dit kan je doen via het end-point: https://solow.nl/wp-json/wc/v3/products?consumer_key=[CustomerKey]8&consumer_secret=[customerSecret]. Vervolgens staat er in het atribuut \"meta_data\" de juiste naam. Bijzonderheden Plug-ins: In WooCommerce is het mogelijk om plug-ins te gebruiken. Gezien deze apps open source zijn kunnen deze plugins ervoor zorgen dat de koppeling van Monta niet meer naar behoren werkt. Een aantal van deze plugins zijn ondertussen bekend bij Monta. Via Plug-in informatie is te vinden welke plug-ins Monta ondersteund. Bedragen inclusief en Exclusief BTW: Wanneer een order geimporteerd word uit WooCommerce worden de prijzen altijd geimporteerd inclusief BTW. Het kan mogelijk zijn dat dit niet juist is volgens de klant. In het geval dat er met refunds gewerkt gaat worden is het van belang dat wij de prijzen op een juiste manier importeren. De klant zal er dan voor moeten kiezen om de prijzen op de volgende manier weer te geven zodat wij de prijzen met een juiste BTW importeren: https://woocommerce.com/document/setting-up-taxes-in-woocommerce/"
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/Zalando/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/Zalando/index.html",
    "title": "Zalando",
    "keywords": "Zalando Algemene toelichting Monta heeft geen directe koppeling met Zalando. Wel is het mogelijk om te koppelen met zalando via bepaalde andere platformen. Omdat zalando veeleisend is in de manier waarop de pakketten worden verstuurd is er wat additionele inrichting nodig, voordat er met zalando mag worden verstuurd. Het volgende is nodig: Pakbonnen in specifieke Zalando lay-out; In de taal van het betreffende land. Retour label in de doos. Het uitwisselen van de data (orders importeren, track&trace terugsturen etc.) kan door Zalando aan te sluiten op de webshop met bijv. Channable; Shopify; Magento en ChannelEngine. Bijzondere velden die we nodig hebben in de koppeling: ItemInvoicePrice / TotalRowInvoiceValue: Deze invoice data hebben we nodig op de pakbon. RetourTT: De retour Track& Trace moet worden teruggekoppeld bij de orderupdate na het verzenden. Data: Zalando vereist op de pakbon bepaalde data die Monta niet altijd standaard importeert. De manier waarop we deze data kunnen importeren kan verschillen per koppeling. Hieronder is een overzicht te vinden van de data die we nodig hebben voor zalando, en in welk veld bij Monta we deze data importeren. Klantennummer: Dit is het klantnummer van Zalando. Bestelnummer : Dit moet worden gevuld met het bestelnummer van Zalando. Artikelnummer = Dit moet worden gevuld met de productcode (artikelnummer) van Zalando. Data Channelengine Shopify Magento Its Perfect Zalando Klantennummer CustomerNumber CustomerNumber CustomerNumber CustomerNumber Zalando Bestelnummer WebshopOrderID Order Nr. Reference Reference Zalando Artikelnummer Orderline Reference (Note?) Supplier Product Code SupplierProductCode Supplier Porudct code Order Date OrderDate OrderDate OrderDate OrderDate Pakbon templates: Letop: De pakbonnen moeten aangepast worden naar de juiste data, zie hierboven. Pakbon_Zalando_AT.docx Pakbon_Zalando_BE_NL.docx Pakbon_Zalando_BE_FR.docx Pakbon_Zalando_DE.docx Pakbon_Zalando_NL.docx Zalando pakbonnen per land.zip"
  },
  "Algemene-informatie/Koppelingen/2.-Platformen/index.html": {
    "href": "Algemene-informatie/Koppelingen/2.-Platformen/index.html",
    "title": "2. Platformen",
    "keywords": "2. Platformen Bij Monta hebben we koppelingen met een groot aantal platformen. Hieronder is een overzicht te zien van alle Standaard koppelingen van monta. AFAS Amazon Bigcommerce Bol.com CCV shop Channable Exact Online FTP Lightspeed Magento2 MijnWebwinkel / MyOnlineStore Mirakl Plug & Pay Shopware Shopify PrestaShop Woocommerce Koppelingen nog niet beschikbaar in de documentatie: BP Brico Prive(Nog geen uitleg beschikbaar) ChannelEngine (Nog geen uitleg beschikbaar) Fonq (Nog geen uitleg beschikbaar) LeroyMerlin (Nog geen uitleg beschikbaar) RestAPI (Nog geen uitleg beschikbaar) Geen directe koppeling Met de volgende platformen hebben we geen directe koppeling, maar er zijn wel mogelijkheden om te koppelen. Magento 1 Zalando Er draaien bij Monta verschillende apparaten waar informatie over te vinden is. Testomgevingen Monta beschikt over een aantal testomgevingen die publiek te benaderen zijn: ChannelEngine exclusief Checkout https://monta-dev.channelengine.net/ Magento inclusief Checkout https://test-magento2.monta.nl Woocommerce inclusief Checkout http://test-woocommerce.monta.nl/"
  },
  "Algemene-informatie/Koppelingen/Installatie---Rest-API/index.html": {
    "href": "Algemene-informatie/Koppelingen/Installatie---Rest-API/index.html",
    "title": "Installatie Rest API",
    "keywords": "Installatie Rest API"
  },
  "Algemene-informatie/Koppelingen/Monta-RestAPI/1.-Shippers-and-shipper-options/index.html": {
    "href": "Algemene-informatie/Koppelingen/Monta-RestAPI/1.-Shippers-and-shipper-options/index.html",
    "title": "1. Shippers and shipper options",
    "keywords": "1. Shippers and shipper options Shippers and shipper options Below is an incomplete list of the shippers we support, with their code. Please note that a shipper has to be enabled for your account before you can use it. Code Description PAK PostNL pickup points PostNL PostNL delivery DPD DPD delivery DPDparcelstore DPD pickup points UPS UPS delivery SEL DHL parcel SELBuspakje DHL parcel mailbox delivery DHLservicepunt DHL pickup points (only in the Netherlands) BpackPickupPoint Bpost pickup points (only in Belgium) Cancelled An order which is already picking cannot be blocked or deleted anymore. Still shipping can be stopped by changing the shipper to Cancelled. The order will be shipped and returned. Below is an incomplete list of the shippers we support in our RMA-portals, with their code. Code Description PostNL PostNL Pakket return DPD DPD return DHLFYPakket DHL For You Pakket UPS UPS return SEL DHL Parcel return PostNlBuspakje PostNL Buspakje return DhlParcelPickup DHL pickup PostNLSmart PostNL paperless return DHLParcelConnect DHL Parcel Connect return Shipper option codes Some of the shippers above have options. These are used to enable certain features for a shipment or for specifying information for a shipment. PostNL Option code Required Description SignatureOnDelivery Optional, no value Add this code to require the receiver of the shipment to sign NoNeighbour Optional, no value Add this code to not allow PostNL to deliver at the neighbour EveningDelivery Optional, no value Add this code to enable delivery in the evening. Take care: not available everywhere. FoodNetwork Optional, no value Add this code to enable delivery via the PostNL foodnetwork. AgeCheckRequired Optional,string, format: “DD-MM\u0002YYYY” Add this code to enable the age verification on delivery. PAK (PostNL pickup point) Option code Required Description EarlyMorningPickup Optional, no value To enable early morning pickup for this shipment. Has to be supported by the pickup points. PickupPointCode Required for shipping to a pickup point in Belgium Code of the pickup point to ship to (“Downnetwork pickup location code”) PickupPointRetailID Required for shipping to a pickup point in Belgium Code of the pickup point partner (“Downnetwork partner ID”) DHLservicepunt Option code Required Description ServicePointCode Required, text The code of the DHL service point this order should be delivered to. DPDparcelstore Option code Required Description ParcelstoreID Required, text The code of the DPD parcel store this order should be delivered to. UPS Option code Required Description Express Optional, no value Normally we choose UPS service (standard/express) base on the country. With this option you can specify to always choose Express service. SEL (DHL parcel) Option code Required Description SignatureOnDelivery Optional, no value Add this code to require the receiver of the shipment to sign DHLservicepunt Option code Required Description ServicePointCode Required, text The code of the DHL pickup point this order should be delivered to BpackPickupPoints (Bpost Belgium) Option code Required Description PickupPointCode Required, text The code of the Bpost pickup point this order should be delivered to (PUGO Id) PickupPointType Optional, text The type of Bpost pickup point DHLDE Option code Required Description PackingStationCode PostNumber"
  },
  "Algemene-informatie/Koppelingen/Monta-RestAPI/2.-Health/index.html": {
    "href": "Algemene-informatie/Koppelingen/Monta-RestAPI/2.-Health/index.html",
    "title": "2. Health",
    "keywords": "2. Health Health Provides information about the status of the API. GET /rest/v5/health Field Description Description A description of the status LoggedIn If a valid login was provided Example `GET https://api.montapacking.nl/rest/v5/health HTTP/1.1 Host: api.montapacking.nl Authorization: Response HTTP/1.1 200 OK {\"Health\":{\"Description\":\"OK\",\"LoggedIn\":false}}"
  },
  "Algemene-informatie/Koppelingen/Monta-RestAPI/3.-Product/index.html": {
    "href": "Algemene-informatie/Koppelingen/Monta-RestAPI/3.-Product/index.html",
    "title": "3. Product",
    "keywords": "3. Product Product Field Validation Description Sku Text, required, unique The SKU of the product, a unique identifier to be chosen by the client Description Text, required Description of the product Barcodes Text array, required The barcodes of the product, only two are supported at the moment. Must be at least one when creating a new product. WeightGrammes Number, read only The weight of de product in grams LengthMm Number, read only The length (longest side) of the packaged product in millimeters WidthMm Number, read only The width of the packaged product in millimeters HeightMm Number, read only The height (shortest side) of the packaged product in millimeters Stock Stock, read only. Not returned when empty The different types of stock for a product, see Stock for more info. ImageUrl Text, post/put only Url of the location of the image to download SupplierCode Text, optional, unique Code of the Supplier. It has to be an existing Supplier. PurchasePrice Number, put only The price of purchase. SellingPrice Number, put only The selling price of the product. PurchasePriceHidden Number, put only The price of purchase. Not visible on MontaPortal Food Boolean, put only Property to set the item as a ‘food’ item. MinimumExpiryPeriodInbound Number, put only Minimum number of days between inbound and expiry date. (If the number of days between inbound and expiry date is below this minimum, the inbound can be rejected) MinimumExpiryPeriodOutbound Number, put only Minimum number of days between outbound order picking and expiry date. (If the number of days between outbound order picking and expiry date is below this minimum, the products will not be picked) Cool Boolean, optional, put only Products marked ‘cool’ shall be placed in cooling cells to keep it as fresh as possible. Note Text, optional The note field can be used as a extra description field for a product. It is also possible to use this field on your packing list. Maximum: 2056 carachters. PurchaseStepQty Number, optional, read only Indicates the quantity of the product that can be fitted in a single container/box/etc. RegisterSerialNumber Boolean, optional This option will enforce the registration of serial numbers in the outbound process for B2C orders. RegisterSerialNumberB2B Boolean, optional This option will enforce the registration of serial numbers in the outbound process for B2B orders. Stock Field Validation Description StockInboundForecasted Number, read only. Not returned when empty Stock that is in forecast but not yet received. StockQuarantaine Number, read only. Not returned when empty Stock returned from orders that has been damaged or became unsellable StockAll Number, read only. Not returned when empty All stock in warehouse excluding quarantaine StockBlocked Number, read only. Not returned when empty Stock on blocked locations StockInTransit Number, read only. Not returned when empty Stock that is received but not yet placed in warehouse StockReserved Number, read only. Not returned when empty Stock that has been reserved by order reservations StockInboundHistory Number, read only. Not returned when empty All stock that has been received ever, excluding stock received from returns StockAvailable Number, read only. Not returned when empty All stock on pickable locations. You may want to include StockInTransit here. StockSplitProduct Number, read only. Not returned when empty or parameter ‘includeSplitStock’ not set All stock in split products. This is the sum of all underlying split products(the child products) StockWholeSaler Number, read only. Not returned when empty All stock availeble at wholesaler(s) PerWarehouse List of objects Stock per warehouse. Only warehouses with stock are in the list. GET /rest/v5/product/{sku} To retrieve details of a product by sku. Provide SKU in query parameters if it contains a slash, e.g. /product/?sku=2334345 Example GET https://api.montapacking.nl/rest/v5/product/2334345 HTTP/1.1 Host: api.montapacking.nl Authorization: Response: HTTP/1.1 200 OK { \"Sku\":\"2334345\", \"Description\":\"Grote Beker\", \"Barcodes\":[\"AHKS81\"], \"WeightGrammes\":60, \"LengthMm\":50, \"WidthMm\":50, \"HeightMm\":15, \"SupplierCode\":null, “Food”:false, “Cool”:false, “Note”:”Test note”, “PurchaseStepQty”:12 } GET /rest/v5/product?barcode={barcode} To retrieve details of a product by barcode. Example GET https://api.montapacking.nl/rest/v5/product?barcode=AHKS81 HTTP/1.1 Host: api.montapacking.nl Authorization: Response: HTTP/1.1 200 OK { \"Sku\":\"2334345\", \"Description\":\"Grote Beker\", \"Barcodes\":[\"AHKS81\"], \"WeightGrammes\":60, \"LengthMm\":50, \"WidthMm\":50, \"HeightMm\":15, \"SupplierCode\":null, “Food”:false, “Cool”:false, “Note”:null, “PurchaseStepQty”:null } GET /rest/v5/products?page={number} To retrieve details of al products Provide page in query parameters to go to next page , e.g. /products?page=1 Example GET https://api.montapacking.nl/rest/v5/products HTTP/1.1 Host: api.montapacking.nl Authorization: Response: HTTP/1.1 200 OK { \"Products\":[ { \"Product\":{ \"Sku\":\"0000142\", \"Description\":\"BENNETT - Dirty Grey Stripe - S\", \"Barcodes\":[ \"3105031201611\" ], \"WeightGrammes\":null, \"LengthMm\":1, \"WidthMm\":1, \"HeightMm\":1, \"Stock\":{ \"StockInboundForecasted\":1, \"StockQuarantaine\":0, \"StockAll\":0, \"StockBlocked\":0, \"StockInTransit\":0, \"StockReserved\":0, \"StockAvailable\":0, \"StockWholeSaler\":0, \"Batches\": [ { “Reference”: “batch-01”, \"Quantity\": 1, \"BestBeforeDate\": \"2019-02-18T00:00:00\" }, { “Reference”: “batch-01”, \"Quantity\": 29, \"BestBeforeDate\": \"2019-02-19T00:00:00\" } ] }, \"SupplierCode\":null, \"PurchasePrice\":null, \"SellingPrice\":null, \"PurchasePriceHidden\":null, \"Food\":false, \"MinimumExpiryPeriodInbound\":null, \"MinimumExpiryPeriodOutbound\":null, \"Cool\":false, \"Note\":null, “PurchaseStepQty”:12 } } ] } GET /rest/v5/product/{sku}/stock To retrieve details of a product including stock. Provide SKU in query parameters if it contains a slash, e.g. /product/stock?sku=2334345 Optional: Use “?includeSplitStock=true” to add the ‘StockSplitProduct’ to your response Example `GET https://api.montapacking.nl/rest/v5/product/2334345/stock HTTP/1.1 Host: api.montapacking.nl Authorization: Response: HTTP/1.1 200 OK { \"Sku\":\"2334345\", \"Description\":\"Grote Beker\", \"Barcodes\":[\"AHKS81\"], \"WeightGrammes\":60, \"LengthMm\":50, \"WidthMm\":50, \"HeightMm\":15, \"SupplierCode\":null, \"Stock\":{ \"StockInboundForecasted\":0, \"StockQuarantaine\":0, \"StockAll\":6, \"StockBlocked\":0, \"StockInTransit\":4, \"StockReserved\":0, \"StockInboundHistory\":124, \"Batches\": [ { “Reference”: “batch-01”, \"Quantity\": 1, \"BestBeforeDate\": \"2019-02-18T00:00:00\" }, { “Reference”: “batch-02”, \"Quantity\": 29, \"BestBeforeDate\": \"2019-02-19T00:00:00\" } ] } } GET /rest/v5/product/updated_since/{updatedSince} To retrieve details of all products with changed stock since the provided DateTime. Max 7 days in the past. Optional: Use “?stock=1&stock=3” to determine which stock you want to see in the response. Below are the corresponding values listed with the type of stock. If none is provided, Stock will not be returned. Example GET https://api.montapacking.nl/rest/v5/product/updated_since/2016-04- 14T16:38:27?stock=2&stock=3&stock=7 HTTP/1.1 Host: api.montapacking.nl Authorization: Basic dGVzdDp0ZXN0= Response: HTTP/1.1 200 OK { \"Products\":[{ \"Product\":{ \"Sku\":\"2334345\", \"Description\":\"Grote Beker\", \"Barcodes\":[\"AHKS81\"], \"WeightGrammes\":60, \"LengthMm\":50, \"WidthMm\":50, \"HeightMm\":15, \"SupplierCode\":null, \"Stock\":{ \"StockQuarantaine\":0, \"StockAll\":5, \"StockInboundHistory\":124 } } }] }"
  },
  "Algemene-informatie/Koppelingen/Monta-RestAPI/index.html": {
    "href": "Algemene-informatie/Koppelingen/Monta-RestAPI/index.html",
    "title": "Monta RestAPI",
    "keywords": "Monta RestAPI Monta REST API Documentation for using Monta’s REST API Abstract With our REST API, our clients are enabled to submit to and retrieve information from our systems. This document describes the features and usage of this API. Connection Url: https://api.montapacking.nl/rest/v5/. Please note that HTTPS connection with TLS 1.2 is required. Authentication Authenticate with username and password using HTTP basic authentication. Username and password can be created in the Montaportal. This can be done through the following link: https://www.montaportal.nl/Connect/PlatformDetails?platform=RestAPI Whitelisting It is possible to whitelist specific IP addresses. This can be done via de Montaportal. IP’s can be added per useraccount. All IP’s are allowed when there isn’t an IP added to the white Technical details The API is set up according to the REST standard. Entities are identified with the URL. The HTTP method specified the action performed on an entity. GET To retrieve details of an entity POST To create a new entity PUT To update an entity DELETE To delete an entity JSON is used for requests and responses. Error handling The HTTP status codes defines the status of a request. These HTTP statuses are used: 200 The entity was successfully retrieved or successfully updated 204 The entity was successfully deleted 400 The entity could not be created, updated or deleted. Details about the problem are specified in the response content 403 The IP used for the request is not whitelisted 404 The entity you tried to retrieve, update or delete could not be found 429 Too many requests, rate limit exceeded Rate limits You can do 4500 requests every 5 minutes, 27000 an hour and 270000 requests a day."
  },
  "Algemene-informatie/Koppelingen/Selling-products/index.html": {
    "href": "Algemene-informatie/Koppelingen/Selling-products/index.html",
    "title": "Selling products",
    "keywords": "Selling products In de webshop staan de producten die worden verkocht. In de Montaportal staan producten die bij ons op voorraad staan. De product match, een onderdeel van de koppeling, legt een link tussen de producten bekend bij Montapacking en de webshop. Wanneer de informatie van het product 1 op 1 hetzelfde is bij zowel de Montaportal als de webshop dan zal het systeem automatische de koppeling leggen. Wanneer er gegevens afwijken, bijvoorbeeld de Barcode of SKU, dan zal de koppeling handmatig moeten worden gemaakt. Dit kan worden gedaan op de sellingproduct pagina. Letop, • Een barcode en SKU moeten uniek zijn voor een product. Er mogen dus geen verschillende producten zijn met dezelfde barcode of SKU. • Het hergebruiken van barcodes is ook niet aangeraden. • Wanneer er in de webshop een SKU wijzigt zal Monta dit zien als een nieuw product. Deze moet dan opnieuw worden gelinkt."
  },
  "Algemene-informatie/Koppelingen/index.html": {
    "href": "Algemene-informatie/Koppelingen/index.html",
    "title": "Koppelingen",
    "keywords": "Koppelingen Bij Monta hebben we standaard koppelingen die voor al onze klanten werken. Op deze manier kunnen we de bedrijfszekerheid van de koppelingen garanderen. Er zijn een aantal standaard onderdelen die onze koppelingen hebben. Welke onderdelen de koppelingen precies hebben is afhankelijk van de type koppelingen. Algemene datastromen De meeste koppelingen bevatten de volgende onderdelen. Afhankelijk van het platform kan je zien welke onderdelen de koppeling precies bevat. Productimport (producten vanuit webshop in Monta omgeving) Product Match (producten vanuit webshop gekoppeld met de producten in de Monta omgeving) Stockupdate (Voorraad die bij Monta ligt wordt verstuurd naar webshop) Order import (Orders worden in Monta geïmporteerd) Order status update (Orderstatus wordt naar webshop doorgestuurd) Letop: Niet alle koppelingen hebben alle onderdelen! Bekijk alle datastromen instellingen Uitgaande IP Bij sommige klanten is het nodig het IP van Monta te whitelist. Deze wordt gebruikt bij alle koppelingen en de FTP. Het uitgaande IP van Monta is: 193.53.249.2 Logging Orders van ondergenoemde platforms worden gelogd als rauwe gegevens. BigCommerce LightspeedEcom Magento2 Shopify Shopware Woocommerce"
  },
  "Algemene-informatie/Monta-Learning/index.html": {
    "href": "Algemene-informatie/Monta-Learning/index.html",
    "title": "Monta Learning",
    "keywords": "Monta Learning Op deze pagina worden alle Monta learning instructievideo's opgeslagen. Deze video's worden onderdeel van de elearning modules in de medewerkersapp. Goederenontvangst: Wat is goederenontvangst? ::: video ::: https://youtu.be/9jcSnQehTug Hoe werkt inbound en wat is een forecast? ::: video ::: https://youtu.be/YzyZweJU9TY Hoe ga je om met een batchlevering? ::: video ::: https://youtu.be/zCIUKSzkQoo Wat is crossdock en fastlane? ::: video ::: https://youtu.be/5KumUrL67tU Mogelijke problemen tijdens het inbounden ::: video ::: https://youtu.be/EzjjoTvQZ9Y Op voorraad plaatsen: Wat is koppelen? ::: video ::: https://youtu.be/cCMKmuHwLT0 Een deelkoppeling maken? ::: video ::: https://youtu.be/jlMnsEE9fmQ Voorraad verplaatsingen en controle: Het verplaatsen van voorraad: ::: video ::: https://youtu.be/fVt5eQeAhuc Wat is cycle count? ::: video ::: https://youtu.be/b4lb2Prlu2I Picken: Wat is picken en welke varianten zijn er? ::: video ::: https://youtu.be/-HEHYOeZ_ak Vaak voorkomende uitdagingen tijdens het picken ::: video ::: https://youtu.be/ovjLa0h4I8Q Wat is een runner? ::: video ::: https://youtu.be/G7SJudFTMrE Wat is een pickbon? ::: video ::: https://youtu.be/woZ2lTMUNIs Pick-to-light: Wat is een pick-to-light en hoe werkt het? ::: video ::: https://youtu.be/bi9gHP7L1yM Echeckwall: Hoe werkt een echeckwall? ::: video ::: https://youtu.be/SmCvd8nlMbc Mogelijke uitdagingen bij een echeckwall ::: video ::: https://youtu.be/iJRqIMffxQw Put-to-light: Wat is een put-to-light? ::: video ::: https://youtu.be/iJRqIMffxQw Hoe werkt een Put-to-light? ::: video ::: https://youtu.be/iJRqIMffxQw Inpakken: Welke verschillende verpakkingstypen zijn er? ::: video ::: https://youtu.be/_Ug0u8_wRK8 Hoe werkt de BVM machine (automatische zakkenmachine)? ::: video ::: https://youtu.be/6-1N96Gu1oE Gomonta: Personeelsplanning - Templates: ::: video ::: https://youtu.be/VJGE8rY7esw Personeelsplanning - Handigheidjes: ::: video ::: https://youtu.be/GIN6R7at8Sw Personeelsplanning - Inschatting plannen: ::: video ::: https://youtu.be/FPDUsLgoktQ Personeelsplanning - Productiviteit: ::: video ::: https://youtu.be/qhrQaijeM34 Joker update ::: video ::: https://youtu.be/siXUFzR7hEo"
  },
  "Algemene-informatie/MontaIdentity/index.html": {
    "href": "Algemene-informatie/MontaIdentity/index.html",
    "title": "MontaIdentity",
    "keywords": "MontaIdentity Monta gebruiker aanmaken Om een gebruiker toegang te geven tot GoMonta moet deze aangemaakt worden in GoMonta en daarna in MontaIdentity. Ga naar het gebruikersbeheer in GoMonta. Vul een email en naam in. Optioneel kan er een rol gekozen worden, welke geldt voor GoMonta en de interne processen. Ook kan er aangegeven worden tot welke magazijnen de gebruiker toegang heeft (systeem technisch). Als laatste kan er een badge toegevoegd worden. Met deze badge kan een gebruiker inloggen in de interne applicaties (Echeck, Inbound, Retouren, handscanners, enz.). Na het aanmaken van een nieuwe gebruiker komt er een schermpje naar boven. Hierop staat wat informatie vermeld die nodig is om een gebruiker aan te maken in het nieuwe Identity. Mocht het schermpje niet naar boven komen of wordt het per ongeluk weg geklikt, kan deze informatie ook teruggevonden worden bij de details van een gebruiker. Vervolgens moet de gebruiker dus aangemaakt worden in het nieuwe Identity systeem (https://identity.monta.nl). Na het inloggen kom je standaard op je eigen profiel pagina. Wanneer je admin rechten hebt, krijg je linksboven een menu te zien. Klik daar op het tabje “Users”. Bij de mobiele weergave moet er eerst op de ingelogde gebruiker geklikt worden. Dit opent een dropdown, met dezelfde menu items. Het gebruikersoverzicht wordt geopend. Rechtsboven staat de knop “Create new”. Het aanmaken van een nieuwe gebruiker in het nieuwe Identity systeem, bestaat uit een aantal stappen. Stap 1: de basis informatie van de gebruiker. Vul hier de gegevens in, die ook gebruikt zijn in GoMonta, zoals het email-adres en de Guid. Voor de gebruikersnaam wordt ook het email-adres gebruikt. Stap 2: voer een wachtwoord in. Hier moet een sterk wachtwoord ingevuld worden. De gebruiker verschijnt dan in de lijst en kan inloggen. Voor @monta account gaat het iets simpeler. Hiervoor is alleen stap 1 nodig. Vervolgens wordt er automatisch herkent dat het account via AD moet gaan inloggen. Rollen in MontaIdentity Algemene rollen: Superadmin: je mag alle users beheren (van alle relaties) en ook alle technische instellingen aanpassen (zoals client registraties). Monta admin: je mag alle users beheren (van alle relaties) maar geen technische instellingen aanpassen. Rollen per relatie: Admin: je mag alle users beheren van deze relatie. Employee: deze rol bestaat alleen om de user aan de relatie te koppelen."
  },
  "Algemene-informatie/MontaTracking/index.html": {
    "href": "Algemene-informatie/MontaTracking/index.html",
    "title": "MontaTracking",
    "keywords": "MontaTracking Hier volgt meer informatie over MontaTracking. Wat het is en hoe het ingericht moet worden. MontaTracking is een Track & Trace pagina voor de consument, waar de order statussen te bekijken zijn. Settings Op het moment maakt MontaTracking gebruik van de RMA settings. Er is dus een actieve RMA nodig om te kunnen werken. Hoe deze gemaakt en ingesteld kan worden is hier te vinden: RMA Module. Url Om de goeie GUID te krijgen die achter https://www.montatracking.com/{GUID} moet komen te staan moet er eerst naar de RMA portal genavigeerd worden in MontaPortal. Door op de link te klikken (zie foto) wordt er genavigeerd naar de RMA. Vervolgens kan de GUID verkregen worden door in adresbalk de cijfers te kopiëren na de / en voor het ? teken. (zie foto) Login De consument kan op dezelfde manier inloggen als bij de bijbehorende RMA, dit ligt aan de login settings van die RMA. Deze worden hier uitgelegd RMA Module onder het hoofdstuk 'RMA instellen' en dan het kopje 'Settings'. Met de standaard RMA settings kan de consument inloggen met webshop ordernummer en e-mail."
  },
  "Algemene-informatie/Outbound/BulkXL-pickstroom/index.html": {
    "href": "Algemene-informatie/Outbound/BulkXL-pickstroom/index.html",
    "title": "BulkXL pickstroom",
    "keywords": "BulkXL pickstroom In deze pickstroom worden de verzendlabels geplakt tijdens het picken. Op deze manier wordt het picken en Echecken samengevoegd. Deze pickstroom is ingericht voor orders met grote artikelen (XL orders), met artikelen die zijn gemarkeerd als eigen verpakking drager. De bulkXL pickstroom kent twee soorten, verzendlabels vooraf printen en verzendlabels tijdens picken printen. 1. Vooraf printen Route van de order: Vooraf printen Pickstroom wordt bepaald op basis van X-criteria (Groot volume; aantal colli). Pickstroom wordt geselecteerd. Krat wordt gescand (Picklabel). Verzendlabels worden gedrukt via de echeck. Picker wordt gestuurd naar locatie. Artikel wordt gescand; Verzendlabel wordt gescand. Verzendlabel wordt op artikel geplakt, artikel wordt opgestapeld. Pickroute wordt afgerond. 2. Tijdens picken printen Route van de order: Tijdens picken printen Pickstroom wordt bepaald op basis van X-criteria (Groot volume; aantal colli). Pickstroom wordt geselecteerd. Krat wordt gescand (Picklabel). Picker wordt gestuurd naar locatie. Artikel wordt gescand; Verzendlabel wordt ter plekken afgedrukt Verzendlabel wordt gescand. Verzendlabel wordt op artikel geplakt, artikel wordt opgestapeld. Pickroute wordt afgerond. Note: Voor de pickstroom tijdens het picken printen is er speciale hardware nodig: Meer informatie over bulkXL Randvoorwaarde: Artikelen zijn altijd een eigen verzendverpakking (Dit is ingevoerd in Gomonta). Meerdere colli bij 1 artikel niet mogelijk. Pickvolgorde wordt bepaald op basis van looproute, magazijn wordt ingericht op basis van groot naar klein om stapelen van pallets goed te krijgen. Artikelen zijn groter dan ingesteld (Afmetingen en gewichten moeten kloppen) Orders vallen binnen de XL of S* Pickstroom Orders vallen binnen de itemaantallen ingesteld in gomonta. Orders moeten niet door een pallet verzender verzonden worden. Er is een verzender geselecteerd *Note: binnen S-orders word geen onderscheid gemaakt in formaat, daarom worden de S-orders die aan de rest van de eisen voldoen meegeteld. In Gomonta zijn instellingen te vinden betreffende deze pickstroom: Outbound > Magazijn outbound instellingen onder \"Algemene pickstromen\": Voor deze pickstroom is het minimum en het maximum van het aantal orders en producten, dat in een pickronde mag voorkomen, in te stellen. Deze zijn te vinden op de hierboven genoemde pagina. Bij deze pickstroom is het niet mogelijk zijn om op ‘krat vol’ te klikken, want dan gaat iemand anders de orders picken terwijl de verzendlabels al geprint zijn. Wel is het mogelijk om verder te picken op een volgende krat (zoals bij put-to-light). In het geval dat alle producten al een eigen verzendverpakking hebben, is er ook de optie om deze randvoorwaarde te negeren. Dit voorkomt dat een product niet gepickt kan worden als er een product nog niet goed staat. Bij een joker kunnen ze proberen het product ergens anders te vinden en te scannen (dan hoeft het geen joker te worden). Als ze het product niet ergens anders vinden moeten ze de producten die eventueel al gepickt zijn van de pallet af halen en apart leggen."
  },
  "Algemene-informatie/Outbound/Echeck-only/index.html": {
    "href": "Algemene-informatie/Outbound/Echeck-only/index.html",
    "title": "Echeck only",
    "keywords": "Echeck only Echeck toevoegproducten Producten die in veel orders voorkomen kunnen bij de echeck gelegd worden. Ze hoeven dan niet gepickt te worden waardoor meer S en HM orders ontstaan die efficiënter (in bulk) gepickt kunnen worden. Het type magazijnlocatie dat we hiervoor gebruiken noemen we een echecklocatie. Zie Voorraadbeheer - Echeck locaties. Als producten op echeck locaties worden gelegd, kan het ook gebeuren dat er orders komen van producten die alleen op echeck locaties liggen. Deze hoeven dan niet via de scanner gepickt te worden. We noemen dit 'echeck only' orders. Op het hoofdscherm van de echeck staat een knop waarmee deze orders te vinden zijn. De knop gaat knipperen als er 'echeck only' orders beschikbaar zijn. Echeck Only Op dit 'echeck only' idee is een concept gebaseerd dat het voor klanten met weinig SKU's (bijvoorbeeld minder dan 20) en redelijk veel orders (bijvoorbeeld minimaal 50 per dag) mogelijk maakt om alle producten op echecklocaties te leggen, waardoor de hele stap van orderpicken wordt overgeslagen. Dit concept kan leiden tot hoge productiviteit, omdat een complete processtap wordt overgeslagen. Een 'echeck only' order wordt gestart in het echeck scherm, de producten worden gepakt vanuit een 'echeck only' locatie en gescand, waarbij de scan direct de echeck scan is. Dit 'echeck only' concept wordt nu op enkele vestigingen gebruikt. Als er interesse is het ook te gaan gebruiken, mail even met techniek@monta.nl en dan zullen we analyseren welke klanten binnen je magazijn mogelijk geschikt zijn. Het mooie van 'echeck only' is dat het vrijwel geen investeringen vraagt, er is alleen een stukje stelling nodig om wat magazijnlocties van het type echecklocatie in te maken en een aantal instellingen in de software. Voorbeeld van een opstelling in Molenaarsgraaf filmpje van werking echeck only in Molenaarsgraaf filmpje echeckonly Voorbeeld van een opstelling in Oud Gastel Echecktolight Er bestaat ook een luxere variant van 'echeck only' die we EcheckToLight noemen. Dit werkt hetzelfde als 'echeck only', alleen is er ondersteuning van lichtjes die gaan branden bij de juiste locaties. Dat maakt EcheckToLight geschikter als het assortiment bijvoorbeeld wat breder is (bijvoorbeeld enkele tientallen SKU's) en het aantal orders wat hoger (bijvoorbeeld minimaal 150 orders per dag)'. Op deze pagina is een uitgebreider beschrijving te vinden van EcheckToLight"
  },
  "Algemene-informatie/Outbound/Echecken/index.html": {
    "href": "Algemene-informatie/Outbound/Echecken/index.html",
    "title": "Echecken",
    "keywords": "Echecken Bepalen verzender Na het verpakken van een order wordt in de Echeck de definitieve verzender bepaald. Na het bepalen van de verzender wordt in de bijlage van een eorder bestand 'Shipper reason Echeck' en 'Collo details'. Shipper reason echeck geeft een overzicht van alle verzenders en waarom deze gekozen/afgekeurd zijn. Collo details geeft per collo de details over de collo weer. Alle vermelde maten en gewichten zijn op het moment van verpakken , en dus ook de gegevens welke aan de verzender doorgegeven zijn. Het kan dus voorkomen dat een materiaal in het heden een andere maat/gewicht heeft dan op het moment van verzenden wanneer dit in de tussentijd is aangepast."
  },
  "Algemene-informatie/Outbound/Jokers/index.html": {
    "href": "Algemene-informatie/Outbound/Jokers/index.html",
    "title": "Jokers",
    "keywords": "Jokers Wat zijn jokers? Als tijdens het picken of e-checken van het proces onderbroken wordt omdat er bijvoorbeeld een product ontbreekt wordt dit een joker genoemd. Bij het maken van een joker tijdens het picken wordt er gevraagd om een reden te kiezen uit de volgende drie opties: Barcode issue Te weinig producten Ander product Deze keuze moet worden gemaakt omdat de vervolgstap voor iedere keuze anders is. Barcode issue Deze optie moet gekozen worden wanneer het juiste product wel op de juiste locatie ligt, maar hier geen of geen werkende barcode op staat. De picker kan dit product dus niet scannen om door te gaan met zijn pickactie maar de order kan er wel compleet mee worden gemaakt. Om deze reden moet de picker het product wel meenemen en hoeft de locatie niet te worden geblokkeerd en word de picker niet naar een alternatieve locatie gestuurd. Wel is het maken van deze joker een melding voor shiftleaders om de overige producten te voorzien van een (betere) barcode. Wanneer deze jokerreden wordt geconstateerd is het aannemelijk dat dezelfde producten op andere locaties ook geen bruikbare barcodes hebben. Het is dan ook aan te raden om deze producten op andere locaties ook te checken om jokers te voorkomen. In het kort: Picker: Joker maken Product wel meenemen Product handmatig sorteren in de echeckwall en aanklikken bij de echecktafel Shiftleader: Locatie checken Nieuwe barcodes op producten plakken Eventuele correctieboeking bij een telverschil Hetzelfde product op andere locaties checken of deze wel bruikbare barcode hebben Te weinig producten Deze optie moet gekozen worden wanneer er niks op locatie ligt of het juiste product er ligt maar niet genoeg. De picker kan dan dus niet alle orders compleet maken uit deze locatie. Om deze reden moet de picker na het kiezen van “te weinig producten” op de scanner ook invullen hoeveel producten hij dus wel mee kan nemen. Op basis hiervan kan een alternatieve locatie worden bepaald om de overige producten te kunnen picken en dus alle orders compleet te maken. Zie Alternatieve picklocatie. In het kort: Picker: Joker maken Aangeven hoeveel producten je wel kan meenemen Zoveel mogelijk producten meenemen Shiftleader: Locatie checken Eventuele correctieboeking bij een telverschil Locatie deblokkeren Ander product Deze optie moet gekozen worden wanneer er een ander product op de locatie ligt dan gewenst. Om deze reden moet de picker dan ook de producten laten liggen zodat niet de foute producten verzonden worden naar consumenten. In het kort: Picker: Joker maken Producten laten liggen Shiftleader: Locatie checken Correctieboekingen Of product A afboeken en product B opboeken Of product A afboeken en product B verplaatsen naar een andere locatie waar dit product ligt. Wanneer deze handelingen worden gevolgd zullen alle orders compleet bij de e-check aankomen en hoeven shiftleaders deze jokerorders niet meer op te lossen. Zij hoeven nu enkel jokerlocaties op te lossen. Tenzij er een product mist wat geen 2e locatie heeft. Product zonder 2e locatie Wanneer een product geen 2e locatie heeft en niet gepickt kan worden in het pickproces kan de order niet compleet worden gemaakt door de picker zelf. Wanneer dit voorkomt zal de order bij de shiftleader moeten worden gemeld en is het de taak van de shiftleader om de jokerlocatie of oudere locaties van dit product te checken om misschien toch het product te vinden. Zo niet zal er een backorder gemaakt moeten worden voor het missende product. Alternatieve picklocatie Er kan ingeschakeld worden dat als een te picken product niet wordt aantroffen op een locatie (joker), de orderpicker wordt doorgestuurd naar een volgende locatie waar het product ligt. De locatie wordt dan geblokkeerd om te voorkomen dat er meer orders op vrijkomen. Als er geen voorraad is op een andere locatie, wordt een gewone pickjoker gemaakt. Andere orders die van die locatie gepickt moesten worden, maar nog niet picking zijn, worden opnieuw geverifieerd, waarbij ze omgezet worden naar een andere locatie of in backorder komen. Andere orders die van die locatie gepickt moesten worden en al picking zijn, worden niet omgezet, dus gaan dezelfde flow in."
  },
  "Algemene-informatie/Outbound/Picken-en-consolideren/index.html": {
    "href": "Algemene-informatie/Outbound/Picken-en-consolideren/index.html",
    "title": "Picken en consolideren",
    "keywords": "Picken en consolideren Voor het picken en consolideren zijn er een aantal bouwstenen beschikbaar: de echeckwall, de PutToLight en PickToLight. De echeckwall en PutToLight zijn er beide op gericht om zoveel mogelijk in bulk te picken en vervolgens uit te sorteren. De PickToLight is bedoeld voor klanten met een smal assortiment en kleine producten maar wel een hoge omloopsnelheid. Echeckwall Inmiddels zijn er drie varianten van de echeckwall. Hieronder staan de verschillende varianten beschreven: Reguliere echeckwall Dit is de meest voorkomende variant van de echeckwall. Dit is een modulaire unit waarbij de vak indeling vooraf te kiezen is. Zoals op onderstaande foto te zien is, zijn de modulaire units los te gebruiken, maar zijn ze ook aan elkaar te koppelen om er een grotere echeckwall van te maken met meer capaciteit. Echeckwall XL De echeckwall XL is speciaal ontworpen voor klanten met grote producten, die in batches te picken zijn en maximaal 5 items in een order hebben. Onderstaande foto geeft een voorbeeld weer uit breda. Deze echeckwall XL is ontwikkeld voor een dekbedden webshop. De werking van deze grote echeckwall is volledig gelijk aan de reguliere echeckwall, enkel zijn de vakken groter. Virtuele echeckwall De virtuele echeckwall is bedoeld voor vestigingen die wel graag in bulk de orders willen picken, maar waarbij het sorteren minder belangrijk is. Hierbij wordt er geen fysieke echeckwall geplaatst, maar wordt enkel de pickroute van de echeckwall gebruikt. Een voorbeeld hierbij is de vestiging in Den Bosch. Hierbij kunnen er meerdere orders tegelijk gepickt worden op een pallet. Omdat in deze situatie de producten vaak groot en duidelijk te herkennen zijn, is het sorteren in een fysieke echeckwall niet nodig. De batch met gepickte items wordt na het picken direct bij de echeckwall verwerkt."
  },
  "Algemene-informatie/Outbound/Pickstromen-op-basis-van-specifieke-Hardware/index.html": {
    "href": "Algemene-informatie/Outbound/Pickstromen-op-basis-van-specifieke-Hardware/index.html",
    "title": "Pickstromen op basis van specifieke Hardware",
    "keywords": "Pickstromen op basis van specifieke Hardware Echeckwall pickstroom Alleen orders die passen in de Echeckwall vakjes worden ingepland. Orders die daarbuiten vallen komen in de reguliere M, S of HM-order pickstroom. Orders die in de Echeckwall passen komen niet meer in de reguliere M-order pickstroom. Het in-uitschakelen van de Echeckwall pickroute kan door IT gedaan worden in het veld tblMagazijnLocatieVerdieping.EcheckwallEnabled Verder kan per relatie ingesteld worden dat een relatie NIET via de echeckwall gepickt moet worden (https://gomonta.montapacking.nl/Office/Relatie/Index) Er kan worden gekozen of S-orders wel of niet meegenomen worden in de Echeckwall pickstroom. Dit omdat het niet in alle gevallen logistiek gezien handig is S-orders mee te picken. Dit kan via het magazijn instellingen scherm in gomonta (https://gomonta.montapacking.nl/WMS/Shift/WarehouseSettings#PutToLightAndEcheckwall) onder het kopje 'Put to Light en Echeckwall picken'. Door het getal 0 in te vullen bij 'Maximale aantal S-orders in Echeckwall pickroute ', worden S-orders niet meer meegenomen in de Echeckwall pickroute Wanneer M of HM orders veel items bevatten, is het soms raadzaam ze niet via de echeckwall te verwerken in verband met het grote aantal scans tijdens sorteren. Via de instelling 'Maximaal aantal items in Echeckwall order' kunnen orders met veel items uitgesloten worden van de Echeckwall pickroute. Echeckwall XL pickstroom De Echeckwall XL pickstroom werkt vrijwel hetzelfde als de Echeckwall pickstroom die hierboven beschreven is. Waarbij in de Echeckwall XL pickstroom de LM en HLM orders worden meegenomen. Een Echeckwall XL pickstroom is alleen beschikbaar op een verdieping als reguliere Echeckwall is ingeschakeld EN er is een EcheckwallXL (tblEcheckwallStelling.EcheckwallXL = true voor deze verdieping) dan komt de EcheckwallXL pickstroom beschikbaar Verder kan de beschrijving van de Echeckwall Pickstroom gevolgd worden. Put To Light pickstroom PutToLight is in te schakelen door een aantal hoger dan 0 in te vullen bij 'Put to Light Aantal orders' in het instellingen scherm per magazijn/verdieping (https://gomonta.montapacking.nl/WMS/Shift/WarehouseSettings#PutToLightAndEcheckwall) PutToLight orders zijn ook zichtbaar in de reguliere M en HM pickstromen. (er is een wens om dit aan te passen) Wanneer M of HM orders veel items bevatten, is het soms raadzaam ze niet via de Put To Light te verwerken in verband met het grote aantal scans tijdens sorteren. M-orders of HM-orders met veel items kunnen worden uitgesloten door 'Maximaal aantal items in een order' in te stellen. Ook kan via 'Put to Light Maximale afmetingen' ingesteld worden dat orders met te grote producten niet in de Put To Light pickstroom gepland worden Monta Pac-man verpakkingsmachine In de verify wordt via een stapelalgoritme bepaald of de producten van de order niet te groot zijn voor de maximale afmetingen die de Monta Pac-man machine aan kan. Ook wordt in de verify gekeken of de producten niet te klein zijn voor de minimale afmetingen van de Monta Pac-man. Deze afmetingen van de monta pac man zijn door IT instelbaaar in tblMontapackerContainerSettings Ook een totaal ordergewicht > 15 kg wordt uitgesloten. Dat is nu nog hardcoded. Orders naar landen met proforma (tblCountryCodes.ProFormaInvoiceRequired) worden uitgesloten omdat het printen van douane documenten lastig is op de machine. Als aan alle voorwaarden voldaan is tijdens het verifieren van de order, krijgt de order dan ReadyToPickState Montapacker (nr19), dit is niet echt een pickstroom, maar een filtermogelijkheid over bestaande pickstromen. Over het algemeen kunnen dan orders uit de volgende pickstromen onder dit filter vallen. S M HM Zie ook deze pagina voor meer info. BVM verpakkingsmachine De BVM verpakkingsmachine pickstroom is in te schakelen door bij de outbound magazijninstellingen de verpakkingmachine aan te zetten. (https://gomonta.montapacking.nl/WMS/Shift/WarehouseSettings#PickingSizes) Een orders moet aan de volgende eisen voldoen om in de pickstroom te komen: De order moet een S-orders zijn. De afmetingen van order moeten groter zijn dan 140 bij 90 bij 1 mm. De afmetingen van order moeten kleiner zijn dan 500 bij 400 bij 100 mm. De klant moet toestaan dat de orders ingepakt mogen worden door de verpakkingsmachine. Dit is in te stellen in het relatie instellingenscherm. Als een order een toevoegproduct heeft, dan moet deze toegestaan zijn voor de verpakkingsmachine. Dit kan worden ingesteld in het product instellingenscherm. Orders die geschikt zijn voor de BVM machine zijn te herkennen via onderstaande pickstroom op de scanner"
  },
  "Algemene-informatie/Outbound/Versturen-buiten-de-EU/index.html": {
    "href": "Algemene-informatie/Outbound/Versturen-buiten-de-EU/index.html",
    "title": "Versturen buiten de EU",
    "keywords": "Versturen buiten de EU Vanaf 2020 is het voor alle pakketten die worden verstuurd buiten de EU verplicht om een Proforma (Douane document) mee te sturen met de pakketten. Monta vindt het belangrijk dat deze documenten correct en volledig worden meegestuurd. Daarom zullen wij bij alle orders buiten de EU een Proforma genereren. Waar mogelijk sturen we deze Proforma’s digitaal mee richting de vervoerder. In sommige gevallen zal deze proforma op papier worden meegestuurd. Om een proforma te kunnen genereren hebben we een aantal gegevens nodig. Mist Monta één van deze gegevens, dan zullen we de order blokkeren, en is het niet mogelijk om de order naar dit land te versturen. Voordat het mogelijk is om buiten de EU te versturen is het dus verplicht om een aantal instellingen te doen. Instellingen: EORI nummer en BTW nummer instellen (Verplicht): Op de Proforma moeten we het EORI nummer en BTW nummer worden ingevuld. Deze moet per kanaal worden ingesteld via de volgende: HS-tariefcode en Land van Herkomst bij Producten (Verplicht). Monta en de Douane moet weten wat voor producten het zijn, en waar ze origineel vandaan komen. Daarom is het verplicht om de HS-tariefcode en het land van herkomst in te vullen bij de producten. Bij sommige koppelingen kan deze informatie worden geimporteerd uit de webshop. In de meeste gevallen moet er echter in de Montaportal de informatie worden ingeladen. Dit is mogelijk op een aantal manieren: Per product: Op de product detailpagina is zijn de gegevens aan te passen: Excel uploaden: Het is ook mogelijk om de gegevens te updaten in bulk via een Excel import. Dit kan via de volgende stappen: Upload een Excel met de volgende kolommen: Via: Overige douane gegevens invullen (Optioneel) Hier kun je het EORI nummer en het BTW nummer opgeven voor specifieke landen per kanaal. Douane statement invullen (Optioneel) Met een douane statement op de pro forma kun je goedkopere importtarieven krijgen. Hier kan de tekst opgeslagen worden uit een handelsovereenkomst die op de proforma erbij gezet moet worden."
  },
  "Algemene-informatie/Outbound/Verzenders/Budbee/index.html": {
    "href": "Algemene-informatie/Outbound/Verzenders/Budbee/index.html",
    "title": "Budbee",
    "keywords": "Budbee Budbee kan niet op alle postcodes bezorgen. Daarom wordt bij het maken van een label, en bij het opvragen van de verzendopties uit onze API (tbv de checkout) gecontroleerd of Budbee op die postcode bezorgd. Bij het maken van het label komt een foutmelding (joker) als verzenden naar die postcode niet mogelijk is. In de checkout wordt de optie Budbee niet teruggegeven als bezorgen naar die postcode niet mogelijk is."
  },
  "Algemene-informatie/Outbound/Verzenders/DHL/index.html": {
    "href": "Algemene-informatie/Outbound/Verzenders/DHL/index.html",
    "title": "DHL",
    "keywords": "DHL Varianten DHL parcel Voor zendingen binnen Nederland. Kunnen niet bij een DHL servicepunt ingeleverd worden voor verzending. DHL parcel buspakje Voor zendingen binnen Nederland die door de brievenbus passen. Is goedkoper omdat de bezorger niet hoeft aan te bellen. Kunnen niet bij een DHL servicepunt ingeleverd worden voor verzending. DHL parcel groot Voor zendingen met DHL Parcel die groter zijn dan eigenlijk door DHL toegestaan waardoor DHL een toeslag zal rekenen. DHL servicepunt Voor zendingen binnen Nederland naar DHL afhaalpunten. Kunnen niet bij een DHL servicepunt ingeleverd worden voor verzending. DHL For You Voor zendingen binnen Nederland. Deze kunnen bij servicepunten ingeleverd worden voor verzendingen. DHL For You buspakje Voor zendingen binnen Nederland die door de brievenbus passen. Is goedkoper omdat de bezorger niet hoeft aan te bellen. Deze kunnen bij servicepunten ingeleverd worden voor verzendingen. DHL For You pickup point Voor zendingen binnen Nederland naar DHL afhaalpunten. Deze kunnen bij servicepunten ingeleverd worden voor verzendingen. DHL Parcel Connect Voor zendingen van Nederland naar een aantal landen binnen de Europese Unie. Alle gegevens van het pakket worden in een grote QR-achtige barcode op het verzendlabel geprint. In het ontvangst land wordt deze barcode uitgelezen en wordt het pakket aangemeld. De track&trace code werkt dus pas als het pakket aangekomen is in het land van ontvangst. DHL Parcel Connect Pickup point Voor zendingen van Nederland naar een afhaalpunt in een aantal landen binnen de Europese Unie. DHL pallet Voor pallet zendingen van Nederland naar een aantal landen binnen de Europese Unie. DHL Paket Voor zendingen binnen Duitsland. Momenteel ondersteunen de volgende vestigingen deze vervoerder via een directe linehaul: Edisonweg Weide Papland Molenaarsgraaf Waspik Breda Krefeld DHL Paket Internationaal Voor zendingen vanuit Duitsland. Hiermee kan ook naar Packstations verzonden worden. Dit vereist dat de consument het adres op de juiste manier intypt in de webshop. Zie https://www.dhl.de/en/privatkunden/pakete-empfangen/an-einem-abholort-empfangen/packstation/empfangen-packstation.html. DHL Europlus Voor zakelijke pakketten van Nederland naar een aantal landen binnen de Europese Unie. Die worden bijvoorbeeld niet na 1700 uur geleverd omdat bedrijven dan dicht zijn. DHL Warenpost (Internationaal) Voor zendingen wereldwijd in klein formaat vanuit een vestiging in Duitsland (Krefeld) Retouradres Bij DHL Parcel is het niet mogelijk om een afwijkend retouradres in te stellen. Dit omdat DHL parcel alle retouren van een magazijn verzameld en dan in bulk terugstuurt. Het retouradres is dus altijd het retouradres van het magazijn. Bij DHL For You is het wel mogelijk om een afwijkend retouradres in te stellen. Adresvalidaties en maximale lengte velden DHL parcel (incl buspakje, servicepunt en groot) Niet mogelijk naar postbussen Huisnummer: verplicht, moet numeriek zijn, niet langer dan 5 cijfers Huisnummer toevoeging: mag niet langer zijn dan 7 karakters Bij de digitale aanmelding van de zending bij DHL: Naam: wordt afgekapt na 100 karakters Plaats (stad): de aanmelding gaat fout als de plaats langer is dan 80 karakters Bij DHL servicepunt zendingen: Bedrijfsnaam verplicht Factuuradres is verplicht. Deze moet de gegevens bevatten van de consument die het komt afhalen, zodat DHL dit kan controleren. In de verzender opties moet de code van het servicepunt ingevuld zijn. DHL Parcel Connect (incl pickup point) Straat: mag niet langer zijn dan 35 karakters Huisnummer: indien ingevuld mag het niet langer zijn dan 35 karakters Huisnummer toevoeging: indien ingevuld mag het niet langer zijn dan 35 karakters Postcode: mag niet langer zijn dan 9 karakters Plaats (stad): moet ingevuld zijn en mag niet langer zijn dan 35 karakters Bij zendingen naar een pickup point: Factuuradres is verplicht. Deze moet de gegevens bevatten van de consument die het komt afhalen, zodat DHL dit kan controleren. In de verzender opties moet een aantal gegevens van het pickup point ingevuld zijn. Als het pickup point een Packstation is (kluisje) dan moet er ook een Postnummer ingevuld zijn in de shipper opties. De consument moet deze ingevuld hebben in de webhshop. Hiermee kan de consument zijn order afhalen uit het kluisje. Zie https://www.dhl.de/de/privatkunden/hilfe-kundenservice/packstation/allgemein.html. DHL Pallet Geen extra validaties. DHL Paket Als het huisnummer veld niet ingevuld is halen we dit uit de straat. Dit nummer mag niet aan het begin staan. Wat betreft packstations: We lezen alle adresregels uit. We zoeken dan of er in het adres de naam ‘packstation’, gevolgd door een nummer voorkomt. Voor het postnummer zoeken we naar het hoogste getal in de adresvelden. Dit kunnen we doen omdat het postnummer altijd uit 7 getallen of meer bestaat. Kunnen we geen matchend postnummer vinden, dan blokkeren we de order. Want een postnummer is verplicht bij een packstation."
  },
  "Algemene-informatie/Outbound/Verzenders/DPD/index.html": {
    "href": "Algemene-informatie/Outbound/Verzenders/DPD/index.html",
    "title": "DPD",
    "keywords": "DPD Varianten DPD Voor het versturen van pakketten van Nederland naar wereldwijd. DPD PL Voor het versturen van pakketten van Polen naar Polen. Adresvalidaties en maximale lengte velden Naam: wordt afgekapt na 35 karakters Bedrijfsnaam: wordt afgekapt na 35 karakters Straat: wordt afgepakt na 35 karakters. Het gedeelte na het 35ste karakters wordt in Referentie2 geplaatst zodat het toch op het label komt. Huisnummer + huisnummer toevoeging (met een spatie ertussen): wordt afgekapt na 8 karakters. Het gedeelte na het 8ste karakter wordt in Referentie2 geplaatst zodat het toch op het label komt. Postcode: mag niet langer zijn dan 9 karakters Plaats (stad): mag niet langer zijn dan 35 karakters E-mailadres (indien ingevuld): mag niet langer zijn dan 50 karakters De opmerking bij het afleveradres wordt digitaal doorgegeven (afgekapt op 35 karakters) aan DPD maar komt niet op het label."
  },
  "Algemene-informatie/Outbound/Verzenders/DynaLogic/index.html": {
    "href": "Algemene-informatie/Outbound/Verzenders/DynaLogic/index.html",
    "title": "DynaLogic",
    "keywords": "DynaLogic Adresvalidaties en maximale lengte velden Straat mag niet langer zijn dan 50 karakters Huisnummer mag niet langer zijn dan 10 karakters Huisnummer toevoeging mag niet langer zijn dan 20 karakters Postcode mag niet langer zijn dan 10 karakters Plaats (stad) mag niet langer zijn dan 50 karakters"
  },
  "Algemene-informatie/Outbound/Verzenders/GLS/index.html": {
    "href": "Algemene-informatie/Outbound/Verzenders/GLS/index.html",
    "title": "GLS",
    "keywords": "GLS GLS bied geen avondlevering. GLS bied geen tijdvakken aan. Een order kan elk moment van de dag (tussen 08:30 en 18:00) geleverd worden. Daarom laten we ook geen tijdvakken zien in de checkout."
  },
  "Algemene-informatie/Outbound/Verzenders/PostNL/index.html": {
    "href": "Algemene-informatie/Outbound/Verzenders/PostNL/index.html",
    "title": "PostNL",
    "keywords": "PostNL Varianten PostNL Voor het versturen van pakketten vanuit Nederland naar de meeste landen in de wereld. PostNL Groot Voor het versturen van pakketten vanuit Nederland naar de meeste landen in de wereld. Voor pakketten die groter zijn dan de maximale afmetingen van PostNL waardoor PostNL een toeslag rekent. PostNL Pakje gemak Voor het versturen naar PostNL afhaalpunten in Nederland en België. Extra @ Home drempel Voor grote producten die door twee personen geleverd moeten worden. Van Nederland naar de Benelux. Adresvalidaties en maximale lengte velden PostNL (inclusief -groot, pakje gemak en extra@home) Straat mag niet langer zijn dan 95 karakters Postcode mag niet langer zijn dan 10 karakters Plaats (stad) mag niet langer zijn dan 35 karakters Voor zendingen naar Nederland: Huisnummer: verplicht, moet numeriek zijn Voor zendingen naar buiten Nederland: Huisnummer: niet verplicht, indien ingevuld mag het niet langer zijn dan 35 karakters Huisnummer toevoeging: niet verplicht, indien ingevuld mag het niet langer zijn dan 35 karakters Voor zendingen naar een PostNL afhaalpunt of pakketautomaat is het factuuradres verplicht. Deze moet de gegevens bevatten van de consument die het komt afhalen, zodat PostNL dit kan controleren."
  },
  "Algemene-informatie/Outbound/Verzenders/UPS/index.html": {
    "href": "Algemene-informatie/Outbound/Verzenders/UPS/index.html",
    "title": "UPS",
    "keywords": "UPS Documentatie UPS Shipping Api documentatie: Download. De laatste versie is te downloaden op het UPS developer portal. De inloggegevens staan in passwordstate. Adresvalidaties en maximale lengte velden Het telefoonnummer wordt afgekapt na 15 karakters Naam en bedrijfsnaam worden afgekapt na 30 karakters Het volledige adres (straat + huisnummer + toevoeging) wordt opgesplitst in 3 adresregels van maximaal 35 karakters. Het adres wordt dus afgekapt na 105 karakters."
  },
  "Algemene-informatie/Outbound/Verzenders/index.html": {
    "href": "Algemene-informatie/Outbound/Verzenders/index.html",
    "title": "Verzenders",
    "keywords": "Verzenders Onder deze pagina staat per verzender een pagina met informatie over die verzender. DHL PostNL DPD UPS GLS DynaLogic Budbee"
  },
  "Algemene-informatie/Outbound/index.html": {
    "href": "Algemene-informatie/Outbound/index.html",
    "title": "Outbound",
    "keywords": "Outbound Outbound is het versturen van goederen vanuit het magazijn. Flowchart graph TD; place --> import verify --> pick ship --> collect deliver --> receive ship --> anonimise subgraph Consument place[Plaatst order] receive[Ontvangt order] end subgraph Monta software import[Importeert order in Monta] --> verify[Verifieert order] anonimise[Anonimiseren] --> archive[Archiveren] end subgraph Magazijn pick[Picken] --> echeck[\"Inpakken (echecken)\"] --> ship[Verzenden] end subgraph Verzender collect[Ophalen] --> sort[Sorteren] --> deliver[Afleveren] end Order Een order kan op de volgende manier ontstaan: Via een koppeling uit een webshop, marketplace of ander systeem van een klant Handmatig aangemaakt worden op Montaportal Uit een Excel bestand geimport worden op Montaportal In GoMonta bij het uitruimen van locaties Typen orders B2B Een order kan als B2B (business to business) gemarkeerd worden. Bepaalde instellingen zoals de verzender matrix, pakbon layout kunnen anders zijn voor B2B orders. Ook kunnen aparte verkooptarieven ingesteld worden. Value added logistics Ook wel verpakkingsorders genoemd. Voor voorraad die afgeboekt moet worden bijvoorbeeld om te verpakking/om te pakken. In de verkooptarieven kan ingesteld worden dat deze orders niet gefactureerd moeten worden. Quarantaine orders Orders om quarantaine voorraad af te boeken. Order statussen Verifying: een nieuwe order moet eerste geverifieerd worden. Blocked: de order kan niet verwerkt worden omdat er iets mis mee is of omdat deze handmatig geblokkeerd is. Backorder: de order kan niet verwerkt worden omdat er geen voorraad is. Etransit: de order staat in de wacht om op een datum in de toekomst verwerkt te worden. Queued: de order staat klaar om gepickt te worden. Picking: de order wordt gepickt. Picked/Packing: de order is gepickt en wordt ingepakt. Packed/Shipping: de order ingepakt, het verzendlabel wordt geprint. Shipped: het verzendlabel is geprint. De volgende statussen zijn beschikbaar als er een koppeling is met de verzender om de status van de verzending op te halen. Zie Verzenden - order afleverstatus. EnRoute: de order is ingescand bij de verzender. Delivered: de order is afgeleverd. AvailablePickup: de order is gereed voor afhalen bij een afhaalpunt van de verzender. Collected: de order is afgehaald bij een afhaalpunt van de verzender. Delivery failed: het afleveren van de order is mislukt, de order komt retour. Opmerkingen over de volgorde van de statussen die een order doorloopt: Een Picking order kan niet meer geblokkeerd worden. Om toch te voorkomen dat een order verzonden wordt kan de order op verzender \"Cancelled\" worden gezet. De producten worden dan via de retourverwerking weer op voorraad genomen. Een order kan van Picking en Packing teruggaan naar Backorder, als tijdens het picken blijkt dat de voorraad fysiek niet aanwezig is in het magazijn. Verifiëren Bij het verifiëren van een order gebeuren een aantal dingen. Dropship orders op verzonden zetten. Zie dropshipment. Controle dubbel ordernummer Prepack instellen Adres normalisatie en -validatie E-mailadressen hashen Geblokkeerde landen, postcodes, e-mailadressen, producten Toevoeg- en splitsproducten instellen Producten zoeken aan de hand van het SKU Order omzetten naar magazijn van de supplier Grote producten splitsen naar aparte order Douane informatie (pro forma) controleren. Zie pro forma invoice. Dangerous goods. Zie verzenden - gevaarlijke goederen. Shipper opties ingesteld bij het kanaal voor alle orders toepassen. Zie Verzender opties. Order splitsen op prijs. Zie Orders splitsen / deelverzendingen. Instelling 'verzekerd verzenden vanaf orderwaarde' toepassen. Zie verzekerd verzenden. Surprise pack per product. Bij een product kan ingesteld worden dat deze altijd een inpakinstructie moet krijgen. Zie Surprise pack. Backorder controle. Zie backorder controle. Er wordt gekeken of alle producten op voorraad zijn. Is dit niet geval, dan krijgt de order de status Backorder. Er wordt nog wel een verzender bepaald, maar geen geplande verzenddatum en de order wordt ook niet klaargezet voor het pickproces. Voorraad reserveren. Als een order geen backorder is wordt een voorraadreservering gemaakt. Bij backorders, Etransit orders en geblokkeerde orders wordt standaard ook een voorraadreservering gemaakt, maar dit is uit te schakelen. Voorraadreserveringen zorgen ervoor dat orders in de juiste volgorde verwerkt worden. Zie voorraadreserveringen voor meer informatie. Verzender bepalen. Er wordt een verzender bepaald voor de order. Zie verzender keuze voor meer informatie hierover. Geplande verzenddatum bepalen. Zie geplande verzenddatum. Order klaarzetten voor het pickproces. De voorraad wordt afgeboekt en toegewezen aan de order. Zie ook locatie keuze. Als een vertraging tussen koppelen en picken is ingesteld, wordt hier gecontroleerd wanneer voor het laatst gekoppeld is op de gekozen locaties. Als dit korter geleden is dan ingesteld, wordt de order in de wacht gezet. Vervolgens wordt elke drie minuten gecontroleerd of de order vrijgegeven kan worden. Adres normalisatie en -validatie Bij het verifiëren van een order wordt eerst het genormaliseerd en daarna gevalideerd. Afleveradres en factuuradres worden beide genormaliseerd. Het afleveradres wordt altijd geverifieerd, alleen bij zendingen naar een afhaalpunt wordt het factuuradres ook geverifieerd. Het factuuradres wordt namelijk doorgegeven bij afhaalpunten zendingen, hiermee controleert de verzender of ze het aan de juiste consument afgeven. Adresnormalisatie Bij het normaliseren gebeurd het volgende: Het land, wat bijvoorbeeld ook ingevuld kan zijn als \"België\", wordt omgezet naar de tweeletterige lancode De postcode wordt genormaliseerd: bij landen die een numerieke postcode hebben (bijv België en Duitsland) worden alle niet-numerieke tekens eruit gegooid. Bij landen die ook letters in de postcode hebben (bijv Nederland) wordt alle tekens die geen letter of cijfer zijn eruit gegooid. Bij Belgische en Nederlandse adressen: Als er niet-numerieke tekens in het huisnummer staan worden die verplaatst naar de toevoeging Als er geen huisnummer is ingevuld (bijv omdat het hele adres in de straat staat) wordt geprobeerd het huisnummer af te splitsen. Huisnummer afsplitsen bij Nederland en België Soms wordt het adres als één veld aangeleverd, dus straat + huisnummer (+ evt toevoeging) in één veld. Voor NL en BE proberen we het dan eerst te splitsen om te kunnen beoordelen of het huisnummer aanwezig en numeriek is is. Dit doen we volgens bepaalde regels van PostNL, die hier staan beschreven: https://www.postnl.nl/klantenservice/bestellen-en-downloaden/documentatie-downloaden/kix-code/ (ToolKIX Pro voor software-ontwikkelaars en dan de Word handleiding in de zip). [[Doelgroep IT De \"RiskKIX-tabel\" (hierin staan de postcodes die een nummer in straatnaam hebben) moet handmatig worden bijgewerkt. Hoe dit moet staat in de IT wiki. Adresvalidatie Na het normaliseren wordt het adres gevalideerd. Als het adres niet geldig is, wordt de order geblokkeerd. Naam, straat, plaats en landcode moeten ingevuld zijn Landcode moet een geldige landcode zijn Het format van de postcode moet goed zijn (bijv in Belgie 4 cijfers). [[Doelgroep IT Hiervoor staan reguliere expressies in de landentabel.]] In NL en BE moet een huisnummer aanwezig zijn en dit moet een nummer zijn Extra adresvalidaties van de verzender: bij sommige verzenders worden nog extra verzender specifieke controles gedaan. Zie de pagina van de betreffende verzender welke controles gedaan worden. Bij het printen van het verzendlabel bij de Echeck kan het zijn dat de verzender ook nog controles doet. (Als het label wordt opgehaald uit het systeem van de verzender.) Het kan zijn dat de verzender \"strenger\" is dan onze controles (zoals hierboven beschreven). Dan kan het label niet gemaakt worden en wordt de order joker. De melding van de joker bevat de foutmelding die de verzender geeft. Hiermee kan het adres gecorrigeerd worden en kan opnieuw geprobeerd worden het verzendlabel te printen. Maximale lengte van de velden De maximale lengte van de naam- en adresvelden bij Monta is 255 karakters. Meer karakters zullen afgekapt worden bij het importeren van de order of er zal een fout ontstaan bij het importeren. Elke verzender heeft ook limitaties voor het aantal karakters in de naam- en adresvelden. Zie hiervoor de pagina van de betreffende verzender. Orders splitsen / deelverzendingen Een order kan in meerdere delen verzonden worden. De order wordt dan gesplitst. Een order kan gesplitst worden op de volgende manieren: Splitsen van backorders Splitsen van backorders van specifieke suppliers Splitsen op waarde Splitsen over magazijnen Afsplitsen grote producten Handmatig op de montaportal Hoe zit het met de terugkoppeling naar de webshop bij gesplitste orders? 1. Splitsen van backorders Bij een kanaal kan worden ingeschakeld dat backorders gesplitst moeten worden. Dit kan ook bij een order worden meegegeven vanuit de koppeling. Hiermee kan het deel wat op voorraad is al meteen verzonden worden. Het deel wat niet op vooraad is kan dan later verzonden worden. Het splitsen wordt uitgevoerd bij de backorder controle. Let op bij het inschakelen van het automatisch splitsen van backorders. Dit kan zorgen voor veel losse orders. Elke 3 minuten worden namelijk de backorders van nieuwe voorraad gecontroleerd. Dus als je een backorder hebt met 50 regels, en elke 5 minuten wordt een product op locatie gekoppeld, ontstaan er 50 losse orders. We zijn bezig om een knop te maken waarmee klanten op een zelf gekozen moment de backorders kunnen splitsen. Dit zit in scrum punt: #4291. 2. Splitsen van backorders van specifieke suppliers Zie backorder controle. 3. Splitsen op waarde Om orders met hoge waarde te splitsen in meerdere orders met een lagere waarde. Om hoge importheffingen te voorkomen. Dit kan ingesteld worden in de Montaportal. 4. Splitsen over magazijnen Zie Verzenden vanuit meerdere magazijnen. 5. Afsplitsen grote producten Het is mogelijk om automatisch grote producten af te splitsen naar losse orders. Omdat orders met één item (S orders) efficiënter verwerkt kunnen worden. Dit moet per klant ingesteld worden. Per magazijn is in te stellen vanaf welke afmetingen producten afgesplitst moeten worden bij de klanten waarbij dit ingeschakeld is. 6. Handmatig op de montaportal De klant kan op de Montaportal handmatig een backorder splitsen. Factuurinformatie meesplitsen Om te voorkomen dat een afgesplitste order geen factuurinformatie meer heeft (wat nodig is voor douane zendingen), kan ingeschakeld worden dat de factuur ook wordt gesplitst. Dit kan ingeschakeld worden op de Montaportal. Standaard staat dit uitgeschakeld omdat Monta niet zonder toestemming financiële informatie wil manipuleren. Backorder controle Bij de backorder controle wordt gekeken of er voldoende beschikbare voorraad is om de order te verwerken. Hierbij gebeurd ook het volgende: Toevoegproducten verwijderen die geen backorder mogen veroorzaken Als bij de order staat ingesteld dat deze geen backorder mag worden, worden de producten waarvan geen voorraad is verwijderd uit de order Order verplaatsen (en evt splitsen) naar ander magazijn als dit ingesteld staat bij de supplier. Zie Verzenden vanuit meerdere magazijnen. Producten in backorder splitsen naar aparte order als dit ingesteld staat bij de supplier. De aparte order op verzonden (dropship) zetten als dit ingesteld staat bij de supplier. Order verplaatsen of splitsen naar magazijn met voorraad. Zie Verzenden vanuit meerdere magazijnen. Voorraad omboeken vanaf de wholesaler Backorders splitsen: per kanaal en order kan ingesteld worden of backorders gesplitst moeten worden. De backorder controle wordt uitgevoerd op de volgende momenten: Bij het verifiëren van een order Ongeveer 3 minuten nadat er nieuwe voorraad is ge-inbound van een product, worden alle backorders van dat product gecontroleerd Elke paar uur worden alle backorders gecontroleerd Voorraadreserveringen De voorraadreserveringen zorgen ervoor dat orders in de juiste volgorde verstuurd worden als ze deels in backorder zijn. Bijvoorbeeld: producten A en B hebben beide 1 stuks voorraad order 1 wordt geplaatst met 1x product A en 2x product B. Dus de order komt in backorder. order 2 wordt geplaatst met 1x product A. Deze order zou verstuurd kunnen worden omdat product A op voorraad is. Echter wordt de voorraad gereserveerd voor order 1. Bij een backorder op Montaportal is te zien welke voorraadreserveringen ervoor zorgen dat de order in backorder blijft staan. Het is ook mogelijk om een order te prioriteren. Zodat die toch verstuurd wordt ondanks dat een andere order de voorraad reserveert. Dit vanuit de lijst met reserveringen bij het gereserveerde product. Na het prioriteren zou de order binnen 5 minuten uit backorder moeten komen. Voorraadallocatie Het is ook mogelijk om voorraad te reserveren zonder order. Dit kan door het maken van een voorraadallocatie. Met een voorraadallocatie is het ook mogelijk om voorraad beschikbaar te maken voor een specifiek kanaal. Door bij het aanmaken van de voorraadallocatie aan te geven dat één of meer kanalen de gealloceerde voorraad wél mogen gebruikt. Let op: om dit invloed te laten hebben op de voorraad die wordt doorgegeven in een voorraadkoppeling, moet het kanaal ook nog ingesteld worden in de voorraadkoppeling (full- en changed stock update). Een voorraadallocaties kan ook gebruikt worden om een deel van de voorraad beschikbaar te maken voor een retailer. Zie wholesale. Verzenden vanuit meerdere magazijnen Voorraad van een klant kan in meerdere magazijnen worden opgeslagen. Het is ook mogelijk om vanuit meerdere magazijnen orders te verzenden. Hiervoor zijn twee opties die ingeschakeld kunnen worden bij een klant: Orders omzetten naar magazijn waar de voorraad is Orders splitsen naar magazijn waar de voorraad is Bij optie 1 wordt de order bij elkaar gehouden. Bij optie 2 wordt de order gesplitst als producten in de order in verschillende magazijnen liggen. Bij het controleren in welke magazijnen voorraad is wordt transit voorraad ook meegeteld. Omdat die snel beschikbaar komt. Het is ook mogelijk om bij een leverancier in te stellen dat de orders worden omgezet naar een specifiek magazijn. Om vanuit een magazijn te kunnen verzenden moet er een kanaal gemaakt zijn. Het omzetten/splitsen wordt uitgevoerd bij de backorder controle. Geplande verzenddatum Een order die beschikbaar is om te verzenden krijgt een geplande verzenddatum toegewezen. Dit is het moment waarop de order uiterlijk verwerkt moet zijn. Als start datum-tijd wordt gebruikt de datum dat de order is aangemaakt/binnengekomen in het systeem, dat deze uit backorder is gekomen of is gedeblokkeerd. Er kan ook een 'gewenste afleverdatum' worden meegeven in de order. Die wordt dan omgerekend naar een verzenddatum en gebruikt als start datum-tijd. Dan wordt gekeken of de order nog voor de cutofftijd is binnengekomen. Zo ja, dan moet de order op de startdatum verwerkt worden, zo niet een dag later. Voor B2c en B2b orders kan een aparte cutofftijd worden ingesteld. Als er extra verzenddagen staan ingesteld, wordt dit aantal dagen er bij op geteld. Extra verzenddagen kunnen meegegeven worden in de order vanuit de koppeling en/of ingesteld zijn bij het kanaal. Als beide het geval zijn, wint de waarde die is meegegeven in de order. Zie verder Koppelingen - verzender keuze importeren. Het tijdstip van de geplande verzenddatum is de afhaaltijd van de verzender. Als de afhaaltijd is verstreken en de verzender heeft het vinkje 'niet gebruiken na afhaaltijd' dan wordt een alternatieve verzender ingesteld. Feestdagen Monta houd rekening met dagen waarop niet gewerkt wordt. Orders krijgen dan een geplande verzenddatum van een dag later. IT kan feestdagen toevoegen. [[Doelgroep IT De feestdagen staan in tabel tblShipperAdditionalTransitTimeNationalHoliday. ]] Etransit (uitgestelde verzending) De order kan een verzenddatum in de toekomst hebben. Als daarbij is aangegeven dat de order niet eerder verzonden mag worden, komt deze in een wachtstatus. Deze wachtstatus noemen we Etransit. Geplande verzenddatum vanuit de koppeling of Montaportal Het is ook mogelijk dat de geplande verzenddatum vanuit de koppeling wordt meegegeven. Ook kan de klant op de Montaportal bij een order een uitgestelde geplande verzenddatum invullen. Hiervoor zijn twee opties bij een kanaal: Altijd de geplande verzenddatum van de order gebruiken. Hiermee nemen we de geplande verzenddatum over die in de koppeling wordt meegegeven. Nadeel is dat de klant een geplande verzenddatum kan meegeven die niet realistisch is waardoor we overdues krijgen waar we niets aan kunnen doen. De geplande verzenddatum van de order gebruiken als deze later is dan de geplande verzenddatum door ons berekend. Hiermee nemen we de geplande verzenddatum over die in de koppeling wordt meegegeven, alleen als die later is dan de geplande verzenddatum die we zelf zouden uitrekenen. Dit voorkomt dus dat er een onrealistische geplande verzenddatum wordt meegegeven in de order. De tweede optie kan ook bij individuele orders worden ingeschakeld. Dit wordt gebruikt als de klant op de Montaportal bij een order een geplande verzenddatum in de toekomst invult. Picken Picken is het ophalen van de producten voor een order uit het magazijn. Dit kan op de volgende manieren: Met de scanner Met een pick-to-light stelling Individuele pickbon voor order Pickbon voor meerdere orders Bij het verifiëren van een order kiest het systeem van welke locaties een order gepickt moet worden. Locatie keuze Als een product in een order op meerdere locaties ligt wordt als volgt de locatie gekozen. Als het een Food product betreft wordt de locatie met de eerste verstrijkende THT gekozen. Dan wordt er gekeken of er locaties zijn waarop meerdere orderregels gepickt kunnen worden. Deze locaties worden eerst gekozen over de andere locaties. Vervolgens wordt e​​erst van handmatig bereikbare locaties afgeboekt. Vervolgens wordt eerst van de locaties met de kleinste voorraad afgeboekt (zodat je die eerst leeg maakt). Tenzij de order in één keer gepickt kan worden van een grote locatie, dan wordt die gekozen om het aantal picks laag te houden. Er is een uitzondering voor pick-to-light: als één van de producten in een pick-to-light stelling ligt wordt geprobeerd alleen locaties in de pick to light stelling te kiezen (zodat de hele order in pick to light komt). Dit wint van kleinste locatie, maar niet van THT. Dus als ergens in het magazijn een oudere batch ligt komt de order niet op de pick to light.​ Er is een uitzondering voor meerdere verdiepingen: als producten in een order op meerdere verdiepingen liggen, dan wordt geprobeerd de order op één verdieping te picken. Dit wint niet van handmatig bereikbaar, maar wel van locaties met de minste voorraad. Er kan ook bij een klant, op kanaalniveau, in GoMonta een afwijkende pickvoorkeur opgegeven worden. Hier kan gekozen worden voor de volgende opties: FIFO: Dan krijgt niet eerst de handmatige locatie en de locatie met de minste voorraad de voorkeur, maar de locatie waar voorraad op staat die het langst geleden is geinbound. Dit wint ook van batch/tht bij food producten. LET OP: als voorraad die later is geinbound wordt bijgeplaatst op een locatie met voorraad die eerder is geinbound, wordt vanaf dat moment de latere inbounddatum aangehouden. Dit geld ook inbounds vanuit retouren. Bulk: Hierdoor krijgt altijd de locatie met genoeg voorraad de voorkeur, ongeacht bereikbaarheid, THT datum of batch. Als een normale locatie dus niet genoeg voorraad heeft krijgt de bulklocatie/grote locatie de voorkeur. Op deze manier blijft het aantal picks laag en hoeven er minder locaties bijgevuld te worden. Bulk dan FIFO: deze optie combineert de twee opties, door eerst te kijken naar de beschikbaarheid van producten en dan op tht-datum. Picken met de scanner Met de scanner kunnen de orders efficiënt en papierloos gepickt worden. Dit werkt als volgt: De orderpicker kiest een verdieping en pickstroom. Per verdieping in pickstroom zijn te zien hoeveel orders er vandaag nog gedaan moeten worden. De orderpicker scant een krat of kar. Er worden orders toegewezen. Zie volgorde van orders picken voor meer informatie hierover. De scanner geeft aan naar welke locatie de orderpicker moet gaan en hoeveel producten daar gepakt moeten worden. Zie voorraadbeheer - looproute voor meer informatie over de volgorde waarin van de locaties gepickt moet worden. De orderpicker scant de barcode van het product ter bevestiging. Zie pickactie bevestigen voor meer informatie hierover. Als meerdere orders tegelijk gepickt worden met meerdere kratten op een kar, wordt aangegeven hoeveel producten er in welke krat gelegd moeten worden. Ter bevestiging moet de krat gescand worden. Als alle producten gepickt zijn is de pickronde klaar. Afhankelijk van de pickstroom moeten de gepickte orders afgeleverd worden bij de Echeck, Put-to-light of Echeck wall. Pickstromen In een pickstroom worden orders verzameld die op een bepaalde manier gepickt moeten worden. S (Bulk) HM (Bulk) M LM L Pallets BulkXL (In development) (Bulk) In bovenstaande afbeelding representeert het fruit het aantal orderlines in een order. S orders Orders die bestaan uit één item van één product (en evt echeck toevoegproducten). Het maakt niet uit hoe groot het product is. Er kunnen meerdere S orders van verschillende producten in bulk gepickt worden in een grote krat. Bij de Echeck kan een willekeurig product uit de krat gepakt worden om te versturen. Omdat S orders het meeste efficiënt verwerkt kunnen worden zijn er mogelijkheden om meer S orders te creeëren: Producten die in veel orders zitten kunnen bij de echeck gelegd worden zodat ze niet meegepickt hoeven te worden. Zie echeck toevoegproducten. Grote producten kunnen afgesplitst worden naar aparte orders. Zie Afsplitsen grote producten. HM orders Orders die bestaan uit meer dan één item van één product (en evt echeck toevoegproducten). Er kunnen meerdere orders tegelijk in bulk gepickt worden in een grote krat. Hierbij kunnen ook S orders van dat product meegepickt worden. Bij de echeck kan een willekeurig product uit de krat gepakt worden om te versturen. De Echeck geeft dan aan hoeveel producten er nog bij gepakt moeten worden. M orders Orders die bestaan uit meerdere producten. Ze kunnen op de volgende manieren gepickt worden. Meerdere tegelijk in een pickronde met meerdere kratten op een kar Meerdere tegelijk in één krat en daarna uitsorteren met Put-to-light Meerdere tegelijk in één krat en daarna uitsorteren met een Echeck wall Als een order te grote producten bevat, wordt deze LM of L order. Hiervoor worden bij het magazijn maximale afmetingen van een M order ingesteld. Het volume van de producten wordt ook gecontroleerd met het volume van de ingestelde afmetingen. LM orders Orders die bestaan uit meerdere producten waarvan een product groter is dan bepaalde afmetingen. Het proces verloopt verder hetzelfde als bij M orders. L orders Orders met grote of veel producten. Deze worden per order gepickt. Gelijksoortige orders Orders met dezelfde samenstelling van producten. Aangezien ze makkelijk uit te sorteren zijn kunnen ze ook in bulk gepickt en bij de echeck uitgesorteerd worden. Pallets picken De scanner bied de optie om hele pallets te picken. Orders komen beschikbaar voor pallet picken als: Alle orders die van de locatie gepickt moeten worden S, HM, HL orders zijn. Een locatie helemaal wordt leeg gepickt OF het aantal bestelde producten op de locatie is hoger dan de instelling \"Gedeeltelijke pallet drempelwaarde\", De locatie het type palletlocatie heeft, De locatie zich bevind in een pallet zone. B2B orders Er kan ingesteld worden dat orders per stuk gepickt kunnen worden door ze op de scanner te kiezen uit een lijst. Er kan ingesteld worden aan welke criteria een order moet voldoen om in deze pickstroom te komen. Dit kan op volume, aantal producten, aantal regels en alleen voor bepaalde klanten. BulkXL In deze pickstroom worden de verzendlabels geplakt tijdens het picken. Op deze manier wordt het picken en Echecken samengevoegd. Deze pickstroom is ingericht voor orders met grote artikelen (XL orders), met artikelen die zijn gemarkeerd als eigen verpakking drager. Zie voor meer informatie: BulkXL pickstroom. Pickstromen op basis van specifieke Hardware Bij het gebruik van specifieke hardware, zijn soms aparte pickstromen of filters mogelijk om maximaal gebruik te kunnen maken van deze hardware. Voorbeelden zijn sorteeroplossingen zoals Echeckwall, PutToLight en verpakkingsmachines zoals de Monta Pac-Man en de BVM machine. Echeckwall pickstroom en Echeckwall XL pickstroom Gedetailleerder info over de Echeckwall pickstroom is te vinden op deze pagina En de informatie over de Echeckwall XL pickstroom is te vinden op deze pagina. In grote lijnen vormen de Echeckwall en Echeckwall XL aparte pickstromen die bestaan naast de bestaande pickstromen. Put To Light pickstroom Gedetailleerder info over de Echeckwall pickstroom is te vinden op deze [pagina] Inpakmachines Monta Pac-man en BVM Om te picken specifiek voor de Monta Pac-man en de BVM machine zijn geen aparte pickstromen, maar het zijn meer filters over bestaande pickstromen. Meer details over picken voor de Monta Pac-man is te vinden op deze pagina. En meer informatie over picken voor de BVM machine is te vinden op deze pagina. Orders die niet via de scanner gepickt worden +Er zijn ook orders die niet via de scanner gepickt worden. Echeck only orders: zie Echeck toevoegproducten en evt de pagina Echeck only Prepack orders die al ingepakt zijn: zie Prepack. Filters Het is mogelijk om in de scanner te filteren om alleen bepaalde orders te picken. Dit kan op: Verzender Klant Runners Highcare Pick-to-light. Als backup voor als de pick-to-light stelling niet gebruikt kan worden. Highcare Orders met producten die van highcare locaties gepickt moeten worden kunnen gepickt worden met een optie in de scanner. Picken van niet handmatige locaties Standaard kan er niet gepickt worden van niet-handmatig bereikbare locaties. De voorraad moet eerst gereplenisht worden naar handmatig bereikbare locaties om de orders te kunnen picken. Zie Voorraadbeheer - niet handmatig bereikbaar. Bij de instellingen van het magazijn kan ingeschakeld worden dat er gepickt mag worden van niet-handmatige locaties. Er hoeft dan niet ge-replenisht te worden om orders te versturen die van niet-handmatige bereikbare locaties gepickt moeten worden. Als dit ingeschakeld is kunnen de order gepickt worden met een optie in de scanner. Er kan ook ingesteld worden dat de niet-handmatig bereikbare orders mee-gepickt worden met de handmatig bereikbare orders. Pickactie bevestigen Om een pickactie te bevestigen moet de barcode van het product gescand worden. Bij sommige producten is dit niet mogelijk. Hiervoor kan bij een product ingesteld worden dat een pickacties bevestigd kan worden door de locatie te scannen. Er kan ook bij de klant ingesteld worden dat alle producten gepickt mogen worden door de locatie te scannen. Als een product niet gescand kan worden, of als er niet voldoende aanwezig is, moet een joker gemaakt worden. Zie Jokers voor meer informatie. Bevestiging lege locatie Het is mogelijk dat bij het leegpicken van een locatie om een bevestiging gevraagd wordt of de locatie inderdaad leeg is. Dit kan ingesteld worden bij de instellingen van het magazijn. Er kan ingesteld worden dat een notificatie gestuurd wordt als de orderpicker aangeeft dat de locatie leeg is, terwijl er administratief nog voorraad op staat. Er wordt geen cycle count gemaakt oid, het sturen van de notificatie is het enige wat er mee gedaan wordt. Volgorde van orders picken Het picken via de scanner start met het kiezen van een verdieping en pickstroom. Het kan zijn dat er bij een verdieping en pickstroom meer orders open staan dan in één pickronde gepickt kunnen worden. Het systeem maakt dan een keuze welke orders als eerste gepickt worden. In GoMonta kan ingesteld worden welke volgorde hierbij wordt gehanteerd. In de verschillende volgordes kunnen de volgende facturen worden meegenomen. Afhankelijk van de ingestelde volgorde heeft de ene of de andere factor meer invloed. Geplande verzenddatum: de geplande verzenddatum van de order geeft aan wanneer deze uiterlijk verwerkt moet zijn. Dichtsbijzijnde locatie: orders die dicht bij elkaar liggen eerst picken. Dit zorgt voor korte pickrondes Kanaal pickvolgorde: per kanaal kan een prio voor picken worden ingesteld. Aantal orders van een klant: de orders van klanten waarvoor de meeste orders open staan worden eerste gepickt. In pickproces gekomen datum en tijd: om de orders die het langste open staan als eerste te picken. Pickkratten Bij het picken wordt een krat gescand waarmee artikelen door het magazijn verplaatst kunnen worden en waarmee het systeem deze kan herkennen. Op deze manier blijven de orders toegewezen aan die krat altijd traceerbaar. De Pick kratten worden gebruikt om individuele orders te lopen. Afhankelijk van het type orders en de afmetingen van de artikelen kan Monta® adviseren in het aantal en type kratten die de klant kan aanschaffen. Pickkarren In het monta systeem kan je werken met drie verschillende pickkarren: Bulkpickkar (Krat) Multi order kar Vaste krat Multi order kar* Deze karren worden gebruikt voor het verwerken van bulkPickroutes als bijvoorbeeld de S-orders. Dit is een kar waarop de bovenstaande kratten kunnen worden geplaatst. Deze karren worden gebruikt voor het verwerken van Multi order pickroutes als de M-orders. Dit zijn karren waarbij de kratten/ kratcodes vastzitten op de karlocaties. Nadere toelichting Vaste krat Multi order kar* Er zijn situaties waarbij de kratjes vast op de Multi order kar zitten. Bijvoorbeeld als er heel veel kratjes op de Multi order kar zijn, of bijvoorbeeld bij afwijkende Multi order karren zoals bij vloerbedekking picks. Als het voor de logistieke operatie niet bezwaarlijk is de hele kar bij de Echeck neer te zetten voor het Echecken van orders, dan is een Vaste krat Multi order kar een mogelijkheid. Door de kratten fysiek vast te zetten op de kar kunnen we er zeker van zijn dat de kratjes altijd bij de kar blijven. Vervolgens kan worden ingesteld welke kratbarcodes bij welke kar positie barcodes horen. Dan zal bij het starten van een pickronde de vraag om kratjes te koppelen aan karlocaties worden overgeslagen. Voordelen: Het koppelen van kratjes aan karlocaties is niet meer nodig, dit scheelt tijd Nadelen: Er zijn totaal gezien iets meer pickkarren nodig, omdat de kar pas opnieuw voor picken gebruikt kan worden als het Echecken klaar is. Als er een joker is op een van de kratjes, is alleen dat kratje niet langer beschikbaar voor nieuwe picks. Dit blokkeert dus niet de andere kratjes op de pickkar. Vooralsnog is er geen scherm voor het configureren van de Vaste krat Multi order kar. Zo lang kan een mailtje worden gestuurd naar techniek@monta.nl met een daarin de karlocatiecodes en de kratbarcodes die aan elkaar gekoppeld kunnen worden. Onderstaand enkele mogelijke toepassingen: Pick-to-light Een pick-to-light is een stelling waarbij elke locatie is voorzien van een klein display. Hierbij geeft het display aan hoeveel producten er gepickt moeten worden. Pick to light is handig voor kleine producten waarvan er veel in een stelling kunnen. Voor meer informatie zie Apparaten - Pick to light. Runner orders Orders kunnen als runner gemarkeerd worden. Dit betekend dat ze snel verwerkt moeten worden. De runner orders moeten apart gepickt worden, zodat hier een medewerker op gezet kan worden. Orders kunnen op de volgende manier runner worden: Specifieke orders kunnen in GoMonta als runner gemarkeerd worden. Er kan ingesteld worden dat orders die x minuten voor de afhaaltijd binnenkomen automatisch runner worden. Bulkpicken Bij bepaalde pickstromen is het mogelijk meerdere orders tegelijk te picken. Zie pickstromen voor meer informatie. Alleen orders met dezelfde geplande verzenddatum komen in een bulkpick. Hierbij kunnen wel orders van verschillende afhaaltijden in één bulkpick komen. Met een instelling in GoMonta kan dit voorkomen worden, evt een x aantal minuten voor de afhaaltijd. Put-to-light en echeck wall Met Put-to-light en een echeck wall kunnen in bulk gepickte producten uitgesorteerd worden naar individuele orders. Voor meer informatie zie Apparaten - Put to light en Apparaten - Echeck wall. Echeck Bij de echeck (inpakstation) gebeurd het volgende. Een order wordt geopend door een krat te scannen waar orders op gepickt zijn of een papieren pickbon te scannen. De producten worden gescand om te controleren dat de order compleet is. Aantikken/klikken ipv scannen is ook mogelijk: zie Product aanklikken ipv scannen De dragers (verpakkingsmateriaal / dozen) worden gescand. Hierbij wordt ook bijgehouden welk product in welke collo gaat. De verzender wordt opnieuw bepaald omdat de afmetingen en gewichten van de colli definitief bekend zijn. Zie verzender keuze voor meer informatie hierover. Het verzendlabel wordt geprint. Eventuele extra dingen worden geprint (pakbon, retourlabel, etc). Als er iets mis gaat wordt de order een Joker. Dragers Bij het echecken van een order moet ook een drager (doos) gescand worden. Bij het kanaal van de order staat ingesteld welke dragers mogelijk zijn. Door elke doos te scannen wordt aangegeven uit hoeveel colli de order bestaat. Een drager heeft afmetingen en gewicht ingesteld. Hiermee wordt per collo het definitieve gewicht en de afmetingen van de order bepaald. Dit wordt weer gebruikt om de juiste verzender te kiezen. Het magazijn kan in GoMonta dragers toevoegen en de eigenschappen van dragers aanpassen. Past door de brievenbus De afmetingen van de drager zijn leidend voor de afmetingen van de colli. Deze afmetingen bepalen of een order door de brievenbus kan. Als een order door de brievenbus kan, zorgt dit voor lagere verzendkosten. Omdat niet altijd automatisch te bepalen is of alle colli van een zending wel of niet door de brievenbus passen, wordt dit gevraagd bij de echeck. De vraag wordt alleen gesteld als het nodig is: Als bij de drager van alle colli het vinkje 'Is flexibele drager' staat uitgeschakeld, wordt de vraag niet gesteld. De check kan dan bepalen a.h.v. de maten van de drager of het door de brievenbus past of niet. Als bij de drager van alle colli het vinkje 'Is flexibele drager' staat ingeschakeld, wordt naar de inhoud van de drager gekeken (productmaten). Als er maar één product in de drager zit, kan de maat van dat product gebruikt worden om te bepalen of een drager door de brievenbus past. Als er meerdere producten in een drager zitten, kan dit niet betrouwbaar berekend worden. de echeck zal dit dan vragen middels een dialoog venster. Zie ook Verzender keuze - mogelijke verzenders. Bij een kanaal kan ook ingesteld worden dat als een order uit één product bestaat (S order) én het product past door de brievenbus, het verplicht is om een drager te kiezen die door de brievenbus past. Zodat zoveel mogelijk geprofiteerd wordt van de lagere verzendkosten voor buspost. Voorraadbeheer Bij een drager kan ingesteld worden dat éen of meerdere producten afgeboekt moeten worden als een drager gescand wordt. De voorraadafboeking van de drager wordt toegevoegd aan de pickbon van de order. Zodat als de pickbon van de order wordt teruggeboekt (bijvoorbeeld bij het annuleren van een order), de drager ook weer wordt teruggeboekt op voorraad. Dragerlocaties per Echeck station Bij een Echeck station moet ingesteld worden van welke dragerlocaties voorraad afgeboekt moet worden als er een order verwerkt wordt. Na het scannen van een drager tijdens het Echecken zal gecontroleerd of er op de betreffende dragerlocaties voorraad beschikbaar is. Dit heeft twee mogelijke resultaten: Er is voorraad van de gescande drager op een gekoppelde drager locatie De drager kan gebruikt worden en wordt afgeboekt van de gekoppelde drager locatie met de laagste voorraad Er is geen voorraad van de gescande drager op een gekoppelde drager locatie Na het scannen van de drager wordt er een melding getoond dat de gescande drager niet op voorraad is op aan het Echeck station gekoppelde dragerlocaties Instellingen In GoMonta moet bij een Echeck station ingesteld worden welke dragerlocaties bij dat Echeck station horen. Dit kan door naar “Admin Dashboard” te gaan, vervolgens kan het gewenste Echeck station op te zoeken en kunnen de locaties toegevoegd worden. Selecteer het juiste magazijn Zoek het gewenste Echeck station op Bewerk het gewenste Echeck station Voeg de gewenste dragerlocaties toe Per magazijn kan dit in- en uitgeschakeld worden door een Toggle-feature, neem contact met servicedesk om dit in te schakelen. Pallets Een pallet is een speciaal type drager die ook gescand kan worden bij de echeck. Op een pallet worden geen producten geplaats, maar andere dragers. Op die manier wordt bijgehouden welke producten in welke doos zitten en welke doos op welke pallet staat. Of een order pallet dragers heeft is ook van invloed op de verzender die gekozen wordt. Pakbon Bij het echecken van de order wordt een pakbon gegenereerd en opgeslagen bij de order. Als dit bij het kanaal staat ingeschakeld wordt de pakbon ook uitgeprint. Het is ook mogelijk om een pakbon per doos en per pallet te maken. Dit kan ingeschakeld worden in het echeck scherm. Dooslabels Het is ook mogelijk om aan het eind van het echecken automatisch dooslabels te laten printen met de tekst \"Doos 1 van 20\". Dit kan ingeschakeld worden bij het kanaal. Echeck toevoegproducten Producten die in veel orders voorkomen kunnen bij de echeck gelegd worden. Ze hoeven dan niet gepickt te worden waardoor meer S en HM orders ontstaan die efficiënter (in bulk) gepickt kunnen worden. Zie Voorraadbeheer - Echeck locaties. Als producten op echeck locaties worden gelegd, kan het ook gebeuren dat er orders komen van producten die alleen op echeck locaties liggen. Deze hoeven dan niet via de scanner gepickt te worden. We noemen dit 'echeck only' orders. Op het hoofdscherm van de echeck staat een knop waarmee deze orders te vinden zijn. De knop gaat knipperen als er 'echeck only' orders beschikbaar zijn. Echeck Only Op dit concept van 'Echeck only' is een concept gebaseerd dat het voor klanten met weinig SKUs en redelijk veel orders mogelijk maakt om alle producten op Echecklocaties te leggen, waardoor de hele stap van orderpicken wordt overgeslagen. Dit concept kan leiden tot hoge productiviteit, omdat een complete processtap wordt overgeslagen. Een 'echeck only' order wordt gestart in het Echeck scherm, de producten worden gepakt vanuit een 'echeck only' locatie en gescand, waarbij de scan direct de echeck scan is. Voorbeelden van 'echeck only' zijn hier te vinden; Echeck only. Surprise pack Bij een order kunnen extra inpakopties meegegeven worden. Bijvoorbeeld \"inpakken in Kerst inpakpapier\" of een persoonlijke tekst op een kaartje. Monta breed zijn een aantal inpakopties gedefinieerd [[Doelgroep IT (in tblSurprisePackTypen)]]. Zo'n optie kan per kanaal beschikbaar worden gemaakt en hierbij kunnen een instructie en een code ingesteld worden. Per optie wordt ook het tarief ingesteld in de verkooptarieven. De surprise pack optie kan op twee manieren bij een order meegegeven worden: Vanuit de koppeling. Aan de hand van de code die bij het kanaal bij de surprise pack optie staat ingesteld. Bij het kanaal kan ook ingesteld worden dat een surprise pack optie aan alle orders toegevoegd moet worden. Bij het meegeven van de surprise pack optie kan ook een tekst meegegeven worden. Dit is dan bijvoorbeeld de persoonlijk tekst die op een kaartje geprint moet worden. De surprise pack bij een order kan ook aan een specifieke orderregel gekoppeld worden. Voor het geval er bijv. twee dezelfde parfumfles één in cadeaupapier voor mannen en één in cadeaupapier voor vrouwen ingepakt moet worden. Als een order met surprise pack geopend wordt in de Echeck, wordt een label geprint met de instructie en de tekst. Voordat het verzendlabel geprint wordt, wordt nog een popup getoond met de waarschuwing dat het een surprise pack order betreft. Deze melding moet weggeklikt worden, pas dan worden de verzendlabels geprint. Tekst printen op kaartje De surprise pack tekst kan op een kaartje geprint worden met inpakoptie \"Tekst op kaartje op Echeck documentprinter\". Als deze optie gekozen is bij een order, wordt bij het echecken een melding getoond dat het kaartje in de printer gelegd moet worden. Dit moet in de 'manuele invoer' van de printer. De printer pakt deze automatisch ipv de papierlade als er iets in ligt. Als op OK geklikt wordt, wordt de tekst op het kaartje geprint. Hiervoor moet bij het kanaal een Word template ingesteld staan waarvan de bestandsnaam begint met: \"SurprisePack\". Het template moet in A4 zijn. Als het kaartje kleiner is, moet dit verticaal in het midden bovenaan geplaatst worden. Zie plaatje hieronder. Retourlabel meesturen Zie Retouren - Retour label. Bulk echecken Als bij de echeck een krat gescand wordt waar meerdere orders op gepickt zijn (zie bulkpicken), worden drie lijstjes getoond: orders nog te echecken, orders ge-echeckt en orders die joker zijn. Er kan een willekeurig product uit de krat gepakt en gescand worden. Het systeem zoekt dan een order uit het lijstje nog te echecken en opent het scherm om deze order te echecken. Fastlane Bij bulk echecken is er de mogelijkheid om de verzendlabels van alle orders in één keer te printen. Dit kan als voldaan is aan de volgende voorwaarden. Alle orders moeten dezelfde samenstelling hebben De gebruiker moet shiftleader zijn Het moet ingeschakeld staat voor het echeck station Skip echeck In de echeck app is ook een optie om het echecken over te slaan. Dan hoeft alleen het aantal dozen ingevuld te worden. Hoe stel je deze optie in? Samenstelling gesplitste producten De echeck heeft ook de optie om te laten zien welke producten bij elkaar horen vanuit de splits en toevoegproducten. Product aanklikken ipv scannen Er is ook de mogelijkheid dat producten aangetikt kunnen worden ipv gescand om ze te echecken. Dit kan voor alle producten ingeschakeld worder door bij de klant de instelling in te schakelen dat alle producten gepickt moeten worden door de locatie te scannen. Het is ook mogelijk om dit voor specifieke producten in te stellen. Dan moet er per product ingesteld worden dat een product aan te klikken is in de echeck. Dit is ook te doen via de product import. De naam van het veld is hier \"IsClickableInEcheck\". Serienummer registratie Het is mogelijk om bij een product in te stellen dat bij het echecken om een serienummer gevraagd wordt. Bij het scannen van een serienummer mogen niet de SKU of de barcodes gescand worden. De klant kan een lijst uploaden met toegestane serienummers, om te voorkomen dat het verkeerde wordt gescand als serienummer. Jokers Worden gemaakt als er iets mis gaat bij het picken of echecken. Zie Jokers. Prepack Met prepack kunnen gepickte en ingepakte orders vastgehouden worden voor verzenden. Een order kan op vier manier gemarkeerd worden als prepack: Per order met een knop in GoMonta Alle orders van een bepaald afleveradres via het adresboek op de Montaportal. Per order in Montaportal Via de REST Api in de Order endpoint Als een order gemarkeerd is als prepack wordt er geen verzendlabel geprint maar een prepacklabel. Op Montaportal moet de order vrijgegeven worden voor verzending. Hierbij moet ook een datum aangegeven worden. Op deze datum wordt de order zichtbaar onder de knop 'Prepack' in het echeck hoofdscherm en kan het verzendlabel geprint worden. Als een Etransit order wordt gemarkeerd als een Prepack order dan wordt de order van Etransit afgehaald. De originele Etransit datum kan teruggevonden worden in de logs van de order. Verzenden Bij de echeck wordt het verzendlabel van de order geprint. Verzender keuze Op twee momenten in het proces wordt voor een order een verzender gekozen. Bij het verifiëren en bij het echecken. De keuze die bij het verifiëren wordt gemaakt is een inschatting. De definitieve afmetingen en gewicht van de colli zijn namelijk pas bekend na het kiezen van de drages bij de echeck. Het kiezen van een verzender bestaat uit twee stappen. Eerst wordt bepaald welke verzenders mogelijk zijn Uit de mogelijke verzenders wordt de voorkeursverzender gekozen. Hieronder worden deze stappen verder uitgelegd. Bij een order wordt in een attachment beschreven hoe de keuze voor een verzender tot stand is gekomen. 1. Mogelijke verzenders De volgende controles worden gedaan om te bepalen of een verzender mogelijk is voor een order. Mag een verzender automatisch gekozen worden. Een verzender heeft de eigenschap of deze automatisch gekozen mag worden. Dit kan ook per verzender per klant ingesteld worden. Als de verzender deze eigenschap heeft, zal de verzender niet gekozen worden voor de order als dit niet expliciet is aangegeven vanuit de koppeling of op Montaportal. Keuze vanuit de koppeling/Montaportal. Het kan dat de consument in de webshop al een verzender heeft gekozen. Of dat in de Montaportal bij de order een verzender is aangegeven. Andere verzenders mogen dan niet gekozen worden. Mag een eenmaal gekozen verzender worden aangepast. Bepaalde verzenders (zoals pickup points) mogen niet meer aangepast worden als ze eenmaal gekozen zijn. Minimale verzekerde waarde. Bij een order kan een minimale verzekerde waarde ingesteld worden. Alleen de verzenders die dit kunnen bieden zijn dan mogelijk. Past door brievenbus. Een buspost verzender is alleen mogelijk als de zending door de brievenbus past. Dit wordt als volgt gecontroleerd: van alle dragers wordt gecontroleerd of ze wel of niet flexibel zijn, een drager zoals een zak wordt als flexibel gezien, een doos niet is een drager flexibel dan worden alle producten gecontroleerd of de afmetingen binnen de buspost afmetingen vallen [drager wordt niet gecontroleerd] is een drager niet flexibel dan wordt de drager gecontroleerd of het binnen de buspost afmetingen valt [producten worden niet gecontroleerd] bij geen van de gekozen dragers mag het vinkje 'past nooit door de brievenbus' ingeschakeld staan bij de echeck mag niet op \"nee\" geklikt zijn bij de vraag \"past het door de brievenbus?\". Zie Echeck - past door de brievenbus. Max afmetingen. Een verzender kan maximale afmetingen hebben. Alle dragers en producten in de order moeten binnen deze afmetingen vallen. Een product kan afwijkende afmetingen hebben speciaal voor de verzending. Bijvoorbeeld een hondenmand die uitgevouwen op voorraad ligt, maar opgevouwen kan worden voor de verzending. Max volume. Een verzender kan een maximaal volume hebben. Het volume van elke collo moet binnen dit volume vallen. In de shipping matrix (dus per kanaal) kan ook per verzender per land een max volume ingesteld zijn. Max gewicht. Een verzender kan een maximaal gewicht hebben. Het gewicht van alle collo en producten moet hier binnen vallen. Bij de mogelijke verzenders van een kanaal kan ook een maximaal gewicht ingesteld zijn. Max lengte. Bij de mogelijke verzenders van een kanaal kan ook een maximale lengte ingesteld zijn. Min gewicht. Een verzender kan een minimaal gewicht hebben. De collo moet dan zwaarder zijn. Max omvang (2xH + 2xB + 1xL). Een verzender kan een maximale omvang hebben. Alle collo en producten moeten dan binnen deze omvang vallen. Pallets. Als de order pallets heeft mag alleen met een pallet verzender verzonden worden. Als een order geen pallets heeft, mag niet met een palletverzender verzonden worden. Postbus. Verzenden naar postbussen is alleen mogelijk met PostNL. Mogelijke landen. Per verzender staat ingesteld welke landen mogelijk zijn. Big/small. Van sommige verzender is er een grotere variant: de maximale afmetingen en/of gewicht zijn groter, maar de verzending is ook duurder. Deze grotere variant is alleen mogelijk als de kleine variant niet mogelijk is. 2. Voorkeursverzender kiezen Uit de mogelijke verzenders wordt een voorkeursverzender gekozen. Het kiezen van een voorkeursverzender gaat met de volgende stappen. De volgorde is hierbij van belang. Shipper per materiaal. Er kan ingesteld worden dat bepaalde producten met een bepaalde verzender verzonden moeten worden. Als dit ingesteld staat voor een product in de order, krijgt die verzender de voorkeur. Niet gebruiken na afhaaltijd. Bij een verzender bij een kanaal kan ingesteld worden dat de verzender niet gebruikt moet worden na de afhaaltijd. Zodat een andere verzender die nog wel afhaalt de voorkeur krijgt, zodat de order dezelfde dag nog verstuurd kan worden. Dit kan er dus voor zorgen dat een order die wel door de brievenbus past, toch met pakketpost verstuurd wordt, omdat de afhaaltijd van buspost al is verstreken. Niet gebruiken bij geen levering volgende werkdag. Bij een verzender bij een kanaal kan ingesteld worden dat de verzender niet de voorkeur moet krijgen als deze niet de volgende dag levert. Wordt vaak gebruikt om op vrijdag een andere verzender te kiezen als de voorkeursverzender niet op zaterdag levert. Of er de volgende dag geleverd kan worden met een bepaalde verzender, wordt uitgerekend met de Afleverdag berekening. Buspost. Buspost verzenders krijgen de voorkeur omdat die goedkoper zijn. Shipping matrix. Per kanaal kan ingesteld worden welke verzender de voorkeur heeft voor een land. Deze instelling kan anders zijn voor B2b en B2c orders. Default shipper. Per kanaal staat een standaard verzender ingesteld. Verzenders Voor elke verzender die is aangesloten is een subpagina met informatie over die verzender. Zie de pagina Verzenders voor een lijst met de verzenders die zijn aangesloten. Verzender opties Extra opties zoals 'niet bij de buren leveren'. Verzender opties kunnen als volgt worden toegevoegd bij een order: Vanuit de koppeling Door bij een kanaal in te stellen dat een shipper optie bij alle orders moet worden toegevoegd, of bij orders die voldoen aan bepaalde voorwaarden. Verzekerd verzenden Bij een order kan een verzekerd bedrag ingesteld worden. Het systeem kiest dan een verzender die voor dit bedrag verzekerd kan verzenden. Gevaarlijke goederen Bij het verifiëren van een order wordt gekeken of een product in de order gemarkeerd staat als 'dangerous good'. Als ook het vinkje 'dangerous goods doorgeven aan verzender' staat ingeschakeld, dan wordt de PostNL shipper optie 'ADR' toegevoegd aan de order. Meer toelichting: Wat is een ‘dangerous good’? Dangerous goods zijn goederen met o.a. een GHS label of UN number. Het komt op uiteenlopende producten voor, bijvoorbeeld schoonmaakartikelen en powerbanks. Binnen Monta moeten de gegevens van gevaarlijke goederen geregistreerd gaan worden. Daarvoor zijn de volgende wijzigingen in onze applicaties gemaakt: Inbound In de inbound is een knopje ‘dangerous product’ gemaakt. Dit knopje kan ingeschakeld worden als de inboundmedewerker een gevaarlijk product aan het inbounden is (product met GHS-label of UN-number). De medewerker hoeft hierbij geen details op te geven, deze knop is bedoeld om aan te geven dat een product gevaarlijk is. Vervolgens moeten de details in een ander proces opgegeven worden (verderop meer hierover). Overigens zal de klant (koppeling van webshop) in de meeste gevallen ervoor zorgen dat een gevaarlijk product al gemarkeerd wordt voordat het geleverd wordt. Dit knopje zal dan al aan staan bij het inbounden. Als een product eenmaal als gevaarlijk gemarkeerd is, kan de markeren niet meer via de inbound eraf gehaald worden. Montaportal Op de product detail pagina van Montaportal is een nieuw knopje beschikbaar wanneer een product als gevaarlijk gemarkeerd is. Ook is er een melding zichtbaar wanneer het systeem detecteert dat gegevens missen. Wanneer er op ‘details’ geklikt wordt, opent een venster waarin de gegevens van het product ingevoerd kunnen worden. De gegevens kunnen overgenomen worden van het product, of van de Safety Data Sheet (SDS) welke eveneens opgegeven moet worden. De ingevoerde gegevens zijn goed wanneer: GHS label opgegeven is -of- UN-number Maar het natuurlijk ook mogelijk om alle velden in te vullen. Echter, meestal bevat een product slechts één van de classificaties. GoMonta Voor de vestigingen is in GoMonta een export functionaliteit toegevoegd om inzicht te geven in de gevaarlijke goederen in een magazijn. Allereerste zal het opvallen dat er een nieuw Montamannetje zichtbaar is in GoMonta. Dit mannatje zal op de homepage tevoorschijn komen wanneer er in het magazijn materialen liggen met ontbrekende gegevens. Door op de tekstwolk te klikken zal er een export gedownload worden. De export is ook te downloaden door te navigeren naar ‘Voorraadbeheer => Materialen => knopje opties => Export Dangerous Goods’. In de export zijn diverse gegevens van dangerous goods te zien: Materiaal gegevens Locaties waar de materialen liggen + type locatie + voorraad/totaal gewicht/totaal volume op locatie GHS, SDS, ADR, Packing Group en UN-number gegevens Mateiralen met ontbrekende gegevens zijn rood gemarkeerd. Order afleverstatus Met veel verzenders is er een koppeling om de status van de verzending te importeren als orderstatus. Zie order statussen. Elke verzender heeft een eigen lijst van statussen. Elke status van een verzender is gekoppeld aan een order status. Er zijn twee soorten koppelingen voor de statuskoppeling. De verzender kan de status naar Monta sturen en Monta kan de status ophalen bij de verzender. Bij tweede type (Monta haalt de status op bij de verzender) moeten we voorkomen dat we eindelijk de statussen van een order blijven opvragen. Daarom stoppen we met het ophalen als we de status DeliveryFailed, Delivered of Collected hebben opgehaald. Soms blijft een order hangen in de EnRoute of AvailablePickup. Om dit op te schonen worden orders die 14 dagen op EnRoute staan of 30 dagen op AvailablePickup, op \"Delivered (?)\" gezet. De afleverstatus kan ook geimporteerd worden voor retourlabels. Aflevermoment Bij een order wordt ook een aflevermoment berekend en getoond op Montaportal. Dit aflevermoment wordt als volgt berekend: Eerst wordt de afleverdag bepaald. Monta houd hiervoor zelf een tabel[[Doelgroep IT: (tblShipperTransitTimeCountryPostcode)]] bij met per verzender, bestemming land en evt postcode range het aantal transit dagen. Ook houd Monta een tabel met feestdagen bij per land[[Doelgroep IT: (tblShipperAdditionalTransitTimeNationalHoliday)]]. Per verzender/land verschilt het of er op zaterdag/zondag geleverd wordt, dit staat in de programmacode. Het aflevertijdstip op die dag wordt opgehaald uit het systeem van de verzender als die koppeling gemaakt is. Pro forma invoice Bij een order naar een niet-EU land wordt automatisch de benodigde douane documentatie (pro forma invoice) in orde gemaakt. Daarnaast wordt de informatie digitaal doorgegeven aan de verzender bij het maken van het label. De benodigde informatie moet hiervoor wel aanwezig zijn in het systeem. Is dat niet het geval, dan wordt de order geblokkeerd. De melding geeft aan welke informatie ontbreekt. Benodigd zijn bij elk product: de HS-tarief codes, de country of origin en een verkooprijs en valuta. De verkoopprijzen en valuta worden geïmporteerd uit de webshop. Kortingsregels op de factuur worden verwerkt in de verkoopprijzen van de producten op de pro forma invoice. Bij gesplitste producten bestaat de optie om het originele product te vermelden op de pro forma invoice. Het template van de pro forma invoice is vast. Verzenders willen deze namelijk in een gestandaardiseerd format ontvangen. Zie ook versturen buiten de EU. Ontbrekende prijzen Om een pro forma invoice te maken moet van elk product in de order de prijs bekend zijn. Voor de meeste orders importeren we de factuur uit de webshop, dus is de prijs bekend. Maar als er producten toegevoegd worden aan de order, is er geen prijs bekend. Dit kan bijvoorbeeld het geval zijn bij splits- en toevoegproducten. Om dit op te lossen zijn er twee opties: Bij een product splitsing kan worden ingesteld dat het originele product op de pro forma moet staan, ipv de onderliggende producten. De prijs van het originele product is dan bekend omdat die wel verkocht is in de webshop. Bij een product kan ingesteld worden dat deze met een bepaalde prijs automatisch moet worden toegevoegd op de pro forma invoice. Het is ook mogelijk om bij een product in te stellen dat de prijs die vanuit de webshop is meegekomen moet worden vervangen door een andere prijs. Douane statements Het is mogelijk douane statements op de pro forma invoice te plaatsen. Dit kan zorgen voor lage importtarieven. Bijvoorbeeld voor als een handelsovereenkomst aanwezig is. De douane statements kunnen ingesteld worden op de Montaportal. Anonimiseren Een periode nadat de order verzonden is wordt deze geanonimiseerd. Deze periode is standaard 90 dagen, klanten kunnen ervoor kiezen dit langer of korter te zetten. Bij het anonimiseren worden de persoonsgegevens van de order verwijderd. Dit zijn naam, straat, huisnummer, huisnummer toevoeging, e-mailadres en telefoonnummer. De beveiligde (gehashte) versie van het e-mailadres wordt wel bewaard. Omdat hetzelfde e-mailadres altijd hetzelfde gehashte e-mailadres oplevert, kan toch na het anonimiseren nog gevonden worden welke orders vanuit hetzelfde e-mailadres besteld zijn. Archiveren Een bepaalde periode nadat de order verzonden is wordt deze gearchiveerd. Deze periode is 90 dagen. Bepaalde informatie van de order zoals bijlagen en logs worden dan verwijderd. Dit om de hoeveelheid dataopslag beperkt te houden. Zoekwoorden: ,o ,ou ,out ,outb ,outbo ,outbou ,outboun ,outbound"
  },
  "Algemene-informatie/Personeelsplanning/Personeelsplanning-Updates/index.html": {
    "href": "Algemene-informatie/Personeelsplanning/Personeelsplanning-Updates/index.html",
    "title": "Personeelsplanning Updates",
    "keywords": "Personeelsplanning Updates Binnen GoMonta is er de mogelijkheid personeel in te plannen. Onderstaand zijn updates aan dit systeem weergegeven. update 7-4-2023 Het is mogelijk gemaakt dat medewerkers met contract type 'Stagiair' bij het uren verwerken de uren op uren type 'Stage uren' krijgen. Die uren tellen dan niet mee met de productiviteit. Dit omdat Monta graag Stagiaires de kans geeft stage te lopen, maar dat voorheen ten laste van de productiviteit ging. Standaard wordt het uren type op 'Stage uren' gezet, maar er kan van worden afgeweken door het uren type op 'Gewerkt' te zetten, da kan bijvoorbeeld zijn bij mensen die naast hun stage ook als bijbaan werken bij Monta. Update 6-4-2023: Week op zondag laten beginnen tbv excel export Omdat er in 2023 voor gekozen is de week op zondag te laten starten administratief, is dit ook doorgevoerd in de personeelsplanning. Update 6-4-2022: Leidinggevenden die uren kunnen goedkeuren van elkaars medewerkers. Soms werken leidinggevenden in duo diensten (zoals in molenaarsgraaf). Hiervoor is een mogelijkheid gemaakt dat leidinggevenden ook uren kunnen goedkeuren van medewerkers die bij de andere leidinggevende horen. Er komt dan een mogelijkheid de andere leidinggevende te kiezen. Er is nog geen mooi instellingen scherm voor, maar instellen kan in deze tabel: tblUrenRegistratieKoppelLeidinggevendeLeidinggevende Update 5-8-2022: Bij ploegen wissel mogelijkheid filteren op afdeling Bij kopiëren van planning, de mogelijkheid de dag en avond ploegen te wisselen. Hieraan is nu toegevoegd dat er gefilterd kan worden op afdeling. Zo kun je onderscheid maken tussen afdelingen die met wisselende ploegen werken en afdelingen waar dit niet het geval is. Update 5-8-2022: Knopje naar uitleg in vragen.monta Via dit knopje kun je vanuit de personeelsplanning naar de vragen.monta pagina met uitleg. Update 5-8-2022: Toevoegingen aan de Tour De 'Tour' is een functie waarbij uitleg gegeven wordt over de werking van verschillende delen van de personeelsplanning. Bij deze tour zijn nu uitbreidingen gedaan, zodat nieuwere functies er ook in staan. Update 27-7-2022: Updates emailadressen bij rooster delen Wanneer je de het rooster deelt met een uitzendburo, wordt het email adres van het uitzendburo onthouden voor de volgende keer dat je een rooster wilt delen. Wanneer je het rooster deelt met medewerkers, is het mogelijk dit vanuit een centraal email adres als afzender te laten komen. Als voorbeeld: planning.molenaarsgraaf@monta.nl. Zodat antwoorden op deze emails op een centrale plek binnenkomen. (Wanneer je dit ook wilt voor je vestiging, kun je dit aanvragen via techniek@monta.nl) Update 27-7-2022: Beschikbaarheids overzicht. Bij het beschikbaarheids overzicht is de knop naar het hoofdscherm gekomen. En bij het beschikbaarheids overzicht is de mogelijkheid gekomen om te filteren op afdeling. Ook is er een Excel export mogelijkheid gebouwd bij het beschikbaarheids overzicht Update 27-7-2022: Bij kopiëren van planning, de mogelijkheid de dag en avond ploegen te wisselen update 27-7-2022: Extra filtermogelijkheden in planning scherm"
  },
  "Algemene-informatie/Personeelsplanning/Uitzendkracht-aanmelden/index.html": {
    "href": "Algemene-informatie/Personeelsplanning/Uitzendkracht-aanmelden/index.html",
    "title": "Uitzendkracht aanmelden",
    "keywords": "Uitzendkracht aanmelden Monta heeft een online portal waar uitzendbureaus de gegevens van uitzendkrachten kunnen doorgeven. Dit heeft als doel dat de uitzendkracht vrijwel direct aan de slag kan bij Monta, zonder dat eerst nog administratieve zaken ingevuld moeten worden. En daarnaast voorkomt dit het e-mailen van persoonsgegevens, wat door de AVG wetgeving eigenlijk niet meer de bedoeling is. Onderstaand wordt meer uitgelegd over de werking van het uitzendkracht aanmeld systeem. Uitzendkrachtaanmelden.monta.nl Via uitzendkrachtaanmelden.monta.nl kan een uitzendbureau gegevens van nieuwe uitzendkrachten vast invullen en de gedragscode laten ondertekenen. Dit is erop gericht dat de uitzendkracht met zo min mogelijk administratieve handelingen in de monta vestiging aan het werk kan, omdat de administratieve zaken al vooraf zijn ingevuld. Uitzendbureaus die nog geen toegang hebben tot uitzendkrachtaanmelden.monta.nl kunnen die toegang aanvragen via techniek@monta.nl. Onderstaand een korte uitleg over de werking van uitzendkrachtaanmelden.monta.nl ::: video ::: Uitzendkracht gegevens overnemen in montamoney Wanneer een uitzendbureau de gegevens van een uitzendkracht heeft ingevuld in uitzendkrachtaanmelden.monta.nl, zijn deze gegevens beschikbaar om over te nemen in montamoney. Omdat de meeste gegevens al vooraf ingevuld zijn, is het een stuk minder werk in montamoney, zodat de uitzendkracht zo snel mogelijk een badge heeft en kan starten. Voor vestigingen waar een uitzendburo intern zit, is er sinds eind oktober 2022 de mogelijkheid dat het uitzendburo al in https://uitzendkrachtaanmelden.monta.nl een badge toekent aan de uitzendkracht, zodat de uitzendkracht sneller aan het werk kan. Wat waarschijnlijk voor de uitzendkracht een prettiger ervaring is en werk scheelt voor de leidinggevende bij Monta. ::: video ::: ********** De informatie hieronder is meer van technische aard ********** Website De website https://uitzendkrachtaanmelden.monta.nl/ draait op webserver mp-web04 De code is te vinden in project 'EmployementAgencyPortal' op DevOps. De volgende url verwijst naar het project: https://dev.azure.com/MontaDevelopment/Montapacking/_git/EmploymentAgencyPortal database De uitzendkrachtgegevens en de gedragsovereenkomst worden opgeslagen in een aparte database op server MP-SQL06\\MSSQL De naam van de database is EmploymentAgency. Het idee hierachter is dat user ….. van de website uitzendkrachtaanmelden.montapacking.nl de enige user is die van buitenaf bij deze database hoeft te komen montamoney Wanneer een uitzendkracht is aangemeld door het uitzendbureau, verschijnt de uitzendkracht in montamoney in beeld bij de leidinggevende (in het medewerker zoek scherm), die de uitzendkracht dan kan worden toegevoegd in montamoney. De gegevens komen dan terecht in de reguliere database en het record uit MP-SQL06\\MSSQL\\EmploymentAgency wordt gewist, zodat persoonsgegevens van de medewerker niet langer dan nodig zijn in de aanmeld database blijven bestaan."
  },
  "Algemene-informatie/Personeelsplanning/Urenregistratie/Uren-op-projecten/index.html": {
    "href": "Algemene-informatie/Personeelsplanning/Urenregistratie/Uren-op-projecten/index.html",
    "title": "Uren op projecten",
    "keywords": "Uren op projecten Voor uren van IT en R&D is er de wens vanuit de accountants om uren op projecten te boeken. Op deze pagina is wat uitleg te vinden hoe er met projecten gewerkt kan worden. Aanmaken van projecten Het aanmaken van projecten is mogelijk in montamoney en gomonta. In onderstaand stukje zal beschreven worden hoe dit er in montamoney uitziet. In gomonta moeten rechten eerst aangepast worden, zodat ook IT leidinggevende in gomonta projecten kunnen aanmaken of wijzigen. Nu kan alleen HR dat. Projecten om uren op te boeken zijn in dit projecten scherm aan te maken. Achteraf toekennen van projecten aan uren Wanneer er geen projecten gekozen zijn tijdens het uren verwerken, is het ook mogelijk om achteraf projecten aan uren toe te kennen. Dit is mogelijk in montamoney. Export om te kijken hoe volledig project administratie is. In hetzelfde scherm waarin projecten kunnen worden toegekend aan geboekte uren, zit ook een exportmogelijkheid om te zien of de uren van medewerkers een project hebben. Het idee is dat er een of meer leidinggevenden gekozen worden en dat er dan van de medewerkers die bij deze leidinggevenden horen een export van de uren en projecten wordt gemaakt. Filteren in deze excel op uren zonder project geeft de uren waar nog een project zou kunnen worden ingevuld."
  },
  "Algemene-informatie/Personeelsplanning/Urenregistratie/index.html": {
    "href": "Algemene-informatie/Personeelsplanning/Urenregistratie/index.html",
    "title": "Urenregistratie",
    "keywords": "Urenregistratie Uren verwerken in gomonta Na jaren van trouwe dienst wordt montamoney qua urenverwerking vervangen door gomonta. Zodat gebruikers die alleen nog voor uren verwerken naar de werkplek moeten, dit ook lokaal kunnen doen. Het omzetten naar gomonta zal geleidelijk gebeuren. We vinden het fijn als je al zoveel mogelijk gomonta gebruikt voor uren goedkeuren, maar montamoney blijft ook nog een tijdje beschikbaar voor als je in gomonta tegen issues aan loopt. sneak preview van uren goedkeur scherm in gomonta: Het volgende scherm waar aan geprogrammeerd wordt om over te zetten naar gomonta is het medewerker detail scherm uit montamoney. Uren in bulk goedkeuren Wanneer het uren verwerken in gomonta gebruikt wordt, is er de optie om uren in bulk goed te keuren. Zeker bij leidinggevenden die voor veel collega's de uren verwerken, kan dit een voordeel zijn. Wanneer de geklokte uren (afgerond op kwartieren) overeenkomen met het aantal uren in de personeelsplanning en als de activiteiten overeenkomen met de gekozen afdeling in de personeelsplanning, wordt de uren regel groen en kan er in bulk goedgekeurd worden. In bovenstaand voorbeeld zou een uren regel in bulk mogen worden goedgekeurd als het aantal geklokte uren 8 is en de activiteiten vallen onder outbound (Picken, Sorteren of Echecken). In bovenstaand voorbeeld zijn de activiteiten allemaal outbound activiteiten en komt het aantal gewerkte uren overeen met het aantal geplande uren (2), waardoor de urenregel groen wordt en in bulk kan worden goedgekeurd. Een goede werkwijze bij uren verwerken zou kunnen zijn om eerst de regels te verwerken die niet groen zijn, vervolgens de groene regels waar je aanpassingen aan zou willen doen. Het restant groene uren regels dat dan overblijft is hetgene dat in bulk goedgekeurd kan worden. Verdeling van activiteiten bij uren verwerken. Vanuit een aantal vestigingen is de wens gekomen om het productiviteits cijfer dat we binnen monta gebruiken (totaal aantal outbound regels gedeeld door totaal aantal uren) meer te specificeren. Er werd aangegeven dat het onderverdelen van dit productiviteits cijfer in de verschillende activiteiten zoals inbound, retouren, echeck etc wenselijk is. Het is een zoektocht geweest hoe dit mogelijk is, zonder dat het enorm veel extra administratief werk vraagt van de uren verwerker of veel extra urenklok handelingen van de medewerker. We denken nu een manier te hebben gevonden waarbij het administratieve werk zo minimaal mogelijk blijft en er toch op termijn het inzicht in de verdeling over de verschillende activiteiten gemaakt kan worden. Het streven is om dit verdelen van de uren over verschillende activiteiten in te laten gaan op 1 januari 2023, zodat de informatie gelijk van een heel kalenderjaar beschikbaar is. In dit voorbeeld is een activiteiten verdeling te zien van 40% inbound en 60% retouren. Dit wordt berekend door de werkdag op te knippen in stukjes van 5 minuten. En dan per stukje van 5 minuten te kijken welk type scans er gedaan is. In dit voorbeeld is de 40% inbound gebaseerd op 28 metingen (tijdvakjes van 5 minuten) en is de 60% retouren gebaseerd op 42 metingen (tijdvakjes van 5 minuten). De reden dat dit kleine getal met aantal metingen erbij wordt weergegeven is dat je dan kunt zien als een percentage op heel weinig metingen gebaseerd is dat je het wellicht wilt aanpassen. Als voorbeeld, stel je hebt een medewerker die vrachtwagens lost en de inbound expeditie netjes houdt. Dat zijn werkzaamheden die niet in het systeem te meten zijn, omdat er geen scans zijn. Die uren zou je normaliter op 100% 'Corvee & Intern transport' willen zetten. Maar stel dat deze medewerker 1 inbound scan gedaan heeft om wat voor reden dan ook, dan zal het systeem de suggestie geven dat deze medewerker 100% inbound gedaan heeft, maar omdat er een klein getalletje 1 onder staat, kun je zien dat dit maar op 1 meting gebaseerd is en kun je ervoor kiezen om ook een percentage bij 'Corvee & Intern transport' in te vullen. Bij medewerkers die als afdeling 'IT, TD, Commercieel & Admin' of 'Kantoor en projectmanagement' hebben staan, zal standaard 100% worden ingevuld bij 'Kantoor' Het systeem dat de percentages suggereert zal in de loop van de tijd steeds beter worden, zodat in de loop van de tijd het handmatige werk dat je er aan hebt bij uren verwerken steeds minder wordt. ** ** ** ** ********** De informatie hieronder is meer van technische aard ********** Technische informatie bij de verdeling van activiteiten R-scripts activiteiten verdeling De scripts heten personal_scans, personal_picks_raw en personal_echecks_raw. Deze scripts draaien via de ScheduleR op de mp-proc02 Tabel en stored procedure activiteiten verdeling monta_ai De tabel die gevuld wordt met de activiteiten verdeling heet tblScanActionsPerUser in de monta_ai database op de mp-sql06. De stored procedure die gebruikt kan worden om de percentages activiteiten over een tijdsperiode per medewerker te laten zien heet getUserActivityForTimeRange en is ook te vinden in de monta_ai database op de mp-sql06 Tabel waarin de uiteindelijke activiteitenverdeling in wordt opgeslagen. de tabel tblUrenregistratieActiviteiten in de monta_backend bevat de activiteitenverdeling na het uren verwerken. Via deze tabel kunnen dan toekomstige power bi rapporten gemaakt worden om het productiviteitsgetal onder te verdelen in de verschillende activiteiten."
  },
  "Algemene-informatie/Personeelsplanning/Whatsapp-personeelsplanning/index.html": {
    "href": "Algemene-informatie/Personeelsplanning/Whatsapp-personeelsplanning/index.html",
    "title": "Whatsapp personeelsplanning",
    "keywords": "Whatsapp personeelsplanning Binnen GoMonta is er de mogelijkheid personeel in te plannen. Een van de mogelijkheden om roosters te delen of om met medewerkers te communiceren over het opvullen van diensten is via whatsapp. Hiervoor wordt gebruikt gemaakt van een business account van whatsapp. Daaraan zijn wat regels verbonden vanuit whatsapp, om te voorkomen dat bedrijven whatsapp als reclame platform gaan gebruiken. Zo moet je een chat altijd starten met een standaard bericht vanuit een template en zodra een medewerker daarop reageert, kun je vrije berichten sturen. Daarom zal aan het begin van een chat altijd onderstaand bericht worden gebruikt. Dat ziet er ongeveer uit zoals onderstaand. Dit bericht is in het Nederlands of Engels beschikbaar. Zodra de whatsapp integratie live is voor Molenaarsgraaf, zullen we onderstaand nog wat meer details beschrijven. ********** De informatie hieronder is meer van technische aard ********** Technische informatie bij de whatsapp integratie CM.com De whatsapp integratie is geregeld via het platform cm.com. Wanneer een andere vestiging ook whatsapp wil, kan dit binnen het cm.com platform geregeld worden. Hier zijn abonnementskosten aan verbonden. De tabellen voor de whatst staan gewoon in de Monta_Backend database. Tabelstructuur Een tabel voor verzonden berichten tblSenderMessages En een tabel voor binnenkomende berichten tblReceivedMessages"
  },
  "Algemene-informatie/Personeelsplanning/Zoeken-op-badge/index.html": {
    "href": "Algemene-informatie/Personeelsplanning/Zoeken-op-badge/index.html",
    "title": "Zoeken op badge",
    "keywords": "Zoeken op badge Onderstaand wordt uitgelegd hoe er gezocht kan worden op badgenummers. Hoe kan ik gemakkelijk zoeken op badgenummers? Stap 1: Ga naar gomonta en klink op het tabblad \"Kantoor\". Stap 2: Klik vervolgens op de knop \"Medewerkers/ uren\". Stap 3: Klik hierna op de knop \"Medewerkers\". Stap 4: In het omcirkelde zoekveld kan een badgecode ingevuld worden. Druk op enter om te zoeken. Door een scanner aan de computer te verbinden, kan de barcode van de pasjes gemakkelijk uitgelezen worden. Stap 5: Nu zou de medewerker waarvan de badge gescand is, getoond moten worden."
  },
  "Algemene-informatie/Personeelsplanning/index.html": {
    "href": "Algemene-informatie/Personeelsplanning/index.html",
    "title": "Personeelsplanning",
    "keywords": "Personeelsplanning Binnen GoMonta is er de mogelijkheid personeel in te plannen. Onderstaand zijn enkele mogelijkheden van de personeelsplanning weergegeven. Inschatten planning ::: video ::: Templates ::: video ::: Handigheidjes ::: video ::: Tour Als je benieuwd bent welke dingen er mogelijk zijn met de personeelsplanning, kun je via de 'tour' daar een indruk van krijgen."
  },
  "Algemene-informatie/Personeelsplanning/montamoney-uitzendburo/index.html": {
    "href": "Algemene-informatie/Personeelsplanning/montamoney-uitzendburo/index.html",
    "title": "montamoney uitzendburo",
    "keywords": "montamoney uitzendburo Montamoney is de tool waarin o.a. uren verwerkt kunnen worden. Veel van de functionaliteit uit montamoney wordt omgebouwd naar tools zoals gomonta en montaportal. Maar zolang zaken nog in montamoney zitten, is op deze pagina het e.e.a. te vinden over de werking van montamoney. Uitzendburo toevoegen In onderstaand filmpje is te zien hoe een uitzendburo kan worden toegevoegd. De collega's van finance hebben rechten om dit uit te voeren. Dit omdat nieuwe relaties zoals uitzendburo's eerst in Exact worden aangemaakt. ::: video :::"
  },
  "Algemene-informatie/Rapportage/Smart-stock/index.html": {
    "href": "Algemene-informatie/Rapportage/Smart-stock/index.html",
    "title": "Smart stock",
    "keywords": "Smart stock Smart stock is een functionaliteit in de Montaportal. De Smart stock pagina is te vinden onder het tabblad Business Intelligence. Monta Smartstock op YouTube Categorieën Smart stock kan helpen met het optimaliseren van je voorraadmanagement en zo voorraadkosten besparen. Het doel van Smart stock is het besparen op gefactureerde voorraadkosten door voorraad van niet of weinig verkopende artikelen af te bouwen. Smart stock is verdeeld in drie verschillende categorieën: • Incourante voorraad, Slow movers en Dure voorraad. Incourante voorraad In de tabel \"incourante voorraad\" worden artikelen getoond die meer dan 90 dagen niet verkocht zijn. In de tabel is er per artikel te zien hoeveel stuks er op voorraad liggen, en wat de verwachte voorraadkosten per week zullen zijn. Opslagvolume Opslagtarief Potentiële besparing Slow Movers In de tweede tabel, genaamd \"Slow movers\", zijn er artikelen te zien die meer voorraadkosten, dan verwachte omzet per week, hebben. Houd hierbij rekening dat de verwachte omzet is gebaseerd op basis van het aantal verkopen uit het verleden, waarbij de laatste vier weken het zwaarst wegen. Indicatie voorraadkosten Verwachte omzet Potentiële besparing Dure voorraad Ten slotte staan in de derde tabel \"Dure voorraad\" artikelen weergegeven die relatief de hoogste Voorraadwaarde hebben ten opzichte van de verwachte omzet. Bij deze tabel worden de ingevulde inkoopprijzen en verkoopprijzen gebruikt per artikel. Ook hier geldt dat de verwachte omzet is gebaseerd op basis van het aantal verkopen uit het verleden, waarbij de laatste vier weken het zwaarst wegen. Verwachte omzet Inkoopwaarde voorraad Voorraadwaarde Besparen op voorraadkosten Zodra je wilt besparen op de voorraadkosten, kan je gemakkelijk een uitgaande order maken van de artikelen die je uit de opslag wilt verwijderen. Je druk om te beginnen op de blauwe knop waarop staat , Bespaar Direct. Vervolgens selecteer je de artikelen die je in de order wilt verwerken. Rond de uitgaande order af door een bestaand adres uit het adressenboek te kiezen of voeg een nieuw adres toe. Artikel onzichtbaar in tabel Stel dat je een artikel onzichtbaar wilt maken in een tabel, kan dit gemakkelijk door het verberg icoontje te selecteren. Je kan vervolgens aangeven na hoeveel dagen het artikel terug mag komen in de tabellen."
  },
  "Algemene-informatie/Rapportage/index.html": {
    "href": "Algemene-informatie/Rapportage/index.html",
    "title": "Rapportage",
    "keywords": "Rapportage Op de volgende plaatsen is rapportage data beschikbaar: Dashboards op de Montaportal Excel rapportages op de Montaportal Excel exports van schermen op de Montaportal Exports bij de factuur in GoMonta Voorraad per locatie Op welke locaties de voorraad ligt is alleen inzichtelijk voor het magazijn. Aangezien voor de klant van het magazijn niet relevant is waar precies in het magazijn iets ligt. Er kunnen echter situaties zijn waarbij het toch handig is als de klant van het magazijn hier inzicht in heeft. Daarom is er een Excel rapportage 'Stock per location' beschikbaar wat voor specifieke klanten beschikbaar gemaakt kan worden in de Montaportal."
  },
  "Algemene-informatie/Rechtenstructuur-GoMonta/index.html": {
    "href": "Algemene-informatie/Rechtenstructuur-GoMonta/index.html",
    "title": "Rechtenstructuur GoMonta",
    "keywords": "Rechtenstructuur GoMonta In GoMonta heeft een medewerker heeft een rol die bepaald wat hij/zij mag. Elke medewerker heeft ook toegang tot één of meer magazijnen. Wat een medewerker mag (via de rol) mag hij/zij in alle magazijn weer hij/zij toegang toe heeft. Hieronder volgt een beschrijving van elke rol (van weinig rechten naar veel rechten). Productiemedewerker Een productiemedewerker mag in de Inbound en Voorraadbeheer alleen gegevens bekijken en niks bewerken. Verder heeft deze rol geen toegang tot de Outbound, Customer service en het Admin gedeelte. Bij de Inbound mag deze rol gegevens inzien van het Inbound dashboard, Inbound forecasts, Inbound forecasts per product en het Koppelen. Bij de Inbound forecasts mag hij de volgende acties niet: Niet-voorgemelde groep aanmaken, Inbounden en een Inbound verwijderen. Bij het Koppelen mag de Productiemedewerker wel een TT01-label downloaden maar mag hij geen TT01 koppelen en verwijderen. Verder mag de Productiemedewerker geen gegevens inzien van de Retouren en Magazijn Inbound Instellingen. Bij de Voorraadbeheer mag deze rol gegevens inzien van de Actuele voorraad, Materialen, Magazijn locaties en Voorraadboekingen. Bij Materialen mag hij alleen gegevens inzien en niet aanpassen. Ook kan hij de volgende acties voor een materiaal niet: Verplaatsen, Correctieboeking, Opboeken en Omboeken. Ditzelfde geldt ook bij Magazijn locaties. Tot slot, een productiemedewerker heeft bij de Voorraadbeheer geen toegang tot Download verplaats labels, Product Import, Cycle count, Voorraad Mutatie Goedkeuring en de Voorraadbeheer instellingen. Probleemoplosser Een Probleemoplosser mag in de Inbound, Voorraadbeheer en Outbound gegevens bekijken en gedeeltelijk aanpassen. Verder heeft deze rol geen toegang tot Customer service en het Admin gedeelte. Bij de Inbound mag deze rol even veel als de rol Productiemedewerker alleen kan hij meer acties uitvoeren. De acties die een Probleemoplosser meer kan uitvoeren zijn Inbound forecasts: Niet-voorgemelde groep aanmaken, Inbounden en Verwijderen, Koppelen: Een TT01 Koppelen, Verwijderen en een label downloaden. Verder mag de Probleemoplosser geen gegevens inzien van de Retouren en Magazijn Inbound Instellingen. Ditzelfde geldt voor de Voorraadbeheer, hier kan de Probleemoplosser even veel inzien maar kan meer acties uitvoeren. Zo kan de Probleemoplosser bij Materialen de basis gegeven aanpassen en open orders per materiaal bekijken. De Probleemoplosser mag geen Excel export maken van Actuele Voorraad, Materiaal aanmaken, Materiaal instructies aanpassen, Efulfilment instellingen aanpassen, Materiaal verplaatsen, Correctieboeking, Opboeken andere locatie, Omboeken​ en bij de Voorraad Mutatie Goedkeuring. De Probleemoplosser heeft ook toegang tot de Outbound. Hierin kan hij bij de Outbound dashboard, Orders overzicht, Tegen gehouden orders en Actuele Jokers. Bij de Order details kan hij pickbon en attachments downloaden, Adres aanpassen, Verzender aanpassen, Echeck en Shipment resetten. Hij mag hier geen Orders splitten, echecken, shipped zetten en als runner markeren. Bij de Tegen gehouden orders mag een Probleemoplosser wel een Replenishment export maken maar geen Volle pallets resetten. Hij heeft geen toegang tot de pagina's Delayed@Shipper, Runner orders, Bulkpickbonnen, Kratten, Pickingstyle, Orders zonder pickbon, Verzenders en Magazijn outbound instellingen. Shiftleader Een Shiftleader mag in de Inbound, Voorraadbeheer en Outbound gegevens bekijken en gedeeltelijk aanpassen. De Shiftleader mag meer aanpassen dan een Probleemoplosser. Verder heeft deze rol geen toegang tot Customer service en het Admin gedeelte. Bij de Inbound mag een Shiftleader hetzelfde als een Probleemoplosser, alleen mag hij in tegenstelling tot een Probleemoplosser wel in het Retouren scherm kijken. De Shiftleader mag hierin alleen kijken en geen Retouren verwijderen. Verder mag de Shiftleader geen gegevens inzien van de Magazijn Inbound Instellingen. Bij de Voorraadbeheer kan een Shiftleader hetzelfde als een Probleemoplosser maar mag hij wel een Excel export maken van Actuele Voorraad, Materiaal instructies aanpassen, Efulfilment instellingen aanpassen, Materiaal verplaatsen, Correctieboeking, Opboeken andere locatie, Omboeken, Cycle Count, Voorraad Mutatie Goedkeuren en kan hij bij Download verplaats labels. Hij heeft geen toegang tot een Materiaal aanmaken, Product Import en Voorraadbeheer instellingen. Bij de Outbound mag een Shiftleader alles behalve de Afhaaltijden aanpassen bij de Verzenders. Hij heeft toegang tot Delayed@Shipper, Runner orders, Bulkpickbonnen, Kratten, Pickingstyle, Orders zonder pickbon, Verzenders, Outbound dashboard, Orders overzicht, Tegen gehouden orders, Actuele Jokers en Magazijn outbound instellingen. Bij de Order details kan hij pickbon en attachments downloaden, Runner Markeren, Echecken, Shipped zetten, Order splitten, Adres aanpassen, Verzender aanpassen, Echeck en Shipment resetten. Bij de Tegen gehouden orders mag hij een replenishment export maken, Volle pallets resetten en Orders doorzetten naar scanner. Bij Bulkpickbonnen mag hij bulkpickbonnen downloaden en resetten. Bij Kratten mag hij een Krat geschiedenis export maken. Tot slot, mag een Shiftleader ook Pickbonnen aanmaken en downloaden van Orders zonder pickbon. Magazijn coördinator Een Magazijn coördinator mag in de Inbound, Voorraadbeheer, Outbound en Customer service. Het Customer service gedeelte is alleen toegankelijk voor Monta medewerkers en dus niet voor bijvoorbeeld de Makro of AkzoNobel medewerkers. Een Magazijn coördinator kan alles in de Inbound, dus ook in het Retouren scherm een retour verwijderen en heeft hij toegang tot de Magazijn Inbound instellingen. Bij de Voorraadbeheer kan hij ook alles, behalve een Materiaal aanmaken en een Product Import. In tegenstelling tot een Shiftleader kan een Magazijn coördinator wel bij de Voorraadbeheer instellingen. Bij de Outbound mag een Magazijn coördinator ook alles, dus ook de Afhaaltijden aanpassen van Verzenders. Bij de Customer service heeft hij maar toegang tot een scherm, namelijk de Bedrijfsstatistieken. Verder heeft deze rol geen toegang tot het Admin gedeelte. Customer service De rol Customer service mag alles in de Inbound, Voorraadbeheer en Outbound. Customer service mag dus in tegenstelling tot een Magazijn coördinator wel een Materiaal aanmaken en een Product import. Verder heeft deze rol geen toegang tot het Admin gedeelte. De rol Customer service heeft natuurlijk toegang tot Customer service. Hierin mag hij bij de Bedrijfsstatistieken, Verkoopfacturen aanmaken/gegenereerde/planning, Relaties (ook aanpassen), Esettings (ook aanpassen) en Bezoekers inplannen. Hij heeft geen toegang tot het resetten van een verkoopfactuur en tot de MontaCast. Vestigingsmanager De rol Vestigingsmanager mag alles in de Inbound, Voorraadbeheer en Outbound. Bij Customer service mag een Vestigingsmanager hetzelfde als de rol Customer service, maar mag hij in tegenstelling tot de rol Customer service wel bij de MontaCast. Verder heeft deze rol geen toegang tot het Admin gedeelte en heeft geen toegang tot het resetten van een verkoopfactuur Finance De rol Finance mag alles in de Inbound, Voorraadbeheer en Outbound. Bij Customer service mag de rol Finance hetzelfde als de rol Vestigingsmanager, maar mag hij wel Verkoopfacturen resetten. Verder heeft deze rol geen toegang tot het Admin gedeelte. P&O De rol P&O mag alles in de Inbound, Voorraadbeheer en Outbound. Bij Customer service mag de rol P&O hetzelfde als de rol Vestigingsmanager. Verder heeft deze rol geen toegang tot het Admin gedeelte. Sales/Marketing De rol Sales/Marketing mag alles in de Inbound, Voorraadbeheer en Outbound. Bij Customer service mag de rol Sales/Marketing hetzelfde als de rol Vestigingsmanager. Verder heeft deze rol geen toegang tot het Admin gedeelte. Magazijn admin De rol Magazijn admin mag alles in de Inbound, Voorraadbeheer en Outbound. Bij Customer service mag de rol Magazijn admin hetzelfde als de rol Vestigingsmanager. Verder heeft deze rol wel toegang tot het Admin gedeelte, waarin hij bij het Gebruikersbeheer kan. In het Gebruikersbeheer kan hij gebruikers aanmaken, aanpassen en wachtwoorden aanpassen. Directie De rol Directie mag alles in de Inbound, Voorraadbeheer en Outbound. Bij Customer service mag de rol Directie hetzelfde als de rol Vestigingsmanager. Verder heeft deze rol geen toegang tot het Admin gedeelte. IT De rol IT mag alles in de Inbound, Voorraadbeheer en Outbound. Bij Customer service mag de rol IT hetzelfde als de rol Vestigingsmanager, dus geen Verkoopfacturen resetten. Verder heeft deze rol wel toegang tot het Admin gedeelte. In het Admin gedeelte kan hij Gebruikers, Printers, Echeck stations, Inbound stations, Picking scanners, Internal Rest Credentials en Toggle features beheren. Hij mag geen Rollen beheren. IT Advanced De rol IT Advanced mag alles in de Inbound, Voorraadbeheer, Outbound en Customer service. Verder heeft deze rol wel toegang tot alles in het Admin gedeelte. De rol IT Advanced kan dus ook Verkoopfacturen resetten en Rollen beheren. ​"
  },
  "Algemene-informatie/Retouren/Externe-Retour-integraties/index.html": {
    "href": "Algemene-informatie/Retouren/Externe-Retour-integraties/index.html",
    "title": "Externe Retour integraties",
    "keywords": "Externe Retour integraties Monta biedt zijn RMA module aan. Sommige klanten kiezen er echter voor om gebruik te maken van andere Retour platformen. Voorbeelden hiervan zijn Returnista; Returnless en LOOP. Monta heeft zelf geen active koppelingen met deze platformen, maar vereist wel dat de retouren worden vooraangemeld, en dat de verzendlabels van Monta worden gebruikt. Om die reden hebben sommige platformen een koppeling gebouwd met Monta. Hieronder is een overzicht te zijen van deze platformen met uitleg en functionaliteiten. Returnista: Returnista heeft een koppeling ontwikkeld met Monta. (De returnista koppeling is in beheer van Returnista, en niet in beheer van Monta). Deze koppeling bevat de volgende functionaliteiten: Vooraanmelding van de retouren Gebruik monta Verzendlabels. Om de koppeling te maken met Returnista moeten er RestAPI credentials aan returnista worden gegeven. Returnista maakt gebruik van de Externe Api van monta. (Belangrijk: bij het aanmaken van het RestAPI Account moet er worden aangezet dat dit account verzendlabels mag genereren). Returnista ondersteund momenteel de volgende vervoerder: DPD PostNL UPS DHL Parcel DHL Parcel Connect PostNL Buspakje Deze vervoerders, en de prijzen die de consument betaald, zijn in te stellen in de Portal van Returnista. Wel moeten deze vervoerder bij het kanaal in monta zijn toegevoegd. Retourredenen: Om het mogelijk te maken dat returnista de retourredenen mee inschiet in de montaportal moeten de retourcodes worden gemapt in Monta en Returnista. Deze codes gebruikt returnista tijdens het aanmaken van de vooraanmelding. Bijzonderheden: Returnista kan geen orders aanmaken in het systeem van Monta. De ruilorders worden aangemaakt in het webshopplatform waaruit monta importeert. Neem contact op met returnista om te kijken welke platformen ze ondersteunen. Returnista haalt de status van de retour niet op. De status van de retouren moet worden bijgehouden in de montaportal. Returnless Returnless heeft een relatief simpele koppeling met monta. LOOP Er is geen actieve koppeling tussen LOOP en Monta."
  },
  "Algemene-informatie/Retouren/RMA-Module/index.html": {
    "href": "Algemene-informatie/Retouren/RMA-Module/index.html",
    "title": "RMA Module",
    "keywords": "RMA Module De klant kan ervoor kiezen dat ze de RMA module gebruiken. Wat is de RMA? De RMA module is een toevoeging aan de Monta diensten. Deze module is erop gericht om de consument zo goed mogelijk te kunnen bedienen en het retourproces zo soepel mogelijk te kunnen laten verlopen. De RMA module is een scherm waarop de consument hun retouren kunnen aanmelden; retourredenen aangeven en verzend labels vanaf kunnen downloaden. Voordelen RMA Retour redenen: De consument kan voorafgaan aan het retour zenden de reden hiervan aangeven. Deze zijn voor de webshop eigenaar vooraf instelbaar. Consument krijgt rechtstreeks een verzendlabel: De consument kan een gewenste vervoerder kiezen uit de vooraf ingestelde opties. En krijgt direct een verzendlabel. Retourkosten de consument betaald instelbaar: De consument rekent in de module de (door jullie bepaalde) kosten af direct af. De retourkosten die de consument moet afrekenen kan de webshopeigenaar zelf bepalen. Nemen jullie het retour voor eigen rekening? Of willen jullie dat de consument zelf de retourkosten betaald? Het is nu allemaal instelbaar. Lay-out en achtergrond zelf instellen: Het design is iets aangepast. Je kunt nu zelf het logo en de achtergrond wijzigen. RMA module talen Onze RMA-module beschikt over de volgende talen: English Dutch French German Swedish Danish Spanish Op basis van de taal die is ingesteld in de browser bepaalt Monta welke taal de consument te zien krijgt. Eventueel kan de Consument ook zelf nog wisselen van taal in de RMA-module. Als de Consument de RMA-module in een X-taal heeft doorgelopen krijgen ze ook een email (met het retourlabel) in deze X-taal. De talen hoeven dus niet per land worden ingesteld, maar worden veranderd op basis van de klantgegevens. Als er geen mail template is ingesteld voor de betreffende taal, dan wordt het default template gestuurd. Retourkosten Bij de instellingen van de RMA pagina kan de webshop aangeven of er kosten gerekend moeten worden aan de consument. Als dit het geval is wordt voor het afrekenen gebruik gemaakt van de betaalprovider Mollie. Standaard wordt hiervoor het Mollie account van Monta gebruikt waarbij het ontvangen bedrag gecrediteerd wordt op de eerstvolgende factuur aan de klant. Nadelen van het Monta Mollie account: De betaalmogelijkheden worden door Monta beheerd (het veelgebruikte Paypal is hierbij bijv. niet beschikbaar) De naamgeving van de Mollie pagina bevat de naam Monta Naast het standaard Mollie account van Monta heeft de klant de mogelijkheid een eigen Mollie account in te stellen. Dit heeft als voordeel dat zij zelf kunnen beheren welke betaalmogelijkheden aangeboden worden en ook de naamgeving naar eigen wens aan te passen is voor de klant. Het instellen van een eigen Mollie account doen klanten op de RMA instellingen pagina in de Montaportal. De credentials kunnen ingesteld worden op de RMA settings pagina: Deze gegeven zijn in Mollie te vinden onder de developers tab: Controle Max afmetingen in de RMA Monta berekend in de RMA module de maximale afmetingen per vervoerder, zodat er geen retour kan worden aangemeld bij een vervoerder die deze afmetingen van het artikel niet kunnen vervoeren. De manier waarop we dit berekenen verschilt op basis van het aantal colli dat in een order zit. Het aantal colli wat wordt gebruikt is het aantal colli in de heenzending. Geen multi Colli: Checken we op het grootste afmeting LBH van ieder artikel in de retour. CHecken op gewicht van de Artikelen op basis van de gewichten per artikel in de montaportal Bij een Multi colli: Checken we op het grootste afmeting LBH van ieder artikel in de retour. Gewicht wordt niet gecontrolleerd, omdat we niet weten welk artikel in welke doos gaat. RMA instellen Om de RMA in gebruik te nemen is het van belang dat er een aantal instellingen worden gedaan. Hieronder is te vinden welke instellingen er allemaal moeten worden gedaan. In het RMA-menu (2) kan je aangeven voor welke kanalen(aanvinken bij 3) je de RMA in wilt stellen Vervolgens klik je op de Plus (4) De RMAlink (5) voor de consumentportal kan op de webshop geplaatst worden. De returnperiod (6) geeft aan hoeveel dagen een consument heeft voor het retourneren van goederen. Als je op de Plus (7) drukt kun je per land (8) de vervoerder (9) en de kosten voor de consument aangeven (10) Huisstyle Via onderstaand deel kan de portal enigszins naar eigen huisstijl aangepast worden. Settings Het is ook mogelijk om de volgende velden in te stellen: Retourperiode: de tijd (in dagen) waarin de consument zijn retour mag aanmelden; Sub domain: om te gebruiken in plaats van de GUID in de URL; Order prefix: voor het gebruik van een prefix in een ordernummer; Order suffix: voor het gebruiken van een suffix in een ordernummer; Inloggen met referentie toegestaan: of consumenten via order-referentie mogen inloggen; Login met postcode: of consumenten in moeten loggen via postcode (of via email); Product-afbeeldingen tonen in de RMA: of in de RMA pagina's de afbeeldingen van producten getoond worden, als deze beschikbaar zijn; SKU tonen in de RMA: zorgt ervoor dat de SKU achter de omschrijving van het product getoond wordt tussen haakjes; Valuta: de valuta van het RMA portaal; Gebruik verzenderafmetingen product: of de verzenderafmetingen van een product gebruikt moeten worden bij het bepalen welke verzenders de consument kan kiezen; Producten alleen tonen op ruilpagina als er voorraad is: toon de producten alleen op de ruilpagina als er voorraad beschikbaar is. Als deze uit staat wordt het bericht 'Uitverkocht, levering duurt langer' getoond. Deze optie staat standaard uit; Bericht tonen bij product over voorraadstand: toon bij de producten een bericht over de voorraad op de ruilpagina. Als deze aan staat wordt het bericht 'Op voorraad' of 'Bijna uitverkocht' getoond. Welk bericht wordt getoond, wordt bepaald op basis van de beschikbare en minimale voorraad. Als de minimale voorraad niet is ingesteld bij het product, wordt alleen het bericht 'Op voorraad' getoond. Deze optie staat standaard uit. Retourredenen De retourredenen dienen van te voren te worden ingesteld. Dit kan worden ingesteld via de Montaportal. Voorbeelden: Product is beschadigd/functioneert niet Product is anders dan besteld Product is niet zoals verwacht In de montaportal kan je onder de retourredenen bepaalde manieren van verwerken hangen: Altijd naar Quarantaine Opmerking verplicht. Afbeelding verplicht: In de RMA wordt de consument bij het kiezen van die reden verplicht een foto te uploaden. De consument kan maximaal 3 foto's uploaden. Deze foto's zijn terug te vinden in MontaPortal, onder Received -> Returns. Zie de afbeeldingen hieronder: Je kunt ook per RMA Portaal retourredenen in en uitschakelen. Opties per product Het is mogelijk het retourneren van bepaalde producten te blokkeren of te verplichten dat een comment ingevuld wordt. Dit kan door productgroepen te maken op de RMA portals pagina. RMA Verzenders In de RMA heb je twee soorten verzenders. Afgeef verzenders, waar de consument zelf het pakket naar een afhaalpunt moet brengen; en ophaal verzenders, waarbij de bezorger het pakket op komt halen bij de consument. Daarnaast zijn er ook twee alternatieve manieren voor consumenten om hun product retour te sturen/brengen. Afgeef verzenders Verzenders Landen Max afmetingen (LxBxH), omvang, gewicht DHL For You (eCom) Nederland (90 cm, 60 cm), n.v.t., 20kg DHL Parcel Connect Return Bulgarije, Denemarken, Duitsland, Estland, Finland, Griekenland, Ierland, Letland, Litouwen, Oostenrijk, Polen, Portugal, Roemenië, Zweden, Slowakije, Spanje, Tsjechië n.v.t. * DHL For You Buspakje Nederland (38 cm x 26 cm x 3 cm), n.v.t., 2kg DHL For You Pakket Belgie, Nederland (80cm x 60 cm x 50 cm), n.v.t., 23kg DPD Oostenrijk, Belgie, Tsjechië, Duitsland, Denemarken, Estland, Finland, Frankrijk, Hongarije, Litouwen, Luxemburg, Letland, Nederland, Portugal, Zweden, Slowakije (175 cm), 300 cm, 31kg PostNL Pakket Nederland (176 cm x 78 cm x 58 cm), n.v.t., 23kg PostNL paperless Nederland ( 100 cm x 70 cm x 58 cm), n.v.t., 30kg * PostNL Buspakje Nederland (38 cm x 26.5 cm x 3.2 cm), n.v.t., 2kg UPS Alle landen (274 cm), 400 cm, 70kg * Buspakje verzenders kunnen alleen gekozen worden als deze ook met buspakje verzonden zijn. Ophaal verzenders Verzenders Landen Max afmetingen (LxBxH), omvang, gewicht DHL Pickup Nederland (90 cm x 60 cm), n.v.t., 20kg Extra at Home Pickup Nederland n.v.t. DynaLogic Nederland, Belgie n.v.t. Swift Nederland n.v.t. Alternatieve verzendmethoden Er zijn twee alternatieve methoden die de consument kan kiezen om te versturen: \"Consumer Own Shipment\": de consument verstuurd zelf zijn pakket terug naar het ingestelde adres. De consument kan elke verzender kiezen die hij wilt, handig als hij bijvoorbeeld verzekerd wilt verzenden. Dit is in te stellen bij de instellingenpagina van een RMA Portaal, onder verzenders: Showrooms: voor als een klant wilt dat de consument ook bij een eigen winkel/showroom zijn retourbestelling mag komen brengen. Deze zijn in te stellen bij de instellingenpagina van een RMA Portaal, onder afleverpunt/winkel adressen: De consument kan deze dan kiezen in de RMA. Afleverpunten worden alleen getoond in een straal van 25km rondom het adres van de originele bestelling: Tekst aanpassen Het is mogelijk om op de retour pagina de sub header tekst te veranderen. Op de settings pagina van het RMA portal kan een language setting aangemaakt, verandert en/of verwijdert worden. Om een language setting te verwijderen, moet op de edit knop worden geklikt. Op de edit pagina staat een verwijder knop. BCC E-mail Settings In de instellingen is mogelijk om e-mailadressen in te stellen die als BCC toegevoegd worden aan alle e-mails die naar klanten verstuurd worden door de RMA. Integratie Iframe Het is mogelijk om de RMA module in een iframe te plaatsen zodat klanten niet de site hoeven te verlaten. Dit is echter alleen mogelijk als de retouren gratis zijn. Wanneer de retouren niet gratis zijn dan moeten de klanten op een externe module van Molly betalen. Deze module werkt niet in samenwerking met een Iframe. Deeplink login Het is mogelijk om een \"deeplink\" te maken naar de RMA. Zodat de consument meteen bij de juiste order uitkomt. Bijvoorbeeld vanuit een \"mijn bestellingen\" overzicht in een webshop. Hiervoor moet een login aangemaakt worden via de RMA api: https://api.montapacking.nl/rma/v0/index.html#tag/Login Het aanmaken van een login geeft een Id terug. Met deze Id kan de deeplink opgebouwd worden: https://www.montareturns.com/{rmaGuid}/{loginGuid} of als gebruik wordt gemaakt van een subdomein: https://{subdomein}.montareturns.com/{loginGuid}."
  },
  "Algemene-informatie/Retouren/RMA-Ruilen/index.html": {
    "href": "Algemene-informatie/Retouren/RMA-Ruilen/index.html",
    "title": "RMA Ruilen",
    "keywords": "RMA Ruilen De RMA kan ook gebruikt worden om consumenten hun producten te laten ruilen. Hoe werkt ruilen? Ruilen is een nieuw onderdeel van de RMA, waar consumenten kunnen kiezen om een product te ruilen voor een ander, vergelijkbaar product. Denk hier bijvoorbeeld aan een kledingstuk die de consument een maat te klein heeft besteld, of in een verkeerde kleur. Bepaalde instellingen zijn nodig om ruilen aan te zetten in de RMA. Die worden hieronder beschreven: Opvolgacties Opvolgacties zijn een nieuw onderdeel van de RMA. Consumenten kunnen via deze opvolgacties aangeven wat ze willen dat er gebeurd aan de hand van hun retour, zoals hieronder aangegeven: Deze opvolgacties zijn in te stellen in MontaPortal, zoals je hieronder kunt zien: In het voorbeeld hierboven heeft de consument aangegven zijn product te willen ruilen. Om ruilen mogelijk te maken moet je één opvolgactie aanmaken waarvan ruilen aan staat, zoals bijvoorbeeld hieronder: We raden vanuit Monta aan meerdere opvolgacties aan te maken, zoals bijvoorbeeld \"Geld terug\" of \"Winkel krediet\". Zo kan de consument ook naast ruilen kiezen wat hij wilt dat er na zijn retouraanmelding gebeurd. Je kunt ook bepaalde opvolgacties gratis maken om te verzenden. Zo kun je bijvoorbeeld de consument aanmoedigen om \"Winkel krediet\" of \"Ruilen\" te kiezen: Na het aanmaken van de opvolgactie moet die ook nog gekoppeld worden aan een retourreden. Opvolgacties kunnen alleen gekozen worden onder die retourreden. Op de detailpagina van retourreden kan dit (hier kom je via Instellingen -> Retouren -> Retourredenen -> klik op de \"wijzigen\" knop van een van de retourredenen): We raden aan alle opvolgacties aan al je retourredenen te koppelen, tenzij je een goede reden hebt dit niet te doen. Zodra je opgvolgacties (waarvan een \"ruilen\") hebt, en deze zijn gekoppeld aan retourredenen, komen deze te verschijnen in de RMA: Productgroepen Productgroepen worden gebruikt om te bepalen met welke producten de consument kan ruilen. Denk bij een groep aan bijvoorbeeld een shirt, die meerdere kleuren heeft. In de groep zitten die verschillende kleuren als losse producten in de groep. Een consument kan ruilen tussen producten binnen de groep. Bijvoorbeeld: In een groep zit een rood, wit en geel shirt. De consument wil zijn rode shirt ruilen. Dit kan voor de producten in die groep. Groepen kun je bekijken en ook aanmaken/wijzigen via MontaPortal: Een groep bestaat uit meerdere producten: En een groep heeft ook meerdere instellingen: Verder gaan wij via de product imports van verschillende koppelingen deze ophalen. Dit gebeurd al via Magento koppelingen. We raden aan de naam van groepen die automatisch zijn aangemaakt (via koppelingen), niet aan te passen, omdat die gebruikt worden om de groepen up te daten. De ruilenpagina in de RMA Als een consument één of meerdere “ruil” opvolgacties kiest komt hij vervolgens op de nieuwe ruilpagina, om specifiek dat product te ruilen voor een ander product: In de RMA kan een consument kiezen uit producten die in dezelfde groep zitten als het product wat hij wil ruilen: Als een consument een vervangend product heeft gekozen kan hij verder. De rest van de RMA loopt zoals vanouds. Opvolgen van ruilen vooraanmeldingen In de eerste fase van RMA ruilen gebeurd het aanmaken van nieuwe ruilbestellingen nog niet automatisch. Via MontaPortal kunnen handmatig nieuwe bestellingen aangemaakt worden. Dit kan ten eerste via de detailpagina van een retour vooraanmelding. Daar wordt getoond welke product de consument gekozen heeft om te ontvangen: Via een knop bovenaan de pagina kan een nieuwe bestelling gestart worden: Vanaf daar kom je op de standaard plek waar op MontaPortal nieuwe orders aangemaakt worden. De producten en het aantal wat de consument heeft bepaald wordt automatisch gezet: Je kunt ook in bulk meerdere nieuwe bestellingen aanmaken, via de retouren overzichts pagina. De gegevens van de originele Eorder worden gebruikt, waarvan onder andere de verzender en het adres. Achter de schermen worden de vooraanmelding gekoppeld aan de nieuwe ruilbestelling. Ook te zien op de retour detailpagina: Andere ruil-gerelateerde instellingen Hieronder worden enkele andere ruilen-gerelateerd instellingen uitgelicht: Custom velden in de RMA omtrent ruilen. Via de instellingen van je RMA Portaal in MontaPortal kun je zelf stukken tekst toe voegen in de RMA. Voor ruilen zijn hier twee mogelijkheden voor: TradeInInfoOnTradePage en TradeInInfoFieldAtEndOfProcess: Je kunt de taal ook instellen: Je kunt dit gebruiken om de gebruiker toe te lichten betreft ruilbestellingen in de RMA. In de RMA worden deze custom velden op de volgende twee plekken getoond, namelijk op de ruilenpagina: En ook aan het eind van de retouraanmelding:"
  },
  "Algemene-informatie/Retouren/index.html": {
    "href": "Algemene-informatie/Retouren/index.html",
    "title": "Retouren",
    "keywords": "Retouren Orders die retour komen kunnen aangemeld worden. Ontvangen retouren kunnen geregisteerd en opgevolgd worden. Retour vooraanmeldingen Een retour kan aangemeld worden. Op de volgende manieren: Handmatig op de Montaportal Door de consument door een retour aanmelding via de RMA. Zie RMA Module. Retour label Met retour label bedoelen we een verzendlabel waarmee de consument de order retour kan sturen naar de webshop. Een retour label kan op de volgende manier gemaakt worden: Op de Montaportal bij een order Op de Montaportal bij een retour vooraanmelding Door de consument bij het aanmelden van de retour via de RMA. Zie RMA Module. Monta kan een retourlabel meesturen met de order Als adres op het retourlabel wordt het retouradres gebruikt. Het kan zijn dat de gebruiker op de Montaportal een retour label wil maken terwijl de oorspronkelijke order niet beschikbaar is, of dat de oorspronkelijke order inmiddels geanonimiseerd is. Hier kan de gebruiker omheen werken door een 'retour order' te maken. Dit is een order die als verzonden in de portal staat zonder producten. Een retour order maken kan vanuit het adresboek, of vanuit het maken van een nieuwe order, in het scherm waar de gegevens van de consument ingevuld kunnen worden. Retourlabel meesturen met de order Bij een kanaal kan ingesteld worden dat bij elke order een retourlabel moet worden meegestuurd. Hierbij wordt ingesteld van welke verzender een retourlabel gemaakt moet worden. Het retourlabel wordt gemaakt bij het verifiëren van de order. Bij de echeck wordt het retourlabel geprint. Het retourlabel wordt op een A4 geprint, zodat het voor de gebruiker bij de echeck duidelijk is wat het verzendlabel en wat het retourlabel is. Afwijkend adres bij een order voor retourlabels Het kan zijn dat het oorspronkelijke adres van de order niet geschikt is als afzender adres voor het maken van een retourlabel. Om dit op te lossen is het mogelijk op de Montaportal een retouradres toe te voegen bij de order. Retourlabel afleverstatus Het is mogelijk om van retourlabels van de meeste verzenders de afleverstatus (onderweg, afgeleverd, etc) te importeren. Net als bij verzendingen.. Hiermee kan de transit tijd van retouren van bepaalde verzenders/landen gemeten worden. Ook kan gemeten worden hoe lang het magazijn nodig heeft om de retouren in te boeken. Als een er een retour vooraanmelding gemaakt is wordt de afleverstatus automatisch geïmporteerd. Bij retourlabels die worden meegestuurd met de order is er echter geen retour vooraanmelding. Voor deze labels kan per klant en verzender ingeschakeld worden dat de afleverstatus geïmporteerd wordt. Dit moet door IT gedaan worden in de programmacode. De afleverstatus blijft 200 dagen lang opgehaald worden, want tot zo lang kan er bij sommige webshops geretourneerd worden. De afleverstatus van het retourlabel is op de volgende plaatsen terug te zien: Als er een retour vooraanmelding is in de statusbalk van de retour vooraanmelding op Montaportal, In de Montaportal Excel rapportages \"Ontvangen retouren\" (175) en \"Retourvooraanmeldingen met productdetails\" (179), In de externe REST api van Monta. Retour adres Het afzender/retour adres staat ingesteld bij het kanaal. Dit adres wordt als afzender adres op de verzendlabels geprint. Als de order niet afgeleverd kan worden komt hij naar dat adres retour. Dit adres wordt ook gebruikt als ontvangeradres op retour labels. Retouren registereren Met de retour applicatie kunnen retouren registreert worden. Dit proces bestaat uit de volgende stappen: Order identificeren. Dit kan door: De barcode te scannen van het oorspronkelijke verzendlabel De barcode te scannen van het retour verzendlabel als deze is aangemaakt via de RMA Module. Te zoeken op ordernummer, postcode, naam Product(en) scannen. Per product: Retour reden kiezen Bepalen of een product naar verkoopbare, outlet of quarantaine voorraad moet Een foto maken als dit ingesteld staat bij de klant Er wordt een koppellabel geprint waarmee de producten weer in het magazijn geplaatst kunnen worden. Zie Inbound - Koppelen. Retour redenen Een klant kan zijn eigen set van retour redenen aanmaken. Dit kan op de Montaportal. Als een klant geen eigen redenen heeft worden de standaard retour redenen van Monta gebruikt. De retour redenen van de klant worden alleen gebruikt bij retouren die door de ontvanger retour gestuurd zijn. Bij 'onbestelbare' retouren wordt altijd de Monta retour redenen gebruikt. Dit zijn: Onbekend adres Geweigerd door bewoner Niet thuis / niet afgehaald Verhuisd Beschadigde verzendverpakking Geweigerd bij douane Anders / Onbekend Sub redenen Het is mogelijk om in de Montaportal een retourreden aan te maken en deze vervolgens als sub reden aan een retourreden te koppelen. Je kunt dus bijv. een retourreden aanmaken dat het product te klein is met als sub redenen een verdere specificatie. Onderstaande is als voorbeeld, ik heb als hoofd reden “Het product is te klein” aangemaakt, met een aantal sub redenen. Bij het aanmaken of bewerken van een retourreden kan de “Main reason” opgegeven worden. Zodra dit gedaan wordt is de retourreden die je bewerkt een sub reden van de geselecteerde main reason Als dit aangemaakt is krijgt de consument in de RMA in eerste instantie de hoofdredenen te zien, met vervolgens een extra keuze voor de sub reden. Dit ziet er als volgt uit: De sub reden is de reden die je vervolgens terugziet in de retouraanmelding. Outlet Als een product een klein beetje beschadigd is (2de kans) kan dit als outlet opgeboekt worden. Deze optie moet per klant ingeschakeld worden. Zie Voorraadbeheer - Outlet voorraad. Quarantaine Als de medewerker die de retouren verwerkt constateert dat een product beschadigd is kan het product naar de quarantaine voorraad geboekt worden. In de Montaportal kan per product aangegeven worden dat het betreffende product altijd naar quarantaine geboekt moet worden als het retour komt. Bij een retourreden kan ook ingesteld worden dat producten die met die retour reden worden ingeboekt altijd naar quarantaine moeten. Zie Voorraadbeheer - Quarantaine voorraad. Reconditioneren Het is ook mogelijk om aanvullende acties zoals strijken en wassen te registreren bij het verwerken van een retour. Deze worden dan op de factuur gezet (zie Facturatie). Retouren opvolgen Een geregistreerde retour wordt getoond op de Montaportal met de status dat deze nog opgevolgd moet worden. De consument moet namelijk een vervangend product krijgen, zijn of haar geld terugkrijgen, of iets dergelijks. Het opvolgen van retouren kan per stuk of voor meerdere retouren tegelijk (bulk). Automatisch refunden Het is ook mogelijk om de refund (het aankoopbedrag terugstorten naar de consument) automatisch te doen als de klant de retour op opvolgstatus \"Please refund\" zet. Dit kan alleen voor de platforms waarmee we een refund koppeling hebben. Zie koppelingen - refunds."
  },
  "Algemene-informatie/Selffulfilment/MontaShip-aanmaken/index.html": {
    "href": "Algemene-informatie/Selffulfilment/MontaShip-aanmaken/index.html",
    "title": "MontaShip aanmaken",
    "keywords": "MontaShip aanmaken Aanmaken Standaard MontaShip klant: Maak een account aan in de montaportal https://www.montaportal.nl/Admin/CreateNewCustomer Vervolgens maak je via de montaportal een simpel magazijn aan. Zoek in tblmagazijnen de vestiging op waar de klant onder komt en noteer dit ID. Zoek in tblmagazijnen je nieuwe magazijn op. Zet hier MagazijnRapportage aan, en zet onder vestiging het ID van de vestiging; zodat het magazijn gekoppeld is aan de vestiging waar hij bij hoort. Zoek in tblShipperCredentialsLink de contracten op van de vestiging waar de klant onder komt: select * from tblShipperCredentialsLink where MagazijnID = <Magazijn ID van de vestiging> En noteer de ID's van de vervoerders tblShipper die je wilt gebruiken. Ga je ook SEL gebruiken? Kijk dan onderaan deze pagina voor het instellen van de vooraanmelding. Maak vervolgens een nieuwe record aan voor je eigen magazijn met deze ID's. Zoek de tabel tblShipperAfhaaltijden. Maak hier nieuwe records voor elke vervoerder die je in het nieuwe magazijn wilt activeren. Noteer hier de ShipperID, MagazijnID en afhaaltijd., Veel gebruikte codes zijn: 15 SEL 30 SEL buspakje 151 DHLFYPakket 101 DHLParcelConnect 2 PostNL 88 PostNlBuspakje Maak een esetting/kanaal aan in GoMonta, zoals je normaal ook zou doen. Controleer hier of je aangemaakte magazijn inderdaad onder de juiste vestiging valt. Pas de Pakbon van de klant aan via: \\montapacking.nl\\dfs\\Appdata\\EsettingsAttachments\\ [esettingsID]. Een voorbeeld van de pakbon die je kan toevoegen is: pakbon.docx. Maak de Print&Verstuur pagina actief en deactiveer de gele (inkoop) knop. Houd van geel de retouren pagina aan. Voeg een Eigen Verpakking Drager toe aan het magazijn en de Esettings Postonderzoeken toevoegen aan het account: Rechten activeren in de Montaportal In de database: Tbl.Magazijnen in kolom ParcelInvestigationEmail het emailadres support@montaship.nl Notification emails instellen voor klant: Notification Emails - Montaportal Voeg de dimensies en gewichten toe aan de producten voor het berekenen van de vervoerder en aanvragen van de labels. Indien fictieve voorraad: Verhoog de limieten van het magazijn en boek de voorraad op in GoMonta DHL Parcel Voor DHL Parcel moet er een vooraanmelder ingesteld worden. Dit kan door in de tabel tblMagazijnenShipperCredentialsDhlParcel een entry toe te voegen voor je nieuwe magazijn. Zoek je magazijn ID Op Ga naar de tabel tblMagazijnenShipperCredentialsDhlParcel Zoek het magazijn van afleveren en kopieer deze gegevens maak een nieuwe entry met deze gegevens en het nieuwe magazijn ID Bijlagen Standaard pakbon: pakbon.docx Standaard shippermatrix MontaShip: MontaShip_Shippermatrix.xlsx"
  },
  "Algemene-informatie/Selffulfilment/index.html": {
    "href": "Algemene-informatie/Selffulfilment/index.html",
    "title": "Selffulfilment",
    "keywords": "Selffulfilment Selffulfilment is voor als klanten bepaalde orders zelf willen versturen. De labels kunnen ze maken via de Montaportal. De bedoeling is wel dat de zendingen worden aangeleverd op één van de Monta DC's. Aangezien onze volumecontracten met de verzenders vereisen dat de zendingen ook in Monta DC's worden aangeboden. Als een klant de zendingen wil aanbieden aan bijvoorbeeld pickup points van de vervoerders, moet hier een ander contract (of zelfs een andere verzender) voor ingesteld worden. Uitwerking Functionaliteiten Labels uit Montaportal Dit document is opgesteld om meer duidelijkheid te verschaffen over de twee functionaliteiten binnen de Montaportal die labels kunnen printen, namelijk de bruine knop en Pickend/Pickbaar. Er bestaat veel onduidelijkheid over deze functionaliteiten en er is steeds meer interesse vanuit zowel interne als externe partijen. In dit document zullen de verschillen tussen de twee functionaliteiten worden besproken, zodat het voor gebruikers duidelijker wordt welke functionaliteit in welke situatie het meest geschikt is. Daarnaast zal er ook worden gekeken naar mogelijke verbeteringen van deze functionaliteiten in de toekomst. Varianten 1. Self Fulfilment / Bruine knop De bruine knop kan zichtbaar gemaakt worden in de Montaportal en is de meest eenvoudige uitvoering. Hij bestaat uit de ‘Verzendbaar’ en ‘Gegenereerde labels’ pagina en je kunt gemakkelijk orders selecteren en labels uitprinten. 2. Pickend / Pickbaar De pickend/pickbaar knop is beschikbaar te maken onder ‘bestellingen’ en werkt iets gecompliceerder, maar is daardoor ook meer uitgebreid. De functionaliteit bestaat uit twee pagina’s, de ‘Pickbaar’ pagina en de ‘Pickend’ pagina. Zo is deze functionaliteit ook in te zetten met bijvoorbeeld voorraadbeheer. Self Fulfilment / Bruine knop Voorwaarden De order kan alleen met de bruine knop worden verzonden als hij de status ‘in wachtrij’ of backorder heeft. Algemene werking Orders die in de wachtrij staan en in backorder komen in het kopje ‘verzendbaar’. Hier kun je alle orders waar je labels voor wilt aanmaken selecteren en de knop ‘Generate labels’ aanklikken. Vervolgens kun je naar de ‘gegenereerde labels’ pagina en kun je de labels downloaden. Instellen De knop moet worden aangezet via de Admin instellingen. Functionaliteiten De Bruine knop heeft beperkte functionaliteiten. Je kunt labels genereren en deze eenmalig downloaden bij gegenereerde labels. Daarna komt de order bij ‘verzonden’, hier kun je het label ook nog raadplegen. Ondersteunde vervoerders DHL Parcel Ecom DHL For You (Ook Buspakje) PostNL (Geen Buspakjes en Pickuppoints) DPD UPS Trunkrs GLS Voordelen Je hoeft geen voorraad te houden Je kunt gemakkelijk backorders en open orders versturen Nadelen Pakketten moeten bij een Monta Vestiging worden aangeleverd. Orders die bij een Monta vestiging in de wachtrij staan kunnen worden verzonden via de Bruine knop. Zo kun je orders van een vestiging ‘wegpikken’ Printen van labels kan alleen via PDF Label verdwijnt na 3 dagen uit de Montaportal Orders moeten wel door de verify heen komen, geblokkeerde orders kunnen dus niet worden verzonden Alleen orders die backorder staan met een geschikte vervoerder komen in ‘verzendbaar’ tevoorschijn. Pickend / Pickbaar Voorwaarden Voor deze functionaliteit zijn een aantal vereisten om de werking te garanderen. De vereisten zijn hier genoteerd: Orders moeten worden ingeschoten op een apart kanaal Het kanaal waar de order op binnen komt moet een (simpel) magazijn hebben, wat niet een Montamagazijn is. Alle materialen in de order moeten voorraad hebben op het magazijn van het kanaal Alle materialen in de order moeten alle benodigde informatie hebben die we ook vereisen in ons normale proces. Denk hierbij aan dimensies en gewicht. Algemene werking De algemene werking van deze functie is het beheren van voorraad, mogelijk maken van picken van orders en uitprinten van labels. Het is perfect voor klanten die naast fulfilment bij Monta ook gebruik willen maken van eigen voorraadbeheer en de mogelijkheid van het orders picken en verzenden in een klein fysiek magazijn. De eerste pagina, ‘Pickbaar’, ziet er als volgt uit: Alle open orders die aangemaakt zijn op een kanaal dat is gekoppeld aan een (simpel)magazijn komen hier te staan en hebben de status in wachtrij, zoals wij deze kennen. Orders kunnen nog geblokkeerd en aangepast worden. Wanneer je een order wilt gaan picken en versturen, kun je de status aanpassen door deze orders te selecteren en op ‘set to picking’ te klikken. Vervolgens komen de orders in de lijst ‘pickend’. Hier kun je een picklijst uitprinten zodat je de orders kunt opzoeken in je magazijn. Hier kun je per order of in bulk een picking list genereren. Met de picking list kun je de producten picken in je magazijn. Wanneer alles gereed is voor verzending kun je de orders waar je labels voor wilt selecteren en op ‘create labels’ klikken. Vervolgens krijg je een keuzemenu hoe je de labels wilt printen. Dit kan op 3 manieren: PDF Bestand (A4 met startpositie of A6) Zebra Printer met printclient (ZPL) Dymo Printer (PDF) Daarnaast krijg je wat informatie over de verzender en de vereisten voor deze verzender. Wanneer er een SKU is die niet verzonden kan worden is dit het moment dat je een foutmelding krijgt. Bijvoorbeeld: Instellen Voor een klant die gebruik wilt maken van de pickend/pickbaar moet het volgende worden ingesteld, naast de normale stappen voor een montaportal: (Simpel) Magazijn aanmaken Kanaal, gekoppeld aan magazijn Knoppen beschikbaar maken in Admin settings Vervolgens moet er voorraad worden geboekt voor de materialen op de locatie(s) in het magazijn. Functionaliteiten Voordelen van de magazijnfunctionaliteit Aparte orderstroom / Kanaal Gebruik maken van de picking list Veel mogelijkheden voor uitprinten label Labels terugvinden bij bijlagen in verzonden orders Ondersteunde vervoerders (getest) DHL For You (incl Buspakje, pick-up points en bezorgopties) PostNL (Incl Buspakje, pick-up points en bezorgopties) DPD Voordelen Het is mogelijk om labels op verschillende manieren te printen. De labels kunnen geprint worden op PDF, Via de Zebra printer (ZPL) (Printing Client vereist) of een Dymo Printer (PDF) Het is mogelijk om in bulk labels te printen Het is mogelijk om een picklijst te maken van orders die je moet pakken. Let op, dit is een andere dan die in GoMonta. Verzonden orders komen bij de ‘verzonden’ lijst, en hier kan het label opnieuw geprint worden. Voor de meeste vervoerders hoeven de pakketten niet bij een Monta Vestiging ingeleverd te worden. Orders die via pickbaar/pickend gaan zijn ook vindbaar in de echeck. Nadelen De situatie heeft veel voorwaarden nodig om te kunnen werken Pakketten die worden verzonden met labels uit de montaportal worden niet door een vestiging verstuurd. Wellicht is dit commercieel niet interessant. Er wordt geen rekening gehouden met het selecteren van een drager. Standaard wordt de vervoerder berekend op de afmetingen van het grootste product, dit wordt dan ook de drager (eigen verpakking) Je kunt maar 1 etiket per eorder aanmaken, 2 of meer colli per eorder is dus niet mogelijk, behalve als je de order splitst. Je kunt niet automatisch een proforma printen terwijl je het label print. Bij een fout in het aanvragen van het label krijg je een algemene error code, in de logs kun je pas zien wat er precies fout is. Dit levert veel klantvragen op."
  },
  "Algemene-informatie/ShipAndPrint/index.html": {
    "href": "Algemene-informatie/ShipAndPrint/index.html",
    "title": "ShipAndPrint",
    "keywords": "ShipAndPrint Ship & Print Print & Ship Met Print & Ship kan de klant gemakkelijk pakketten versturen zonder gebruik te maken van een Warehouse Management System (WMS). In plaats daarvan maakt Print & Ship gebruik van de Montaportal. Print & Ship maakt veelal gebruik van kunstmatige voorraad en er is geen koppeling met de voorraad van een magazijn. Dit betekent dat de applicatie vooral bedoeld is voor labels en orderverwerking en minder geschikt is voor uitgebreide voorraadbeheer taken. Print & Ship is een applicatie die momenteel door twee afdelingen binnen het bedrijf wordt verkocht, namelijk de WMS-afdeling en de Sales-afdeling. De WMS-afdeling richt zich op de verkoop van Print & Ship aan klanten die nog geen gebruik willen maken van een Warehouse Management System. Voor deze klanten is Print & Ship een handige aanvulling op hun bestaande systeem, omdat het de mogelijkheid biedt om pakketten te verzenden zonder dat er een volledige integratie met het WMS nodig is. Vervoerders naar eigen wensen Prospect WMS Hoge orderaantallen Klant van WMS De Sales-afdeling richt zich op de verkoop van Print & Ship aan kleinere klanten die geen gebruik maken van een WMS. Voor deze klanten biedt Print & Ship een gemakkelijke opstap naar het Monta® systeem. Klant van de vestiging Lagere orderaantallen (Max 30K) Ex of prospect Fulfilment Vervoerders vanuit ons bepaald Door de verkoop van Print & Ship door twee verschillende afdelingen, wordt er ingespeeld op verschillende behoeften en wensen van klanten. Hierdoor kan Print & Ship aan een breed publiek worden aangeboden en kan er optimaal worden ingespeeld op de specifieke eisen en wensen van elke individuele klant. De verwachting is dat Print & Ship snel zal groeien. De visie is het uitrollen van de Print & Ship applicatie met als doel de vervoerdersstaffels te halen; meer omzet te genereren; en Print & Ship als opstapje te gebruiken voor potentiële (WMS)klanten. De overzichtspagina De overzichtspagina ziet er uit zoals de bekende Montaportal pagina’s. De orders waarvoor je labels/pakbonnen wilt printen kunnen via de vinkjes aan de linkerkant geselecteerd worden. De bekende filters kunnen gebruikt worden om bijvoorbeeld te kunnen filteren op vervoerder. Labels/pakbonnen selecteren Op de pijl die je naast 'Print & verstuur' kunt vinden is kan je klikken om een pop-up tevoorschijn te laten komen. In deze pop-up kan je vervolgens kiezen of je verzendlabels of juist pakbonnen wilt printen. Allebei selecteren is natuurlijk ook een optie. Selecteren doe je door middel van het selecteren van de vinkjes. De instellingen worden automatisch opgeslagen. Vervoerder aanpassen Het is ook mogelijk om de vervoerder van de orders aan te passen. Dit doe je eerst door de orders te selecteren die je wilt gebruiken, om vervolgens te klikken op 'Verander vervoerder'. Deze klik toont een pop-up waar je alle beschikbare vervoerders ziet. Alleen de vervoerders die toegepast kunnen worden op alle geselecteerde orders worden getoond in de lijst. Als je bijvoorbeeld 10 'PostNL pakket' orders hebt geselecteerd, dan zal een 'PostNL briefpost' nooit getoond gaan worden. Een pakket past immers niet door de brievenbus. De vervoerder wijzigen doe je door het selecteren van de gewenste vervoerder en vervolgens op 'Vervoerder wijzigen' te klikken. Print instellingen Ook is er de knop 'Print instellingen'. Wanneer je hier op klikt kun je instellen wat voor printer je wilt gebruiken met daarbij diverse instellingen. Wanneer deze pop-up tevoorschijn komt kan je selecteren of je de labels wilt genereren als een PDF bestand of dat je de labels direct door wilt sturen naar een Zebra (ZPL) of een Dymo printer. Hier dien je dan wel de correcte software voor de desbetreffende printer geinstalleerd te hebben op je PC. Een PDF-bestand kan gewoon handmatig via de Windows uitgeprint worden. Pakbonnen worden altijd als een PDF bestand gegenereerd en deze moet je dus dan ook zelf uitprinten. Printen maar! Wanneer alles naar wens is, kan je de orders selecteren en vervolgens op 'Print en verstuur' klikken. Wanneer je de PDF optie hebt gekozen, zullen er twee vensters geopend worden waar je vervolgens die print-acties kunt uitvoeren. Heb je voor een Zebra of een Dymo gekozen, dan wordt de opdracht naar deze printer verstuurd. De orders verdwijnen vervolgens automatisch uit de lijst."
  },
  "Algemene-informatie/Voorraadbeheer/ABC-categorieen-op-een-koppellabel/index.html": {
    "href": "Algemene-informatie/Voorraadbeheer/ABC-categorieen-op-een-koppellabel/index.html",
    "title": "ABC categorieen op een koppellabel",
    "keywords": "ABC categorieen op een koppellabel Op deze pagina wordt uitleg gegeven over de ABC-analyse en categorisering. Wat is ABC? De ABC-analyse is een vaak terugkerend begrip in de logistiek. Hiermee worden voorraadprocessen geoptimaliseerd door de nadruk te leggen op de belangrijkste artikelen. De producten die het vaakst worden verkocht, worden aangeduid met een 'A'. Producten die iets minder worden verkocht met een 'B' en producten die bijna niet verkocht worden, worden aangeduid met een 'C', ook wel bekend als de slowmovers. Wat zijn de suggesties per categorie? Deze classificaties dienen als ondersteunend advies bij het koppelen van voorraad. Door de voorraad slim te koppelen, win je productiviteit bij het picken van artikelen. Onderstaand enkele ondersteunende suggesties per categorie: A Fastmovers: Leg deze artikelen op toegankelijke locaties in het magazijn. Dit kunnen voorraadlocaties zijn met een korte afstand tot de echeck of locaties die zich op een ergonomische positie in een legbordstelling bevinden. B Average: Voor artikelen in deze categorie hoeft er niet per se iets te veranderen. Je zou de meest optimale locaties in het magazijn kunnen overslaan bij het koppelen van deze artikelen, maar actief de minder ideale locaties opzoeken is niet nodig. C Slowmovers: Deze artikelen kan je het beste koppelen op de minste geschikte locaties. Hierbij kan je denken aan locaties die zich verder in het magazijn of in gangpaden bevinden, maar ook aan het laagste en hoogste niveau in een legbordstelling. Welke producten zitten in welke categorie? Er is een PowerBI rapport gebouwd waarin te zien is wat de verhoudingen tussen de verschillende categorieën is. Daarnaast zijn alle producten per magazijn hier te zien, inclusief de bijbehorende categorie. Het rapport is te vinden tussen de Customer service rapportages en heet 'ABC-analyse'. Of gebruik onderstaande link: https://gomonta.montapacking.nl/Office/Reports/Details?TargetAddress=1624aa4d-9cce-46a5-af0b-930e363ddc16&reportId=129 Hoe worden de classificaties berekend? Er wordt dagelijks per magazijn berekend wat de afzet van een product in de afgelopen 4 weken (28 dagen) is geweest. Waarbij de meest recente week het zwaarst meeweegt om snel veranderende patronen mee te kunnen nemen in de berekening. Vervolgens worden alle artikelen via de berekening toegevoegd in de onderstaande categorieën: Let op! Zodra een artikel nieuw is en er nog geen historische data beschikbaar is, zal er nog geen classificatie worden toegevoegd. Na een aantal dagen zal dit nieuwe product vanzelf in een categorie terecht komen."
  },
  "Algemene-informatie/Voorraadbeheer/Barcodes/index.html": {
    "href": "Algemene-informatie/Voorraadbeheer/Barcodes/index.html",
    "title": "Barcodes",
    "keywords": "Barcodes Barcode scannen Een barcodescanner functioneert als een toetsenbord. De barcodescanner vertaalt de streepjes naar tekens (letters, cijfers, etc) en voert deze in in de software. De ingevoerde tekens worden vergeleken met de barcodes van de producten om het product te vinden. GS1 barcodes Sommige producten bevatten GS1 barcodes. Deze zijn te herkennen aan de (..) in de code. De haakjes zijn alleen verwerkt in de geprinte tekst. De barcode zelf ‘scant’ alleen de nummers tussen de haakjes. GS1 barcodes bevat een ‘encoded’ EAN. Dat wil zeggen dat e.e.a. omgerekend moet worden om EAN uit deze code te filteren. Zie https://www.omnicalculator.com/finance/gtin-check-digit voor meer info. Naast GTIN/EAN kan een GS1 barcode ook informatie over Batch, THT, hoeveelheid in omdoos, etc bevatten. https://www.gs1.org/standards/barcodes/application-identifiers In de meeste Monta-applicaties zal bij het scannen van een GS1 code automatisch de EAN berekend worden."
  },
  "Algemene-informatie/Voorraadbeheer/Bijvullen/index.html": {
    "href": "Algemene-informatie/Voorraadbeheer/Bijvullen/index.html",
    "title": "Bijvullen",
    "keywords": "Bijvullen Via deze functie is het mogelijk om picklocaties tijdig aan te vullen vanaf bulklocaties via vooraf ingestelde veiligheidsvoorraad. Deze veiligheidsvoorraad werkt per SKU en is in handmatig te stellen in Gomonta. Op het moment dat het voorraadniveau van een betreffend SKU het veiligheidsniveau heeft bereikt, zal er een bijvulopdracht worden aangemaakt in de handscanner. De functie 'bijvullen' activeren De functie is te activeren door middel van de onderstaande stappen: Ga in Gomonta naar voorraadbeheer instellingen; Activeer de functie genaamd: 'Voorraad optimaliseren met handscanners'; De veiligheidsvoorraden instellen Via de volgende twee manieren zijn de veiligheidsniveau's in te stellen voor de gewenste SKU's: In Gomonta is er een mogelijkheid om op SKU-niveau een waarde op te geven. Deze waarde kan in het onderstaande invulvakje worden toegevoegd: Als de veiligheidsniveau's liever in bulk worden ingesteld, is dit mogelijk via de product import in het tabblad voorraadbeheer in Gomonta: Het bijvullen Nadat de bovenstaande stappen zijn uitgevoerd, worden de bijvulopdrachten automatisch aangemaakt zodra de voorraadstanden op handmatig bereikbare locaties onder de ingestelde waarde komt. Deze bijvulopdrachten zijn te vinden in de handscanner onder de groene knop: 'voorraad optimaliseren' en vervolgens onder: 'voorraad bijvullen'. Stap 1: Stap 2: Stap 3: Stap 4: Dit scherm laat alle producten zien waarbij een 'minimaal gewenste handmatig bereikbare hoeveelheid' is ingesteld. De producten waarbij te weinig voorraad handmatig bereikbaar is zijn rood omrand en staan bovenaan de lijst. Bij \"doelwit\" staat de ingestelde minimaal gewenste handmatig bereikbare hoeveelheid. Stap 5: Na het kiezen van een product worden de locaties getoond waar het product staat. Hier kan een locatie gekozen worden. Stap 6: In deze stap is er te zien waar de artikelen gepickt kunnen worden en naar welke locatie de artikelen gebracht mogen worden. Stap 7: Na het scanne van de locatie waar de artikelen heengebracht mogen worden, wordt onderstaande bevestiging getoond. Zoektags: bijvullen, bijv, bijvu, bijvul, bijvull, bijvulle, bij vullen, repl, reple, replen, repleni, replenis, replenish, replenishen, minimum voorraad, voorra, voorra, voorr, voor, voo,"
  },
  "Algemene-informatie/Voorraadbeheer/Bouwstenen-warehouse-inrichting/index.html": {
    "href": "Algemene-informatie/Voorraadbeheer/Bouwstenen-warehouse-inrichting/index.html",
    "title": "Bouwstenen warehouse inrichting",
    "keywords": "Bouwstenen warehouse inrichting Inleiding ​Monta heeft als ambitie om stevig te groeien, maar tegelijkertijd de individuele vestigingen relatief klein te laten zijn, zodat de positieve dingen van een kleiner persoonlijker bedrijf blijven bestaan. Om toch te kunnen doorgroeien, zal dat leiden tot meer vestigingen. De gedachte daarachter staat beschreven in deze ​inleiding. Klik hier om naar de pagina te gaan over nieuwe vestigingen. ​Monta groeit snel. Steeds sneller onstaan nieuwe vestigingen of breiden vestigingen uit. Om die groei gemakkelijker te maken is bedacht om zoveel mogelijk bouwstenen te ontwikkelen die je kunt gebruiken in je vestiging. Steeds meer standaard bouwblokjes maken dat je snel kunt opschalen als dat nodig is en dat bouwblokjes die al in andere vestigingen ontwikkeld en geprobeerd zijn overgenomen kunnen worden zonder dat je zelf weer het wiel moet uitvinden. Intern transport Voor het interne transport in magazijnen zijn allerlei hulpmiddelen beschikbaar. Degenen die in de afgelopen jaren het meest in gebruik zijn genomen worden hier beschreven. ​​​​Afvalvoorzieningen ​Voor het schoon en opgeruimd houden van de magazijnen zijn hulpmiddelen nodig. Een aantal hierbij zijn onderstaand beschreven. Krattenkar Voor In sommige processen is er vrij veel transport van lege blauwe kratjes. Hiervoor zijn op maat gebouwde karren verkrijgbaar waar relatief veel kratjes op passen die stabiel blijven staan. De kar is goed verplaatsbaar tussen verdiepingen met een goederenlift. Voor bestellen kun je contact opnemen met techniek@monta.nl Bezemrek Voor het ophangen van bezems en veger&blik zijn standaard borden beschikbaar. Het voordeel van het toepassen van zulke borden is dat de bezems kunnen worden teruggehangen op een vaste plek, zodat medewerkers de bezems gemakkelijk kunnen vinden als ze hun werkplek glad willen houden. Dit bezemrek is te bestellen bij techniek@montapacking.nl​ Ophangen kan gedaan worden door de Technische Dienst, maar als gekozen wordt dat iemand van de vestiging zelf het bord ophangt, kan bij bestellen gevraagd worden om een setje schroeven en pluggen erbij. ​​​ Er zijn eventueel blauwe bezems en veger&blik te krijgen in de kleur blauw. Het handigs is om die direct bij de webshop te bestellen: https://www.manutan.nl/nl/mnl/steel-met-schroefverbinding-o-34-mm​ (bezemsteel) https://www.manutan.nl/nl/mnl/borstel-vikan-voor-intensief-gebruik-vloerborstel-a021245​ (bezem) ​https://www.manutan.nl/nl/mnl/set-schop-en-stoffer-haccp-manutan (veger&blik) Heftruck, pompwagen etc ​Heftruck, reachtruck, pompwagens worden door verschillende vestigingen bij verschillende leveranciers gehaald. Het handigst is om hierover met andere vestigingsmanagers te overleggen. Onderstaand wat namen van leveranciers. https://www.devriesheftrucks.nl/contact.aspx#main​ https://www.still.nl/ contactpersoon Benjam van der Waal https://www.petim.nl/​ voor gebruikt Pickkarren Herkenbaar maken van een pickkar Bulkpick karren herkenbaar gemaakt door bijvoorbeeld namen van steden Tijdens drukke dagen, als er veel orderpickers in het magazijn lopen en soms ook ondervaren mensen ingehuurd worden, komt het soms voor dat mensen tijdens het picken van bulk orders (bijvoorbeeld S-orders of PUTL orders) per ongeluk producten in elkaars karren gooien. Dit kan vooral voorkomen als karren in de brede paden blijven staan en de medewerkers de smalle paden inlopen. In Papland is daarom getest om de karren herkenbaar te maken, zodat je gemakkelijker kunt onthouden \"Ik was bezig met de kar ROME of met de kar DONALD DUCK\"​. In Papland is gekozen voor stickers met daarop de naam van een stad en een symbool zodat het ook herkenbaar is voor orderpickers die een andere taal spreken. Maar er kan ook worden gedacht aan bijvoorbeeld een vlaggetje met een afbeelding van een dier ofzo op een winkelwagen. Bulkpickkarren verhogen​ In Papland is een expiriment gedaan om de grijze bulkpickkarren van hogere poten te voorzien, zodat mensen die aan het picken zijn minder hoeven te bukken. Dit geldt ook voor mensen bij de echeck en PutToLight. Goederenheffer Sinds 2020 kopen we goederenheffers vaak bij Stapro. Het proces om zo'n goederen heffer te bestellen start vaak met inmeten van de vloerhoogtes en kiezen hoe de deuropeningen van de goederenheffer moeten. Tot nu toe deed Marien den Besten (marien@montapacking.nl) dat vaak. De verwachting is dat dit door de Technische Dienst wordt gedaan in de toekomst. Bij het inmeten wordt ook gekeken of de goederenheffer goed geplaatst kan worden, omdat de goederenheffer vaak in 1 stuk binnenkomt en dus de route naar de plek waar de goederenheffer komt te staan geschikt moet zijn. Na het meten wordt een offerte aangevraagd. Na akkoord op de offerte gaat de levertijd die vaak een maand of 4 is lopen. Akkoord op offerte wordt gegeven door de vestigingsmanager. Vervolgens wordt een leverdatum doorgegeven. Het plaatsen wordt door de leverancier Stapro gedaan en tot nu toe was Marien daar ook altijd bij om te helpen met manouvreren met heftruck/reachtruck. ​ De goederenheffer staat gewoon bovenop een bestaande betonnen magazijnvloer, maar ook op een asfaltvloer is al eens een goederenheffer geplaatst. Hierdoor is het niet nodig voorz​ieningen in de vloer te maken. Wel geeft dit een oprijhoogte op de begane grond van tussen de 7 en 10 cm. ​​De goederenheffer heeft een 380/400V 16A -5 polig​e stroomaansluiting nodig als voorbereiding. Werkplek in het warehouse Voor werkplekken in het warehouse zijn veel verschillende oplossingen beschikbaar. Degenen die in de afgelopen jaren het meest in gebruik zijn genomen worden hier beschreven. Echecktafel ​De oranje houten echecktafels met hoogteverstelling worden gemaakt door de 'huistimmerman' van Monta. Bestellen kan door een mailtje te sturen naar Martin Wessels (TimmerbedrijfMW@hotmail.com / 06-54907398)​ De meestgebruikte tafel heeft een afmeting van 90 bij 180 cm Levertijd is meestal ca 3 weken Martin komt de tafels op locatie brengen in delen. De delen kunnen dan met enkele schroeven aan elkaar gezet worden op de plek waar de echecktafel moet komen te staan. Voorbereidingen voor een echecktafel bestaan uit het beschikbaar maken van een stroomaansluiting en een netwerk aansluiting. Bij een echecktafel zijn verschillende uitbreidingen te verkrijgen. Echeck-organizer doosjes Een opzetstuk zodat verpakkingsmateriaal boven op de echecktafel geplaatst kan worden. (Bestellen kan door een mailtje te sturen naar Martin Wessels (TimmerbedrijfMW@hotmail.com / 06-54907398)​ Een voorbeeld van deze opzetstukken is te zien in papland. Echeck-organizer zakken Een uitbreiding op de echecktafel is een lade voor het gemakkelijker kunnen pakken van verzendzakken, maar ook een lade voor flyers als echecktoevoegproduct is denkbaar. Bestellen kan door een mailtje te sturen naar Martin Wessels (TimmerbedrijfMW@hotmail.com / 06-54907398) Een voorbeeld van deze echeck organizer zakken is te zien in Papland. Echeck-organizer plakband Een andere uitbreiding is een bordje waar zaken als plakbandautomaten, verzendlabels en mesjes een vaste plek hebben bestellen kan via techniek@montapacking.nl​​​​ Kassa Scanner Een nieuwe mogelijkheid om de echecktafel te versterken is de kassa scanner. Deze scanner, te zien op onderstaande afbeelding, lijkt op een variant die in supermarkten gebruikt wordt bij kassa's. De eerste scanner is enige tijd geleden geïnstalleerd in de vestiging op Papland. Wat zijn de voordelen van deze scanner? Beide handen blijven vrij tijdens het inpakken; De scanner reageert sneller dan de gebruikelijke scanners; Deze scanner beschikt over een grotere invalshoek voor het lezen van barcodes; Tijdens het scannen is het makkelijk om te focussen op de interactie op de monitor. Wanneer komt de scanner het best tot zijn recht? De meeste orders bevatten minimaal drie orderlijnen; Een hoge bezettingsgraad aan de betreffende echeck tafel; De meeste orders bevatten relatief kleine artikelen. Bestellen of verdere informatie opvragen kan via techniek@montapacking.nl​​​​ ​Inbound tafel De gelehouten inboundtafels met hoogteverstelling worden gemaakt door de 'huistimmerman' van Monta. Bestellen kan door een mailtje te sturen naar Martin Wessels (TimmerbedrijfMW@hotmail.com / 06-54907398)​ De meestgebruikte tafel heeft een afmeting van 90 bij 180 cm Levertijd is meestal ca 3 weken Martin komt de tafels op locatie brengen in delen. De delen kunnen dan met enkele schroeven aan elkaar gezet worden op de plek waar de echecktafel moet komen te staan. Op onderstaande foto zijn scanner/printer en labelprinter nod niet geplataats, maar daar is wel ruimte voor. Voorbereidingen voor een inboundtafel bestaan uit het beschikbaar maken van een stroomaansluiting en een netwerk aansluiting. Inboundmal Bij mode klanten met wisselende assortimenten en bij nieuwe klanten met veel SKU's, is het tijdrovend om bij inbound de producten op te meten. Daarnaast is het bij kleding soms verwarrend of je het in opgevouwen toestand meten moet, of uitgevouwen. Hiervoor is een hulp mal beschikbaar, waarmee je kunt passen of een kledingstuk in opgevouwen toestand door de brievenbus kan. Vervolgens kun je door de barcode op de mal te scannen in 1 keer de afmetingen overnemen in het inbound scherm. Elektrisch laden station Het elektrisch laden station is een standaard stelling met brandwerende platen van 2 x 2 x 0,6 meter. In het station kunnen de opladers van elektrische transportmiddelen zoals heftruck en elektrische pompwagen veilig worden geplaatst. Bestellen of verdere informatie opvragen kan via techniek@montapacking.nl​​​​ Picken en consolideren ​Voor picken en consolideren zijn een aantal bouwstenen beschikbaar. Echeckwall en PutToLight zijn erop gericht zoveel mogelijk in bulk te picken en later orders samen te stellen en deze bouwstenen zijn geschikt voor een vrij diverse groep van relatief kleine producten. PickToLight is vooral geschikt voor klanten met een smal assortiment met kleine producten en veel orders. ​Echeckwall ​Een Echeckwall is als module beschikbaar die compleet aangeleverd wordt. Bestellen kan bij R&D, via Kevin Zijlmans (kzijlmans@montapacking.nl​​) Er zijn een aantal Echeckwalls met een standaard indeling uit voorraad leverbaar. Vaak worden modules van echeckwalls aan elkaar gekoppeld, maar ze zijn ook los inzetbaar. De vakjes van de echeckwall kunnen gekozen worden, dus heb je een hele specifieke product afmeting, kan daarvoor een speciale echeckwall samengesteld worden. Maar voor de meeste producten voldoet de standaard indeling. Gewenste indeling van een echeckwall kan ook met Kevin doorgenomen worden. Voorbereidingen voor een echeckwall bestaan uit het beschikbaar maken van een stroomaansluiting en een netwerk aansluiting. IT systems ​Voor veel onderdelen van het logistieke proces zijn IT systemen nodig. Onderstaand een beginnetje welke systemen dat zijn en waar je ze kunt bestellen. ​Montatron ​Voor zowel de echecktafels als de inbound tafels is een standaard concept beschikbaar, de montatron. Dit is eenvoudigweg een computer, scherm, toetsenbord en barcode scanner. Deze montatrons kunnnen besteld worden via servicedesk@montapacking.nl. Wanneer je dan aangeeft of het om een echeckstation of een inboundstation gaat, kunnen gelijk de juiste printers meegeleverd worden.​ Voorbereidingen voor een montatron bestaan uit het beschikbaar maken van een stroomaansluiting en een netwerk aansluiting​. Laadkast scanners Voor het opladen van de pistoolscanners is een standaard scannerkast en beheersysteem beschikbaar. De scannerkast kan besteld worden via techniek@montapacking.nl​​​​ Via servicedesk@montapacking.nl kan gevraagd worden met hulp om de scannerkast werkend te krijgen op locatie. Voorbereidingen die nodig zijn voor een scannerkast is 1 werkende netwerk kabel en 1 stopcontact van 230 VAC. Urenkloksysteem Voor het registreren van uren van medewerkers die in een vestiging werken, zijn urenkloksystemen beschikbaar. Deze werken met dezelfde rfid badges die medewerkers ook gebruiken om in te loggen in de pistoolscanners en bijvoorbeeld de echeckapp. Een urenkloksysteem is te bestellen via techniek@montapacking.nl​​​​ Voorbereidingen die nodig zijn voor een urenkloksysteem is 1 werkende netwerk kabel en 1 stopcontact van 230 VAC. Magazijnborden legbordstellingen We hebben de mogelijkheid om goed geprijsde bordjes te kopen om een eenvoudige manier. Uiteraard zijn magazijnborden een eenvoudige manier om meer structuur in het magazijn aan te brengen. De borden inclusief bevestigingsmateriaal kosten afhankelijk van de oplage ongeveer €9,50. Na bestelling worden de borden momenteel binnen drie weken geleverd. De borden zijn in onderstaande vier kleuren te bestellen. Deze kleuren zijn ook instelbaar, zodat de interface in de handscanner overeen komt met de kleur van de borden: De magazijnborden zijn te bestellen door een mail te sturen aan techniek@monta.nl om zo de bestellijst aan te vragen. Strips met magazijnlocaties voor bakjeskasten Het is via PB-services mogelijk om de locatiesnummers direct op strips te laten drukken. Deze strips kunnen direct in de bakjeskasten geschoven kunnen worden. Dit scheelt in de kostprijs en tevens in de benodigde arbeid. Verder zullen deze strips minder snel slijten dan de losse labels. In de onderstaande afbeelding is op de linkerhelft de manier weergegeven met losse labels en op de rechter helft de manier met de voorgedrukte strips. ​​"
  },
  "Algemene-informatie/Voorraadbeheer/Cycle-counten/index.html": {
    "href": "Algemene-informatie/Voorraadbeheer/Cycle-counten/index.html",
    "title": "Cycle counten",
    "keywords": "Cycle counten Zie ook: Algemene informatie - Voorraadbeheer - Cycle count. Als de gebruiker wil gaan tellen, krijgt hij/zij 2 keuzes: Telwachtrij – dit betekent dat er specifieke locaties geteld worden Tellen zonder wachtrij – de gebruiker kan elke willekeurige locatie gaan tellen Telwachtrij Net als bij het picken kan er een keuze gemaakt worden op welke verdieping er geteld gaat worden. Als extra moet de gebruiker ook aangeven in welk gangpad hij/zij gaat tellen. Na het maken van deze keuze worden alle locaties uit dit gangpad toegewezen aan de gebruiker. Deze locaties moet de gebruiker allemaal gaan tellen, maar er is ook een keuze om te stoppen met tellen. Dan worden de toegewezen locaties weer vrijgegeven. Tellen zonder wachtrij Als er wordt gekozen om te tellen zonder wachtrij, krijgt de gebruiker het volgende scherm te zien. Hier kan een locatie gescand of ingetypt worden. Locatie tellen De informatie van de locatie wordt opgehaald en getoond. Mocht de locatie leeg blijken te zijn, kan er direct op de rode knop “Locatie is leeg” geklikt worden. Er zal om een bevestiging gevraagd worden. Daarna wordt dit direct ingevoerd. Als er wel producten op de locatie liggen, kan er een product gescand of ingetypt worden. Het systeem gaat dan de informatie van dit product ophalen en laat vervolgens een schermpje zien waar het aantal ingevoerd kan worden. Met het blauwe toetsenbord kan het aantal producten dat op locatie ligt ingevoerd worden. Vervolgens moet er op de knop “OK” geklikt worden, zodat het aantal wordt onthouden. Het getelde product wordt toegevoegd aan de lijst met ‘Materialen op locatie’. Rechtsboven staat het aantal dat door de gebruiker is geteld. Mocht de gebruiker een fout gemaakt hebben tijdens het tellen, kan dit gecorrigeerd worden. Dit kan op 2 manieren: Het product nogmaals scannen. Op de regel met het product klikken. Hierna worden er twee opties getoond: opnieuw tellen of materiaal ligt niet meer op voorraad. Met de tweede optie wordt het product weer uit de lijst met ‘Materialen op locatie’ gehaald. Opties om een telling af te ronden Telling opslaan – de telling wordt vergeleken met de administratieve voorraadstand op locatie. Als deze overeenkomen wordt de telling opgeslagen, anders wordt er aangegeven dat de locatie nogmaals geteld moet worden. Reset – alle getelde producten op deze locatie worden weer weggehaald, zodat de gebruiker opnieuw kan beginnen. Stop – de telling wordt afgebroken. Er wordt niets opgeslagen."
  },
  "Algemene-informatie/Voorraadbeheer/Klant-uitruimen/index.html": {
    "href": "Algemene-informatie/Voorraadbeheer/Klant-uitruimen/index.html",
    "title": "Klant uitruimen",
    "keywords": "Klant uitruimen Om alle voorraad van een klant af te boeken is het het handigst om een order te maken op de Montaportal."
  },
  "Algemene-informatie/Voorraadbeheer/Klant-verhuizen-naar-ander-magazijn/index.html": {
    "href": "Algemene-informatie/Voorraadbeheer/Klant-verhuizen-naar-ander-magazijn/index.html",
    "title": "Klant verhuizen naar ander magazijn",
    "keywords": "Klant verhuizen naar ander magazijn Voorraad verplaatsen Voorraad van een klant kan verhuist worden naar een ander magazijn door het in het ene magazijn te verplaatsen naar move labels en in het andere magazijn er vanaf. Backorders De voorraad op move labels telt als 'transit' voorraad. Standaard wordt dit meegeteld als beschikbare voorraad in de voorraadkoppeling naar de webshop. De klant kan dus gewoon doorverkopen. Bij de voorraadkoppeling kan echter ook ingesteld staan dat transit voorraad niet wordt meegeteld. Het is ook mogelijk om bij de voorraadkoppeling in te stellen dat alleen de voorraad van bepaalde magazijnen wordt meegeteld. Het is ook mogelijk (tijdelijk) vanuit meerdere magazijnen te verzenden. Zie Algemene informatie - Outbound - Verzenden vanuit meerdere magazijnen."
  },
  "Algemene-informatie/Voorraadbeheer/Magazijn-indeling/index.html": {
    "href": "Algemene-informatie/Voorraadbeheer/Magazijn-indeling/index.html",
    "title": "Magazijn indeling",
    "keywords": "Magazijn indeling Op deze pagina wordt uitleg gegeven over de verschillende termen die je tegen kan komen binnen een magazijn. magazijn verdieping Zone Stelling Nivo vak locatie sticker"
  },
  "Algemene-informatie/Voorraadbeheer/Magazijnlocatie-tool/index.html": {
    "href": "Algemene-informatie/Voorraadbeheer/Magazijnlocatie-tool/index.html",
    "title": "Magazijnlocatie tool",
    "keywords": "Magazijnlocatie tool Met de magazijnlocatie tool kunnen magazijnlocaties gemaakt, aangepast en verwijderd worden. Nummering Om makkelijk locaties toe te voegen probeert de tool de nummering van een stelling te herkennen. Een nieuwe locatie krijgt dan het volgende nummer in de nummering. Het kan echter zijn dat de nummering van een bestaande stelling zo complex is dat de nummering niet wordt herkend. De tool zou dan alle locaties gaan hernoemen waardoor de hele stelling opnieuw gestickerd zou moeten worden. Om dit te voorkomen kunnen er geen locaties aangepast worden in een stelling waarvan de nummering niet herkend wordt."
  },
  "Algemene-informatie/Voorraadbeheer/Warehouseviewer-&-warehousemapper/index.html": {
    "href": "Algemene-informatie/Voorraadbeheer/Warehouseviewer-&-warehousemapper/index.html",
    "title": "Warehouseviewer & warehousemapper",
    "keywords": "Warehouseviewer & warehousemapper De warehouseviewer en warehousemapper zijn twee tools die helpen bij het optimaliseren van het warehousehouse. De warehousemapper wordt gebruikt om het magazijn inclusief stellingen en werkplekken in te tekenen. Vervolgens kunnen er verschillende analyses gedaan worden in de warehouseviewer. De warehousemapper is te gebruiken voor onder andere: Het gemakkelijk deactiveren van vakken en stellingen; Het configureren van de looproutes. De warehouseviewer heeft in ieder geval de volgende functionaliteiten: Het tonen van live activiteiten in het warehouse; Het tonen van de pickroutes in het warehouse; Het tonen van de vullingsgraad in het warehouse; Het tonen van een heatmap van het warehouse. De WarehouseViewer De warehouseviewer wordt gebruikt om inzicht te krijgen in de magazijnprocessen. De warehouse viewer kan gezien worden als een bovenaanzicht van het magazijn, waarin verschillende processen inzichtelijk gemaakt worden. Om te starten met het gebruik van de warehouse viewer, is het nodig eerst een 'mapping' te maken van het magazijn via de warehouse mapper. Dit is eigenlijk het plaatsen van de stellingen en objecten op hun positie in de plattegrond van het magazijn. Wanneer de map gereed is, kan de warehouse viewer gebruikt worden. Hoe kom ik bij de warehouse viewer In de Montaportal is de warehouse viewer te vinden. Sommige klanten in montaportal zijn eigenaar van een magazijn en in dat geval kun je de warehouse viewer vinden. Alle Monta fulfilment vestigingen zijn bijvoorbeeld zo'n magazijn eigenaar, daarnaast zou dit ook gelden voor de WMS-klanten. Wat kan je met de WarehouseViewer? Voorraad inzichten Pickroutes Pick heatmap Vullingsgraad Looproutes Wat kan je met de WarehouseMapper? Het doel van de Mapper is het de gebruiker makkelijk maken om een opstelling van een magazijn in te kunnen stellen. De Mapper maakt het mogelijk om een verdieping te kiezen en vervolgens stellingen doormiddel van sleepacties te kunnen verplaatsen, vergroten en draaien. Hierdoor wordt het 'mapping' proces sneller, makkelijker en inzichtelijker. Verder kan je ook met de Mapper de vakvolgorde instellen. Hier onder is als voorbeeld Edisonweg te zien in de WarehouseMapper. Hoe werkt de WarehouseMapper? Wat je het beste kan om te begrijpen hoe de Mapper werkt, is om de Mapper te openen en de 'Hoe werkt het?' knop boven in de navigatiebalk te drukken. Hiermee zal een 'tour' door de applicatie starten. Bij sommige punten moet je de opgelichte knop indrukken om verder te gaan met de tour, dit zal de tour zelf ook aangeven. Hier onder zie je de locatie van deze 'Hoe werkt het?' knop Belangrijke informatie om te weten Deze applicatie is nog in ontwikkeling. Een bug kan voorkomen. Verder is het belangrijk om te weten dat er geen Cross-client synchronization is ingebouwd, dit betekend dat aanpassingen in de Mapper die je hebt geopend niet direct zichtbaar zijn in een andere instantie van de Mapper, hierdoor is het niet verstandig om met meerdere instanties van de applicatie op de zelfde magazijn te werken! Zorg er dus voor dat als je werkt aan een mapping, jij de enige bent die werkt aan deze magazijn."
  },
  "Algemene-informatie/Voorraadbeheer/Wholesale/index.html": {
    "href": "Algemene-informatie/Voorraadbeheer/Wholesale/index.html",
    "title": "Wholesale",
    "keywords": "Wholesale De wholesale koppeling is een koppeling tussen 2 relaties binnen Monta. Hierdoor wordt het mogelijk voor een Retailer om de voorraad van de Wholesaler te verkopen. Zodra er een order binnenkomt zal de voorraad worden omgezet naar de retailer. Eenmaal per week krijgt de wholesaler een order in de Montaportal met wat de Retailer heeft verkocht. De productassortimenten van de twee klanten moeten ook aan elkaar gekoppeld worden. Er kan gekozen worden of een retailer alle voorraad van de wholesaler mag gebruiken, of alleen de voorraad die de wholesaler beschikbaar heeft gemaakt voor de retailer door een voorraadallocatie te maken. Zie Outbound - voorraadallocatie. Relaties koppelen Het maken van een wholesale koppeling is middels de volgende stappen te doen: De Wholesaler maakt in de Montaportal een uitnodiging De wholesaler stuurt de uitnodiging naar de retailer De retailer maakt op basis van de key de koppeling aan In de Montaportal onder settings is een pagina toegevoegd: De Wholesaler gaat naar “My retailers” om daar vervolgens een uitnodiging aan te maken: Na het maken van de uitnodiging wordt er een Invite Key aangemaakt, deze kan de Wholesaler vervolgens doorsturen naar de retailer. De retailer kan vervolgens in zijn/haar Montaportal de ontvangen Invite key invullen op de “My Wholesalers” pagina: Producten linken Dit kan gedaan worden door de retailer in de Montaportal met de knop \"Match wholesale\" op de supplier details pagina. Als de wholesaler een stock allocatie maakt voor de retailer worden de producten ook automatisch gelinkt. Als dit niet lukt wordt een melding gegeven bij de stock allocation en op de Montaportal homepage bij de retailer. Inactieve producten Een wholesale link tussen producten wordt inactief als één van de producten inactief gemaakt wordt. Er kan dan een nieuwe match gemaakt worden. Voorraad delen Van de gelinkte producten wordt de voorraad van de wholesaler zichtbaar bij de retailer. Hoeveel voorraad er zichtbaar wordt hangt af van de gekozen instelling bij het koppelen van de relaties. De voorraad beschikbaar van de wholesaler wordt ook doorgegeven als beschikbare voorraad naar de webshops via de voorraadkoppeling. Zie Koppelingen - Dataflows - Stock update. Voorraad gebruiken Voorraad wordt omgeboekt van de wholesaler naar de retailer als een order wordt geplaatst met producten die niet op voorraad zijn bij de retailer maar wel bij de wholesaler. Dit wordt alleen gedaan als de order uit backorder kan komen. Als de order niet uit backorder kan komen omdat een ander product niet op voorraad is, wordt er geen voorraad gereserveerd bij de wholesaler. Dit is bewust, omdat je niet wil dat de retailer voorraad in beslag neemt van de wholesaler terwijl dit nog niet eigendom is geworden van de retailer. Het wholesale systeem is namelijk bedoeld voor consignatie. Bij de retailer wordt een Inbound geregisteerd (per week), zodat terug te vinden is hoeveel er is overgeboekt per wholesaler. Bij de wholesaler wordt een order gemaakt (per week per retailer), zodat de wholesaler kan terugvinden hoeveel er is omgeboekt naar de retailer."
  },
  "Algemene-informatie/Voorraadbeheer/index.html": {
    "href": "Algemene-informatie/Voorraadbeheer/index.html",
    "title": "Voorraadbeheer",
    "keywords": "Voorraadbeheer Voorraadbeheer is de opslag van producten in het magazijn. Soorten voorraad De volgende termen worden gebruikt voor de verschillende soorten voorraad. Financiële voorraad / in magazijn Alle niet-quarantaine voorraad van een klant die in ons pand aanwezig is. Dit is dus 'Alle voorraad' inclusief de voorraad afgeboekt voor orders die nog niet zijn verzonden. Alle voorraad Administratieve voorraad op alle niet-quarantaine locaties. Administratieve voorraad Voorraad beschikbaar op een magazijnlocatie. Omdat voorraad voor orders al wordt afgeboekt als de order klaarstaat om te picken, komt deze voorraad niet overeen met het aantal daadwerkelijk op de locatie. Zie fysieke voorraad. Geblokkeerde voorraad Voorraad op geblokkeerde magazijnlocaties. Transit voorraad Voorraad tijdelijk niet beschikbaar omdat het wordt verplaatst in het magazijn. Ook voor voorraad die is geinbound maar nog niet op een magazijnlocatie is gekoppeld. Quarantaine voorraad Voorraad op quarantaine locaties. Zie quarantaine voorraad. Fysieke voorraad Het aantal daadwerkelijk op de locatie. De administratieve voorraad kan anders zijn omdat voorraad voor orders al wordt afgeboekt als de order klaarstaat om te picken. De fysieke voorraad wordt berekend door te kijken of een pickactie al is afgehandeld met de scanner. Papieren pickbonnen wordt niet gepickt met de scanner. Dus als een papieren pickbon geprint is, kan niet berekend wordt wat de exacte fysieke voorraad is zo lang de order niet verzonden is. Gereserveerde voorraad Voorraad gereserveerd dmv voorraadreserveringen. Voor backorders en etransit orders. Zie voorraadreserveringen. Beschikbare voorraad Voorraad beschikbaar voor orders. Alle voorraad minus geblokkeerde minus transit minus gereserveerde voorraad. Webshop voorraad Voorraad beschikbaar voor de webshop om te verkopen. Dit is de beschikbare voorraad. Daarbij kan de klant ervoor kiezen voorraad uit de inbound forecasts alvast te verkopen. Dit kan per inbound forecast ingeschakeld worden. Ook wordt hier de voorraad uit split products verwerkt: de voorraad van een hoofdproduct wordt gebaseerd op de onderliggende producten. Tenslotte kunnen nog instellingen van de specifieke voorraadkoppeling van toepassing zijn. Zie 1. Koppelingen dataflow. Magazijnlocaties De locaties in het magazijn worden gemaakt in de magazijnlocatie tool in Montaportal. Zie Magazijnlocatie tool. Op een locatie mag standaard één product of batch liggen. Meerdere producten of batches moet expliciet toegestaan worden, zie multiproductlocaties. Multiproductlocaties Het is mogelijk om meerdere producten of batches op een locatie te leggen. Dit moet ingeschakeld worden bij de klant van het product en bij de zone van de locatie. Ook kan per magazijn een maximaal aantal SKU's en items ingesteld worden. Meerdere producten mogen ook op één locatie liggen als ze via het wholesale-systeem aan elkaar gekoppeld zijn. Het zijn dan namelijk fysiek dezelfde producten. Highcare Dure producten kunnen in een aparte zone opgeslagen worden die beter beveiligd is. Door locaties in deze zone als highcare te markeren, worden orders van de producten op de locaties apart gehouden bij het picken via de scanner. Een product kan ook als high care gemarkeerd worden. Zo'n product mag dan alleen op een highcare of niet-handmatig bereikbare locatie gekoppeld worden. Als een highcare product wordt ge-inbound wordt een melding getoond dat het product in de high care ruimte gekoppeld moet worden. Looproute De locaties in een magazijn worden ingedeeld op een loopvolgorde. Dit bepaald in welke volgorde de orderpicker langs de verschillende locaties gestuurd wordt bij het picken met de scanner. Echeck locaties Voor voorraad die bij de echeck gelegd wordt tbv Echeck toevoegproducten. Verplaatsen Met de scanner kan voorraad in het magazijn verplaatst worden van de ene naar de andere locatie. Dit is niet mogelijk als er te picken orders op de locatie staan. Anders zou het kunnen gebeuren dat een orderpicker naar een locatie wordt gestuurd terwijl de voorraad net wordt versjouwd naar een andere locatie. Voorraad verplaatsen van een locatie met open orders is wél mogelijk met een MOVE label. De orders worden dan vastgehouden bij dat MOVE label tot de verplaatsing gereed is. Dan kunnen de orders gepickt worden van de nieuwe locatie. Het MOVE label is bedoeld om de voorraad tijdelijk vast te houden. Als we dit niet zouden doen is de kans op foutmeldingen bij het verplaatsen hoger, omdat de voorraad inmiddels veranderd kan zijn. Zou de gebruiker deze foutmelding negeren en fysiek toch de verplaatsing doen, dan is er een voorraadverschil in het magazijn. Zie ook klant verhuizen. Replenishen Dit werkt via Niet handmatig bereikbaar, zie hieronder. Niet handmatig bereikbaar Locaties kunnen als niet handmatig bereikbaar worden gemarkeerd. Orders worden eerst gepickt van handmatig bereikbare locaties. Zie outbound - locatie keuze voor meer informatie over de locatie keuze. Orders van niet handmatige locatie komen als aparte pickstroom in de scanner of er moet eerst geplenisht worden. Zie Outbound - picken van niet handmatige locaties. Replenishen gaat altijd met hele pallets. Dus de hele locatie moet naar beneden geplaatst worden. Er kan ook een drempelwaarde ingesteld worden vanaf wanneer die het aantal laat zien. NOG TESTEN HOE DIT PRECIES ZIT. In het replenishen in de scanner zijn de B2B order gescheiden van de gewone orders. Dmv de knop B2B kan gekozen worden om te replenishen voor B2B orders. Ook wordt in de replenish opdrachten op de scanner onderscheid gemaakt in vandaag, morgen, later. Het kan gebeuren dat orders na het replenishen in backorder komen. Als een voorraadreservering is gemaakt nadat de orders aan de bulklocatie zijn toegewezen en voor het replenishen. Na het replenishen worden de orders opnieuw geverifieerd waardoor de voorraadreservering van toepassing wordt. Terwijl die dat eerst niet was omdat de orders al klaargezet waren om te picken. Proactief replenishen is ook mogelijk, zie Bijvullen. Cycle count Met de scanner kan een locatie geteld worden om te controleren of de administratieve voorraad klopt met de fysieke voorraad. Zie Cycle counten. Als een order gepickt wordt met een papieren pickbon is het niet mogelijk om een locatie te tellen. Het systeem kan dan namelijk niet berekenen wat de fysieke voorraad op de locatie is. Bij alle andere orders kan het systeem dit wel berekenen: orders die \"queued\" zijn worden nog niet gepickt, dus het systeem weet dat die voorraad er nog ligt. En bij orders die picking zijn met de scanner weet het systeem ook of het er nog ligt, omdat de locatie gescand wordt bij het picken. Alleen bij picken met een papieren bon kan het systeem het niet weten, dus dan is het niet mogelijk om de locatie te tellen. Cycle count wachtrij Het is mogelijk om een wachtrij te maken van locaties die geteld moet worden. De locaties die moeten worden geteld kunnen worden gevuld via Excel in Gomonta door een bestand te uploaden met alle locatie codes. (Voorraadbeheer > Cyclecount wachtrij) Letop: Als je telt met een wachtrij kan een zone maar door 1 persoon tegelijkertijd worden geteld. Locaties kunnen ook automatisch toegevoegd worden aan de wachtrij als een locatie administratief leeg zou moeten zijn maar er liggen nog producten op de locatie. Dit kan gedaan worden door middel van een controle na het picken van een product. Deze controle kan worden aangezet in GoMonta > OutBound > Magazijn outbound instellingen > Algemeen pickproces > “Tijdens het picken de vraag stellen: Is de locatie nu helemaal leeg?”. Door deze instelling aan te zetten krijg je de vraag ‘Is de locatie nu helemaal leeg” als een locatie leeg zou moeten zijn. Je kan hier “ja” of “nee” antwoorden. Als je op “ja” klikt, wordt de locatie in het systeem als leeg gemarkeerd, kies je “nee” dan wordt de locatie aan de wachtrij toegevoegd en wordt er een emailnotificatie verstuurd naar het emailadres dat is ingesteld voor magazijnnotificaties. Cycle counts verwerken Als bij het tellen een verschil wordt geconstateerd, moet dit in GoMonta verwerkt worden. Bijvoorbeeld door een voorraadmutatie te maken. Bij picken Het is ook mogelijk om bij het picken om een bevestiging te vragen of de locatie leeg is. Zie: Outbound - Bevestiging lege locatie. Voorraad optimalisatie De volgende mogelijkheden zijn beschikbaar om de voorraad in het magazijn te optimaliseren. Bijvullen handmatig bereikbare locaties: zie Bijvullen. Voorraad optimaliseren: dit is een optie in de scanner. Hierbij wordt voorraad op handmatig bereikbare locaties die 2 maanden niet gepickt is, verplaatst naar niet-handmatig bereikbare locaties. Outlet voorraad Een outlet product is een product van mindere kwaliteit, bijvoorbeeld met een lichte beschadiging. Het kan voor een lagere prijs nog verkocht worden (2de kans). Outlet producten hebben \"-o\" achter het SKU en de barcode van het oorspronkelijke product. Verder is het een normaal product, zodat het op webshops verkocht kan worden. Outlet producten kunnen gemaakt worden vanuit het retour verwerken. Quarantaine voorraad Quarantaine voorraad is voorraad waar iets mis mee is en die dus niet verkocht mag worden. Deze voorraad wordt op speciaal daarvoor aangemerkte locaties gelegd. Quarantaine voorraad kan ontstaan vanuit: Retouren: als wordt geconstateerd dat geretoureerde producten niet meer verkoopbaar zijn Inbound: als bij de inbound meteen al wordt geconstateerd dat producten beschadigd zijn. De klant kan quarantaine voorraad afnemen door op Montaportal een quarantaine order te maken. Voorraad quarantaine maken Omdat quarantaine een apart gedeelte in het magazijn is, is het niet zomaar mogelijk van verkoopbare voorraad quarantaine voorraad te maken. Hier is een fysieke verplaatsing voor nodig van een gewone locatie naar een quarantaine locatie. De verplaatsing kan vervolgens administratief in GoMonta gedaan worden. Dit kan niet in de scanner, want dan is het risico te groot dat dit per ongeluk gebeurd. Gevaarlijke goederen Een product kan gemarkeerd worden als gevaarlijk goed. In GoMonta kan een export gemaakt van alle locaties waar gevaarlijke goederen liggen. Daarin zijn ook totalen zichtbaar per zone, per un nummer, en per un nummer per zone. Als een gevaarlijk goed gekoppeld is aan een UN Nummer dat een beschrijving heeft met het woord 'Battery' of 'Batteries' wordt het gemarkeerd als 'Heeft batterij'. Groothandel systeem / wholesale Met het groothandelsysteem kunnen klanten elkaars voorraad gebruiken. Zie de pagina wholesale voor meer informatie. Batches/tht Zie Inbound - Food/THT. Klant verhuizen Een klant verhuizen kan door alle voorraad van een klant te verplaatsen naar een MOVE label en in het andere magazijn weer van het move label naar de magazijnlocatie. Klant uitruimen Het kan voorkomen dat de hele voorraad van een klant moet worden afgeboekt. Het handigst is dan om op de Montaportal een order te maken van de hele voorraad van de klant. Deze order kan gepickt met een papieren pickbon en op verzonden gezet worden in GoMonta. Bepaalde locaties leegboeken Dit kan met de tool Uitruimen in GoMonta. Er wordt dan een order gemaakt waarmee specifieke locaties worden leeggeboekt. PalletDC Een PalletDC concept is al uitgedacht en deels ontwikkeld. Het zou als volgt werken: PalletDC werkt alleen met hele pallets Vestiging maakt MOVE labels om voorraad naar PalletDC te verhuizen Klanten mogen ook direct naar PalletDC leveren Bij het inboundstation wordt de pallet gekoppeld aan een locatie. Hierdoor is in het pand geen wifi nodig om met een scanner op locatie te koppelen. Systeem maakt automatisch een lijst van voorraad die vanuit het PalletDC verplaatst moet worden naar fulfilment vestigingen. Het is ook mogelijk voor vestigingsmanagers om deze lijst aan te vullen. De opslag in het PalletDC wordt me meegefactureerd met de fulfilmentvestiging. Zodat de klant geen aparte factuur vanuit het PalletDC krijgt. Magazijn als verdieping? Een apart magazijn kan in het systeem ook als apart magazijn geregistreerd worden of als verdieping van een bestaand magazijn. Nadelen apart magazijn: Twee facturen Je kan orders van het ene magazijn niet echecken in het andere magazijn Replenishen met de scanner kan niet Nadelen verdieping: Benaming komt niet overeen met de werkelijkheid Een order waarvan de producten in twee verschillende verdiepingen liggen komt vrij als 'meerdere verdiepingen order'. Bij aparte magazijn blijft zo'n order in backorder staan. Minimale voorraad Op een product kan een minimum voorraad ingesteld worden. Dit kan zowel een algemeen aantal zijn, of een aantal per magazijn. Dit kan op de detail pagina van een product. Als de voorraad van dit product onder dit minimum, komt dit product te staan op de Minimale voorraad pagina in Montaportal. Deze pagina bestaat uit twee delen: een pagina voor de produten met batch en de ander voor de producten zonder batch. De laatste staat standaard open. Dit is uit ekaar gehaald omdat een product met een batch meerdere malen in de lijst voor kan komen als dat product meer dan 1 batch heeft."
  },
  "Algemene-informatie/index.html": {
    "href": "Algemene-informatie/index.html",
    "title": "Algemene informatie",
    "keywords": "Algemene informatie Deze pagina's beschrijven de algemene werking van het systeem en wat de mogelijkheden zijn. Kies een onderdeel om door te gaan, U kunt die in het overzicht links vinden."
  },
  "Troubleshooting/EcheckWall/Maintenance-Mode/index.html": {
    "href": "Troubleshooting/EcheckWall/Maintenance-Mode/index.html",
    "title": "Maintenance Mode",
    "keywords": "Maintenance Mode Om het opsporen van fouten in apparaten gemakkelijk te maken is er een Maintenance Mode gemaakt. Het doel van deze pagina is om op een eenvoudige manier de hardware aan te kunnen sturen. Ook is er te zien wat alle ip adressen van de verschillende controllers zijn. Als een opstart check gefaald is komt er een popup tevoorschijn, rechts bovenin staat een knop voor de maintenance mode. Deze is beveilig met een wachtwoord. Het wachtwoord is K0ffieTijd Een 2e manier om de Maintenance Mode pagina te bereiken is om bij het scan bulk krat scherm op de knop naast de log uit knop te drukken. (Deze knop is alleen voor IT personen te zien) Hieronder is te zien wat hoe het scherm eruit ziet. Alle led-secties kunnen 1 voor 1 aangelicht worden om te checken of dat deze nog individueel bereikbaar zijn. Hetzelfde kan gedaan worden met de atop lampen. Deze zullen ook het busadres laten zien op het schermpje Om te zien of alle vakken goed zijn ingesteld en aangestuurd kunnen worden kan deze optie gebruikt worden. Hierbij worden alle led-secties van dat vak en de atop knop 1 voor 1 aangezet. Om heel snel alles aan te zetten kan deze knop gebruikt worden. Dit zet alle ledstrips en alle atop knoppen aan."
  },
  "Troubleshooting/EcheckWall/Startup-cyclus/index.html": {
    "href": "Troubleshooting/EcheckWall/Startup-cyclus/index.html",
    "title": "Startup cyclus",
    "keywords": "Startup cyclus Tijdens het opstarten van de EcheckWall worden er verschillende hardwarechecks uitgevoerd om ervoor te zorgen dat alle essentiële componenten correct functioneren. Het is een ingebouwd proces dat automatisch wordt uitgevoerd zodra het systeem wordt ingeschakeld. Hier volgt een overzicht van de hardwarechecks die tijdens het opstartproces worden uitgevoerd: - Netwerk Bij deze check wordt er gekeken of de pc is verbonden met het netwerk en of deze de monta systemen kan bereiken. Deze check wordt ook al eerder uitgevoerd. Zie kopje OpstartProblemen - Ledstrips Om te checken of de ledcontroller bereikbaar is worden deze gepingd, als de controller reageert gaat het systeem door naar de volgende check. Wanneer de ledcontroller niet bereikbaar is komt er een popup met onderstaande: Omdat bij veel Echeckwalls de opstelling van het ledstrip systeem verschillent is ervoor gekozen om toch door te kunnen gaan met opstarten, maar dan zonder het de ledstrip systeem. Deze popup verdwijnt ook automatisch na 15 seconden. - Ledstrips (pickpoorts) Als er pickpoort met daarin ledstrips aanwezig zijn, (Molenaarsgraaf) worden deze op dezelfde manier gepingd als de andere ledstrips. Ook hier is er weer de keuze om door te gaan zonder de ledstrips. Als de pickpoorts niet aanwezig zijn dan wordt deze check in zijn geheel overgeslagen. - Atop knoppen Als laatste check wordt er gekeken of de Atop knoppen aangestuurd kunnen worden. Deze lichten op en het adres van de knop wordt op het schermpje afgebeeld. Omdat de atop knoppen essentieel zijn voor de werking van de Echeckwall kan deze check niet overgeslagen geworden."
  },
  "Troubleshooting/EcheckWall/Thuiskomer/index.html": {
    "href": "Troubleshooting/EcheckWall/Thuiskomer/index.html",
    "title": "Thuiskomer",
    "keywords": "Thuiskomer Thuiskomer Thuiskomer is de naam van een trolley met spare parts en eenvoudige gereedschappen. Deze zijn in principe voldoende om kleine storingen op te lossen. Mochten materialen uit deze trolley gebruikt worden, is het een good practice om de materialen zo snel mogelijk weer aan te vullen, zodat de trolley compleet blijft. Stuklijst thuiskomer Handleidingen thuiskomer dit wordt nog aangevuld Fotos thuiskomer"
  },
  "Troubleshooting/EcheckWall/index.html": {
    "href": "Troubleshooting/EcheckWall/index.html",
    "title": "EcheckWall",
    "keywords": "EcheckWall Troubleshooting Echeckwalls Alle Echeckwall stations hebben in teamviewer een naam waarin echeckwall voorkomt. De naamgeving is over het algemeen {Vestiging} - Echeckwall- {Nummer} - {(MontPC nummer)} voorbeeld: Lijst met alle Echeckwalls Elke Put-To-Light heeft een nummer dat er ook als typeplaatje opgeplakt is. Ongeveer zoals onderstaand voorbeeld: Melding over \"ugly\" krat Er zitten producten in die te groot zijn. Wat moet er dan eigenlijk gebeuren? [[Doelgroep IT: controleer of de EcheckWall service op de mp-proc02 wel draait. De echeck wall doet het helemaal niet meer Is de service op de mp-proc02 wel gestart? Barcode scanner batterijn leeg Een heel enkele keer komt het voor dat de draadloze barcode scanner van de echeckwall vergeten wordt in de oplader te hangen. Voor die gevallen is er bij de meeste echeckwalls een vaste bolscanner. Maar daarmee zijn niet de barcodes te scannen die op de echeckwall vast zitten, zie onderstaand plaatje. Wat er dan gedaan kan worden is met het toetsenbord de barcode intikken. Daarbij zijn de teksten soms net iets anders als dat op de sticker staat. (dit omdat dat beter aansluit bij barcodes die elders gebruikt worden) START --> START JOKER --> JOKER JA --> JAJA OK --> OK NEE --> NEENEE AANTAL BEVESTIGEN --> #_BEVESTIGEN LOG-OUT --> LOGOUT Opstart problemen Bij het opstarten kan er een melding voorkomen \"kan geen verbinding maken met Monta's webservice. Neem contact op met jouw contactpersoon bij Monta en geef door dat de REST API niet beschikbaar is\" of \"Geen internet connectie. Controleer of de WIFI of internetkabel verbonden is.\" Thuiskomer Er is een trolley beschikbaar met spare parts, deze noemen we thuiskomer. Meer info is te vinden op deze pagina."
  },
  "Troubleshooting/Montabots/index.html": {
    "href": "Troubleshooting/Montabots/index.html",
    "title": "Montabots",
    "keywords": "Montabots Keuzeboom troubleshooting Montabots Gebruik de keuzeboom om de correcte oplsossing te vinden voor het probleem graph TD; subgraph Keuzeboom troubleshooting Montabots product_info[Er is iets mis] --ja-->open_orders[Staan er nog orders open?] --ja-->staat_planner_rood[Staat de planner op rood of is hij uitgevallen?] --ja-->instellingen[staan alle instellingen goed?] --ja-->planner_uitgevallen[is de planner uitgevallen?] --nee-->order_block[Is er een order die het proces blocked?] --ja-->L_order[L order controleren] end subgraph Oplossingen open_orders_oplossing[Er is geen werk beschikbaar, ga naar Monta Bot Cockpit extra informatie]---staat_planner_rood_oplossing[Planner opnieuw opstarten, ga naar het uitvallen van de Montabotplanner of Montabotheffer service]--- instellingen_oplossing[Zet de instellingen terug naar standaard, ga naar oplossing 2 verkeerde instellingen in Monta Bot Cockpit]--- planner_uitgevallen_oplossing[Opnieuw opstarten, ga naar oplossing 1 services]--- order_block_oplossing[Controleer supervisor op binnenkomende opdrachten, ga naar het uitvallen van de Montabotplanner of Montabotheffer service] end open_orders-->open_orders_oplossing staat_planner_rood-->staat_planner_rood_oplossing instellingen-->instellingen_oplossing order_block-->order_block_oplossing De Montabots zijn Autonome Mobiele Robots (AMR's) van het merk Lowpad. De Montabots worden gebruikt voor het transporteren van opslagrekken. Een Montabot is in staat een rek op te tillen, ergens heen te rijden en weer neer te zetten. De Montabots hebben sensoren waardoor ze afremmen voor obstakels. Hierdoor is het mogelijk voor Monta medewerkers om in dezelfde ruimte te werken als de Montabots. Wel is het goed de veiligheid flyer te bekijken voordat je in het Montabot gebied gaat werken. Deze flyer is hier te vinden en hangt op bij de ingangen van de Montabot gebieden. Naast deze pagina met algemene informatie is er ook een handleiding en een pagina met algemene informatie Trouble shooting videos Onderstaand een aantal filmpjes over issues die soms optreden en hoe je die kunt oplossen Montabot aan en uitzetten ::: video ::: Montabot is lokalisatie kwijt ::: video ::: Montabot knippert blauw ::: video ::: Montabot knippert rood ::: video ::: Bij een rood knipperende montabot is er sinds half 2022 ook de mogelijkheid een reset knop te gebruiken die op de montabot zit. Deze knop kan gebruikt worden als het obstakel inmiddels weg is en de montabot weer zou kunnen gaan rijden. ::: video ::: Montabot is offline ::: video ::: Stappenplan troubleshooting Lowpads Als er geen meldingen worden gemaakt in Elastic of de logfile. Dan kan er iets mis zijn met een van de Montabot instellingen of services. Het uitvallen van de \"MontabotPlanner\" of \"MontabotHeffer\" service Dit kan voorkomen bij het verwerken van een order met een hoge aantal aan artikelen (een \"L\" order). De redenen hiervoor is omdat het systeem de berekening van de hoeveelheid artikelen niet rond kan krijgen met de beschikbare capaciteit. Dit is te controleren via een stappenplan. 1. Controleren van \"L\" orders In het outbound dashboard van GoMonta kun je \"Picking Info\" sorteren. Kijk op de 2de en 3de verdieping voor LXL orders. Selecteer een order ID in de lijst en controleer of het bestaat uit een groot aantal artikelen. Wanneer dit het geval is moet aan de shiftleader doorgegeven worden welke order het is, vervolgens moet deze uitgeprint worden en handmatig gepickt worden. 1.1 Oplossing 1 \"Services\": Stap 1 verbinden met \"mp-proc03.monatpacking.nl\" Als er geen meldingen meer binnenkomen in Elastic is het altijd verstandig om met \"mp-proc03.montapacking.nl\" te verbinden. Stap 2 openen van services Wanneer je ingelogd bent op \"mp-proc03.monatpacking.nl\" wil je de Windows-toets indrukken. Vervolgens wil je zoeken naar \"Services\" \"Services\" openen door dubbelklikken of entertoets te drukken. Stap 3 starten van \"MontabotPlanner\" & \"MontabotHeffer\" Controleer of de \"MontabotPlanner\" & \"MontabotHeffer\" services running zijn. Dat kun je doen door te zoeken naar de zoekterm Montabot binnen services. Wanneer de \"MontabotPlanner\" of \"MontabotHeffer\" weergegeven zijn controleer je de status. Als er bij de status geen running wil je het proces opnieuw starten. Dit doe je door het selecteren van de services en dan rechter muisknop te klikken. Vervolgens wil je op de optie \"Start\" klikken. Hiermee start je de services opnieuw op. 1.2 Oplossing 2 Verkeerde instellingen in \"Monta Bot Cockpit\" Er kunnen verkeerde instellingen in Monta Bot Cockpit ingesteld zijn. Om deze app te open kun je applicatie downloaden of via teamviewer connectie maken met de Lowpad outbound PC (MONPC 1197). Stap 1 openen van de instellingen Om dit te controleren moet in het startscherm de tandwieloptie gekozen worden. Stap 2 Controleren van de instellingen Nadat je op het tandwiel geklikt hebt worden de instellingen weergegeven. Controleer of de volgende instellingen kloppen: Echeckwalls: Montabot Blauw staat aan Montabot Geel staat aan Let op! De knoppen van Algemeen, inbound, outbound, pickeiland en replenish Geven de status aan waar ze naartoe veranderen als je erop klikt Dus als er staat uitschakelen betekent dat het ingeschakeld is Algemeen: ingeschakeld Inbound: ingeschakeld Outbound: ingeschakeld Pickeiland: ingeschakeld Replenish: Uitgeschakeld Hieronder een afbeelding van de correcte instellingen Controleer of de instellingen kloppen met de afbeelding . 1.3 geen vrije posities beschikbaar Het kan voorkomen dat de Montabots geen vrije posities beschikbaar heeft op een verdieping. Om dit te controleren moet er gekeken worden in de \"Monta Bot Cockpit\". Om deze app te open kun je applicatie downloaden of via teamviewer connectie maken met de Lowpad outbound PC (MONPC 1197). stap 1 open \"Monta Bot Cockpit\" stap 2 Klik op \"Dashboard\" stap 3 Bekijk vrije posities per verdieping Kijk per verdieping of er nog vrije posities zijn, zo niet meldt dit bij de shiftleader. ##pickeiland Extra informatie Elastic Elastic werkt als een meldingscentrum voor de Lowpads. Wanneer er geen meldingen binnenkomen is er iets mis met de de Montabots. Monta Bot Cockpit Monta Bot Cockpit is een applicatie van Monta waarmee je informatie en instellingen kan zien van de Montabots. De applicatie kan je downloaden via het bedrijfsportaal. Monta Bot Cockpit Monta Bot Cockpit extra informatie In \"Monta Bot Cokpit\" kun je meer informatie krijgen over het aantal rekken dat gehaald kan worden. Soms komt het voor dat deze op 0 staat. Dit kan betekenen dat er op het moment geen orders zijn. Wanneer er wel orders zijn en het getal is 0 kan het betekenen dat er iets mis met de Montabots in dat geval is het aangeraden om te kijken of een service is uitgevallen. Inloggen Lowpad supervisor via \"mp-proc02.montapacking.nl\" Met Lowpad supervisor krijg je meer informatie te zien over de huidige positie van de Montabots. Wanneer je ingelogd bent op \"mp-proc02.montapacking.nl\" kun je per verdieping inloggen met de volgende links: verdieping 1 https://lowpad01.monta.nl/account/login verdieping 2 https://lowpad02.monta.nl/account/login verdieping 3 https://lowpad03.monta.nl/account/login Transportrek op de 2e verdieping met niet gepickte orders Het kan voorkomen dat een transportrek op de 2e verdieping is geplaatst, met orders die niet gepickt zijn. Om dit op te lossen moet dit rek weer terug naar de 3e verdieping. Dan zal het tranportrek bij het pickeiland worden geplaatst om de orders te picken. Hiervoor moet handmatig een lift opdracht worden ingeschoten. Momenteel kan dit alleen in de database worden gedaan. Dit moet worden gedaan in tblLiftJobGroups."
  },
  "Troubleshooting/PUTL/Startup-cyclus/index.html": {
    "href": "Troubleshooting/PUTL/Startup-cyclus/index.html",
    "title": "Startup cyclus",
    "keywords": "Startup cyclus Tijdens het opstarten van de EcheckWall worden er verschillende hardwarechecks uitgevoerd om ervoor te zorgen dat alle essentiële componenten correct functioneren. Het is een ingebouwd proces dat automatisch wordt uitgevoerd zodra het systeem wordt ingeschakeld. Hier volgt een overzicht van de hardwarechecks die tijdens het opstartproces worden uitgevoerd: Netwerk Bij deze check wordt er gekeken of de pc is verbonden met het netwerk en of deze de monta systemen kan bereiken. Deze check wordt ook al eerder uitgevoerd. Zie kopje OpstartProblemen Atop knoppen Als laatste check wordt er gekeken of de Atop knoppen aangestuurd kunnen worden. Deze lichten op en het adres van de knop wordt op het schermpje afgebeeld. Omdat de atop knoppen essentieel zijn voor de werking van de Echeckwall kan deze check niet overgeslagen geworden."
  },
  "Troubleshooting/PUTL/index.html": {
    "href": "Troubleshooting/PUTL/index.html",
    "title": "PUTL",
    "keywords": "PUTL Troubleshooting Put-To-Lights Alle Put-To-Light stations hebben in teamviewer een naam waarin puttolight voorkomt. De naamgeving is over het algemeen {Vestiging} - Puttolight - {Nummer} - {(MontPC nummer)} voorbeeld: Lijst met alle PUTL's: Elke Put-To-Light heeft een nummer dat er ook als typeplaatje opgeplakt is. Ongeveer zoals onderstaand voorbeeld: Monta Gorinchem - Weide 30 21-Put-To-Light Weide 2 De bovenste stekker gaat naar het beeldscherm. De onderste gaat naar de computer. Zorg ervoor dat beide kabels goed aangesloten zijn in het stekkerblok en in de bijbehorende adapter. 22-Put-To-Light Weide 2 De bovenste stekker gaat naar de computer. De onderste gaat naar het beeldscherm. Zorg ervoor dat beide kabels goed aangesloten zijn in het stekkerblok en in de bijbehorende adapter. Let erop dat de computer aanstaat. De lamp moet groen verlicht zijn, anders moet deze ingedrukt worden. De schakelaar moet op de 'ON'-positie staan. Monta Gorinchem - Papland Put-To-Light Papland 1 en 2 (links en rechts) Let erop dat de zekering linksboven de kast goed is ingeschakeld (zoals op deze afbeelding) en dat alle kabels juist aangesloten zijn. De stroomkabel rechtsboven gaat naar het beeldscherm. Rechtsonder gaat naar de computer (MONPC0588). Zorg dat deze kabels goed zijn aangesloten aan beide kanten, en dat de apparaten aanstaan. De stroomkabel linksboven gaat naar het beeldscherm. Linksonder gaat naar de computer (MONPC0587). Zorg dat deze kabels goed zijn aangesloten aan beide kanten, en dat de apparaten aanstaan. Monta Breda 04, 05, 10, 11, 12-Put-To-Light. Let erop dat de groene lamp aanstaat. Let erop dat de zekering goed is ingeschakeld zoals op deze afbeelding. 15, 16, 17-Put-To-Light 3 t/m 5 Breda Outbound Expeditie Let erop dat de zekering goed is ingeschakeld zoals op deze afbeelding. Monta Oud Gastel 08-Put-To-Light Watermolen 3 Links 09-Put-To-Light Watermolen 3 Rechts Let erop dat de zekering goed is ingeschakeld zoals op deze afbeelding. Linksonder gaat naar de computer (MONPC0749), rechtsonder gaat naar het beeldscherm. Let erop dat de blauwe knop is ingedrukt zoals op deze afbeelding. Problemen met het scannen van de barcodes Het kan voorkomen dat de scanners op een PUTL niet alle barcodes begrijpen. Waarschijnlijk is de scanner dan nog niet volledig geconfigureerd en moeten er nog specifieke typen barcodes worden toegevoegd. Dit kan gedaan worden door de onderstaande handleidingen te volgen: Thuiskomer Thuiskomer Er is een trolley beschikbaar met spare parts, deze noemen we thuiskomer. Meer info is te vinden op deze pagina."
  },
  "Troubleshooting/ProGlove/index.html": {
    "href": "Troubleshooting/ProGlove/index.html",
    "title": "ProGlove",
    "keywords": "ProGlove ProGlove componenten Indicatie lampen op de ProGlove gateway LED 1 USB Controleer of deze led indicator groen brandt. Als dit niet het geval is plug de USB eruit en daarna opnieuw in. LED 2 Scanner Constant rood Als deze indicator brandt dan mogen er geen extra scanners verbonden worden. Zet alle gebruikte scanners in de oplader en verbind dan opnieuw. Flikkert rood 3 keer Houdt de knop van de scanner 15 seconden lang ingedrukt, vervolgens loslaten en daarna weer 2 seconden ingedrukt houden. Nu start reboot proces. De lampen op scanner gaan aan. Kijk of de scanner nu wel verbind, zo niet start de gateway opnieuw op. Als dit niet werkt neem dan contact op met de R&D afdeling Flikkert blauw Scan een barcode met de scanner, kijk of LED 2 (scanner) blauw wordt. Hierna moet de LED 1 (USB) blauw worden. Wanneer dit niet het geval is neem contact op met de R&D afdeling LED 3 Cloud Geel Als LED 3 (Cloud) geel brandt geeft dit aan dat het mogelijk is om de gateway op afstand te beheren."
  },
  "Troubleshooting/Shippers/index.html": {
    "href": "Troubleshooting/Shippers/index.html",
    "title": "Shippers",
    "keywords": "Shippers Amazon Asendia BPost Budbee BundleShipper Cancelled ColisPrive COT Courier CustomerService Cycloon DeutschePost DHLDE DHLEuroplus DHLForYou DHLPallet DHLParcelConnect DPDNL DPDPL Dynalogic FedEx GLS INT Izipack Landmark Oegema Packs ParcelNL PLX PostNL PostNLBuspost PostNLPakjesBuitenland RedjePakketje Reviva RoyalMail Seabourne SelektVracht Swift TBQ Trunkrs UPS"
  },
  "Troubleshooting/index.html": {
    "href": "Troubleshooting/index.html",
    "title": "Troubleshooting",
    "keywords": "Troubleshooting Deze pagina beschrijft problemen die je kan tegenkomen. Koppelingen Er staan orders in backorder terwijl ik een voorraadkoppeling heb Dit kan de volgorde oorzaken hebben: Er zijn meerdere webshops met een voorraadkoppeling en het laatste item is ongeveer tegelijkertijd in meerdere webshops verkocht. Als een product in één webshop verkocht is, duurt het namelijk ongeveer een kwartier voordat de voorraad in de andere webshops ook bijgewerkt is. Een oplossing kan zijn om de laatste stuks maar in één webshop aan te bieden. Dit kan door het maken van een stock allocatie. Zie Algemene informatie - Outbound - Voorraad allocatie. Er is voorraad opgeboekt in de webshop door een ander proces dan de voorraadkoppeling van Monta. Veelvoorkomend is dat als een order in het webshopsysteem geannuleeerd wordt, het webshopsysteem de voorraad van de order opboekt. Picken De juiste orders worden niet als eerste gepickt! Het is belangrijk dat orderpickers de juiste verdieping en pickstroom kiezen. Zorg ervoor dat de juiste pickstijl gekozen is in GoMonta Bij bulkpicken worden orders van verschillende afhaaltijden toegewezen. Dit kan ervoor zorgen dat die ene order net voor de afhaaltijd in een pickronde met veel orders terechtkomt. Het picken van verschillende afhaaltijden bij bulkpicken is uit te schakelen in GoMonta, evt een x aantal minuten voor de afhaaltijd. Voor meer info zie: Algemene informatie - Outbound - Picken - volgorde van orders picken. Er staan geen orders op de scanner Controleer of de instelling \"alleen overdue picken\" niet is ingeschakeld. Voorraad Er staan nog te koppelen TT01 labels die niet gekoppeld of verwijderd kunnen worden Het kan soms gebeuren dat er meerdere koppellabels zijn van hetzelfde product, en één van de koppellabels dubbel gekoppeld wordt. Het saldo op de TT01 locatie is dan lager geworden dan het aantal op openstaande TT01 labels, waardoor de laatste labels niet gekoppeld of verwijderd kunnen worden omdat er geen voorraad is. Met de volgende query kan gevonden worden welke labels dubbel gekoppeld zijn: select tblVoorraad.VoorraadID, tblVoorraad.Hoeveelheid, tblVoorraad.Aanmaakdatum, tblVoorraad.Inslag, tblVoorraad.Referentie, sum(tblvoorraadtransitokoppeloplocatie.aantal) as gekoppeld from tblVoorraad left join tblVoorraadTransitoKoppelOpLocatie on tblVoorraad.VoorraadID = tblVoorraadTransitoKoppelOpLocatie.InboundVoorraadID where Materiaal = ? and Locatie = ? and TypeBoeking = 1 group by tblVoorraad.VoorraadID, tblVoorraad.Hoeveelheid, tblVoorraad.Aanmaakdatum, tblVoorraad.Inslag, tblVoorraad.Referentie having sum(tblvoorraadtransitokoppeloplocatie.aantal) > tblVoorraad.Hoeveelheid In tblVoorraadTransitoOpLocatie kan dan één van de records omgehangen worden naar het TT01 label wat niet gekoppeld en verwijderd kan worden. Door het InboundVoorraadID aan te passen. Echeck wall Info over Echeckwall troubleshooting is hier te vinden Put-To-Light Info over Put-To-Light troubleshooting is hier te vinden Montabots Montabots Verschillende issues die kunnen optreden zijn uitgewerkt qua oplossingen in filmpjes Montabots aan en uitzetten Montabot is lokalisatie kwijt Montabot knippert blauw Montabot knippert rood Montabot is offline Internetverbindingen en wifi Zie \"Emergency Monta\" document in Teams: Serviceteam - IT algemeen - Algemeen. Hierin staat informatie over de verbindingen en telefoonummers van (wifi)leveranciers."
  },
  "Updates/Development-roadmap/index.html": {
    "href": "Updates/Development-roadmap/index.html",
    "title": "Development roadmap",
    "keywords": "Development roadmap Hier laten we zien welke grotere projecten we aan werken voor fulfilment klanten en magazijnen. Interne projecten (security, performance, stabiliteit) staan niet in deze lijst. In ontwikkeling en gepland ID Categorie Omschrijving Planning 8 Montaportal Verbeterd inkoopsysteem 2023 Q3 15 Montaportal Dashboard retouren 2023 Q3 10 Magazijn Grote order picken met meerdere pickers 2023 Q3 Magazijn PalletDC 2023 Q3 Verzenders DHL Buspakje tot 500 gram 2023 Q3 Verzenders Colis privé 2023 Q3 Verzenders TransMission 2023 Q3 8301 Magazijn Omdoos barcodes 2023 Q4 Koppelingen Koppeling met Exact Globe (ERP systeem) 2023 Q4 Koppelingen Koppeling met Lightspeed Omnichannel 2023 Q4 Koppelingen Koppeling met Zalando 2023 Q4 Checkout Checkout instellingen scherm in Montaportal gebruikersvriendelijker maken 2024 Q1 Verzenders Bpost 2024 Koppelingen Koppeling met Optiply (inkoopsysteem) 2024 54 Magazijn Max aantal bij replenishen (bijvullen) ntb Koppelingen Koppeling met Channable ntb Koppelingen Koppeling met VirtualStock ntb 17 Koppelingen Alle instellingen van koppelingen zichtbaar en aanpasbaar in Montaportal ntb 43 Magazijn Prepack orders op locatie boeken ntb Koppelingen Koppeling met Kaufland ntb 1775 Montaportal Nieuw design ntb 39 Magazijn Assemblage/montage ntb Montaportal Meer dashboards ntb 42 Montaportal Custom reports / meer data inzichtelijk ntb 50 Magazijn Verplaatsen/replenishen zonder MOVE labels ntb 60 Magazijn Bij het inplannen van een order rekening houden met de tijd die nodig is voor picken ntb 55 Magazijn Minimaal handmatig bereikbare voorraad automatisch bepalen ntb 57 Magazijn WarehouseCommander doorontwikkelen / zelflerend maken ntb 56 Magazijn QR codes: dit wordt de nieuwe standaard ipv barcodes ntb 53 Magazijn Orders picken in verzenddoos ntb Magazijn, Montaportal Montaportal en GoMonta samenvoegen ntb Voltooid ID Categorie Omschrijving Datum voltooid Documentatie RMA Ruilen 17 augustus 2023 Link naar documentatie 51 Montaportal Print & ship: verzendlabels printen op Montaportal verbeteren 17 augustus 2023 Link naar documentatie"
  },
  "Updates/R&D-Updates/index.html": {
    "href": "Updates/R&D-Updates/index.html",
    "title": "R&D Updates",
    "keywords": "R&D Updates Welkom op deze pagina. Op deze pagina zijn alle R&D updates terug te vinden die sinds begin 2022 gemaild zijn. Autostore (Update 21) 31-08-2023 MontaCast (Update 20) 11-08-2023 Echeck only & echeck to light (Update 19) 20-07-2023 Vaste locaties op een multi-order kar (Update 18) 14-07-2023 WhatsApp in de personeelsplanning (Update 17) 29-06-2023 ZippCube (Update 16) 15-06-2023 ABC Tool (Update 15) 21-02-2023 Monta Parts (Update 14) 10-02-2023 Automatisch uitlezen weegschalen (Update 13) 14-10-2022 Tapedispenser (Update 12) 22-09-2022 Eerste orders Montapacker (Update 11) 14-07-2022 Transportmiddel blauwe kratjes (Update 10) 22-06-2022 MontaPacker (Update 9) 20-05-2022 Pick-To-Light Heatmap (Update 8) 21-04-2022 Magazijnborden (Update 7) 01-04-2022 Pick-by-vision (Update 6) 17-03-2022 Inpakmachine (Update 5) 04-03-2022 Kassa Scanner (Update 4) 18-02-2022 Magazijn Heatmaps (Update 3) 11-02-2022 Echeck-Organizer (Update 2) 18-01-2022 Pick-Volgorde Manueel Instellen (Update 1) 05-01-2022"
  },
  "Updates/index.html": {
    "href": "Updates/index.html",
    "title": "Updates",
    "keywords": "Updates Deze pagina beschrijft updates aan het systeem."
  },
  "_site/styles/node_modules/@types/flexsearch/README.html": {
    "href": "_site/styles/node_modules/@types/flexsearch/README.html",
    "title": "Installation",
    "keywords": "Installation npm install --save @types/flexsearch Summary This package contains type definitions for flexsearch (https://github.com/nextapps-de/flexsearch/). Details Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/flexsearch. Additional Details Last updated: Thu, 14 Sep 2023 15:26:41 GMT Dependencies: none Global values: none Credits These definitions were written by LOSSES Don."
  },
  "_site/styles/node_modules/flexsearch/CHANGELOG.html": {
    "href": "_site/styles/node_modules/flexsearch/CHANGELOG.html",
    "title": "Changelog",
    "keywords": "Changelog v0.7.0 Bidirectional Context (the order of words can now vary, does not increase memory when using bidirectional context) New memory-friendly strategy for indexes (switchable, saves up to 50% of memory for each index, slightly decrease performance) Better scoring calculation (one of the biggest concerns of the old implementation was that the order of arrays processed in the intersection has affected the order of relevance in the final result) Fix resolution (the resolution in the old implementation was not fully stretched through the whole range in some cases) Skip words (optionally, automatically skip words from the context chain which are too short) Hugely improves performance of long queries (up to 450x faster!) and also memory allocation (up to 250x less memory) New fast-update strategy (optionally, hugely improves performance of all updates and removals of indexed contents up to 2850x) Improved auto-balanced cache (keep and expire cache by popularity) Append contents to already existing entries (already indexed documents or contents) New method \"contain\" to check if an ID was already indexed Access documents directly from internal store (read/write) Suggestions are hugely improved, falls back from context search all the way down to single term match Document descriptor has now array support (optionally adds array entries via the new append under the hood to provide a unique relevance context for each entry) Document storage handler gets improved Results from document index now grouped by field (this is one of the few bigger breaking changes which needs migrations of your old code) Boolean search has a new concept (use in combination of the new result structure) Node.js Worker Threads Improved default latin encoders New parallelization model and workload distribution Improved Export/Import Tag Search Offset pagination Enhanced Field Search Improved sorting by relevance (score) Added Context Scoring (context index has its own resolution) Enhanced charset normalization Improved bundler (support for inline WebWorker) These features have been removed: Where-Clause Index Information index.info() Paging Cursor (was replaced by offset) Migration Quick Overview The \"async\" options was removed, instead you can call each method in its async version, e.g. index.addAsync or index.searchAsync. Define document fields as object keys is not longer supported due to the unification of all option payloads. A full configuration example for a context-based index: var index = new Index({ tokenize: \"strict\", resolution: 9, minlength: 3, optimize: true, fastupdate: true, cache: 100, context: { depth: 1, resolution: 3, bidirectional: true } }); The resolution could be set also for the contextual index. A full configuration example for a document based index: const index = new Document({ tokenize: \"forward\", optimize: true, resolution: 9, cache: 100, worker: true, document: { id: \"id\", tag: \"tag\", store: [ \"title\", \"content\" ], index: [{ field: \"title\", tokenize: \"forward\", optimize: true, resolution: 9 },{ field: \"content\", tokenize: \"strict\", optimize: true, resolution: 9, minlength: 3, context: { depth: 1, resolution: 3 } }] } }); A full configuration example for a document search: index.search({ enrich: true, bool: \"and\", tag: [\"cat\", \"dog\"], index: [{ field: \"title\", query: \"some query\", limit: 100, suggest: true },{ field: \"content\", query: \"same or other query\", limit: 100, suggest: true }] }); Where Clause Replacement Old Syntax: const result = index.where({ cat: \"comedy\", year: \"2018\" }); Equivalent Syntax (0.7.x): const data = Object.values(index.store); The line above retrieves data from the document store (just useful when not already available in your runtime). const result = data.filter(function(item){ return item.cat === \"comedy\" && item.year === \"2018\"; }); Also considering using the Tag-Search feature, which partially replaces the Where-Clause with a huge performance boost. v0.6.0 Pagination v0.5.3 Logical Operator v0.5.2 Intersect Partial Results v0.5.1 Customizable Scoring Resolution v0.5.0 Where / Find Documents Document Tags Custom Sort v0.4.0 Index Documents (Field-Search) v0.3.6 Right-To-Left Support CJK Word Splitting Support v0.3.5 Promise Support v0.3.4 Export / Import Indexes (Serialize) v0.3.0 Profiler Support"
  },
  "_site/styles/node_modules/flexsearch/README.html": {
    "href": "_site/styles/node_modules/flexsearch/README.html",
    "title": "",
    "keywords": "Web's fastest and most memory-flexible full-text search library with zero dependencies. Basic Start • API Reference • Document Indexes • Using Worker • Changelog FlexSearch v0.7.0 The new version is finally available. FlexSearch v0.7.0 is a modern re-implementation and was newly developed from the ground up. The result is an improvement in every single aspect and covers tons of enhancements and improvements which was collected over the last 3 years. This new version has a good compatibility with the old generation, but it might require some migrations steps in your code. Read the documentation of new features and changes: https://github.com/nextapps-de/flexsearch/blob/master/doc/0.7.0.md Read the documentation of new language encoding features: https://github.com/nextapps-de/flexsearch/blob/master/doc/0.7.0-lang.md When it comes to raw search speed FlexSearch outperforms every single searching library out there and also provides flexible search capabilities like multi-field search, phonetic transformations or partial matching. Depending on the used options it also provides the most memory-efficient index. FlexSearch introduce a new scoring algorithm called \"contextual index\" based on a pre-scored lexical dictionary architecture which actually performs queries up to 1,000,000 times faster compared to other libraries. FlexSearch also provides you a non-blocking asynchronous processing model as well as web workers to perform any updates or queries on the index in parallel through dedicated balanced threads. Supported Platforms: Browser Node.js Library Comparison \"Gulliver's Travels\": Performance Benchmark Scoring Benchmark Memory Consumption Plugins (extern projects): https://github.com/angeloashmore/react-use-flexsearch https://www.gatsbyjs.org/packages/gatsby-plugin-flexsearch/ Get Latest Stable Build (Recommended) Build File CDN flexsearch.bundle.js Download https://rawcdn.githack.com/nextapps-de/flexsearch/0.7.31/dist/flexsearch.bundle.js flexsearch.light.js Download https://rawcdn.githack.com/nextapps-de/flexsearch/0.7.31/dist/flexsearch.light.js flexsearch.compact.js Download https://rawcdn.githack.com/nextapps-de/flexsearch/0.7.31/dist/flexsearch.compact.js flexsearch.es5.js * Download https://rawcdn.githack.com/nextapps-de/flexsearch/0.7.31/dist/flexsearch.es5.js ES6 Modules Download The /dist/module/ folder of this Github repository * The bundle \"flexsearch.es5.js\" includes polyfills for EcmaScript 5 Support. Get Latest (NPM) npm install flexsearch Get Latest Nightly (Do not use for production!) Just exchange the version number from the URLs above with \"master\", e.g.: \"/flexsearch/0.7.31/dist/\" into \"/flexsearch/master/dist\". Compare Web-Bundles The Node.js package includes all features from flexsearch.bundle.js. Feature flexsearch.bundle.js flexsearch.compact.js flexsearch.light.js Presets ✓ ✓ - Async Search ✓ ✓ - Workers (Web + Node.js) ✓ - - Contextual Indexes ✓ ✓ ✓ Index Documents (Field-Search) ✓ ✓ - Document Store ✓ ✓ - Partial Matching ✓ ✓ ✓ Relevance Scoring ✓ ✓ ✓ Auto-Balanced Cache by Popularity ✓ - - Tags ✓ - - Suggestions ✓ ✓ - Phonetic Matching ✓ ✓ - Customizable Charset/Language (Matcher, Encoder, Tokenizer, Stemmer, Filter, Split, RTL) ✓ ✓ ✓ Export / Import Indexes ✓ - - File Size (gzip) 6.8 kb 5.3 kb 2.9 kb Performance Benchmark (Ranking) Run Comparison: Performance Benchmark \"Gulliver's Travels\" Operation per seconds, higher is better, except the test \"Memory\" on which lower is better. Rank Library Memory Query (Single Term) Query (Multi Term) Query (Long) Query (Dupes) Query (Not Found) 1 FlexSearch 17 7084129 1586856 511585 2017142 3202006 2 JSii 27 6564 158149 61290 95098 534109 3 Wade 424 20471 78780 16693 225824 213754 4 JS Search 193 8221 64034 10377 95830 167605 5 Elasticlunr.js 646 5412 7573 2865 23786 13982 6 BulkSearch 1021 3069 3141 3333 3265 21825569 7 MiniSearch 24348 4406 10945 72 39989 17624 8 bm25 15719 1429 789 366 884 1823 9 Lunr.js 2219 255 271 272 266 267 10 FuzzySearch 157373 53 38 15 32 43 11 Fuse 7641904 6 2 1 2 3 Contextual Search Note: This feature is disabled by default because of its extended memory usage. Read here get more information about and how to enable. FlexSearch introduce a new scoring mechanism called Contextual Search which was invented by Thomas Wilkerling, the author of this library. A Contextual Search incredibly boost up queries to a complete new level but also requires some additional memory (depending on depth). The basic idea of this concept is to limit relevance by its context instead of calculating relevance through the whole distance of its corresponding document. This way contextual search also improves the results of relevance-based queries on a large amount of text data. Load Library There are 3 types of indexes: Index is a flat high performance index which stores id-content-pairs. Worker / WorkerIndex is also a flat index which stores id-content-pairs but runs in background as a dedicated worker thread. Document is multi-field index which can store complex JSON documents (could also exist of worker indexes). The most of you probably need just one of them according to your scenario. ES6 Modules (Browser): import Index from \"./index.js\"; import Document from \"./document.js\"; import WorkerIndex from \"./worker/index.js\"; const index = new Index(options); const document = new Document(options); const worker = new WorkerIndex(options); Bundle (Browser) <html> <head> <script src=\"js/flexsearch.bundle.js\"></script> </head> ... Or via CDN: <script src=\"https://cdn.jsdelivr.net/gh/nextapps-de/flexsearch@0.7.31/dist/flexsearch.bundle.js\"></script> AMD: var FlexSearch = require(\"./flexsearch.js\"); Load one of the builds from the folder dist within your html as a script and use as follows: var index = new FlexSearch.Index(options); var document = new FlexSearch.Document(options); var worker = new FlexSearch.Worker(options); Node.js npm install flexsearch In your code include as follows: const { Index, Document, Worker } = require(\"flexsearch\"); const index = new Index(options); const document = new Document(options); const worker = new Worker(options); Basic Usage and Variants index.add(id, text); index.search(text); index.search(text, limit); index.search(text, options); index.search(text, limit, options); index.search(options); document.add(doc); document.add(id, doc); document.search(text); document.search(text, limit); document.search(text, options); document.search(text, limit, options); document.search(options); worker.add(id, text); worker.search(text); worker.search(text, limit); worker.search(text, options); worker.search(text, limit, options); worker.search(text, limit, options, callback); worker.search(options); The worker inherits from type Index and does not inherit from type Document. Therefore, a WorkerIndex basically works like a standard FlexSearch Index. Worker-Support in documents needs to be enabled by just passing the appropriate option during creation { worker: true }. Every method called on a Worker index is treated as async. You will get back a Promise or you can provide a callback function as the last parameter alternatively. API Overview Global methods: FlexSearch.registerCharset(name, charset) FlexSearch.registerLanguage(name, language) Index methods: Index.add(id, string) * Index.append(id, string) * Index.update(id, string) * Index.remove(id) * Index.search(string, <limit>, <options>) * Index.search(options) * async Index.export(handler) async Index.import(key, data) WorkerIndex methods: async Index.add(id, string) async Index.append(id, string) async Index.update(id, string) async Index.remove(id) async Index.search(string, <limit>, <options>) async Index.search(options) async Index.export(handler) (WIP) async Index.import(key, data) (WIP) Document methods: Document.add(<id>, document) * Document.append(<id>, document) * Document.update(<id>, document) * Document.remove(id || document) * Document.search(string, <limit>, <options>) * Document.search(options) * async Document.export(handler) async Document.import(key, data) * For each of those methods there exist an asynchronous equivalent: Async Version: async .addAsync( ... , <callback>) async .appendAsync( ... , <callback>) async .updateAsync( ... , <callback>) async .removeAsync( ... , <callback>) async .searchAsync( ... , <callback>) Async methods will return a Promise, alternatively you can pass a callback function as the last parameter. Methods export and also import are always async as well as every method you call on a Worker-based Index. Options FlexSearch is highly customizable. Make use of the right options can really improve your results as well as memory economy and query time. Index Options Option Values Description Default preset \"memory\" \"performance\" \"match\" \"score\" \"default\" The configuration profile as a shortcut or as a base for your custom settings. \"default\" tokenize \"strict\" \"forward\" \"reverse\" \"full\" The indexing mode (tokenizer). Choose one of the built-ins or pass a custom tokenizer function. \"strict\" cache Boolean Number Enable/Disable and/or set capacity of cached entries. When passing a number as a limit the cache automatically balance stored entries related to their popularity. Note: When just using \"true\" the cache has no limits and growth unbounded. false resolution Number Sets the scoring resolution (default: 9). 9 context Boolean Context Options Enable/Disable contextual indexing. When passing \"true\" as value it will take the default values for the context. false optimize Boolean When enabled it uses a memory-optimized stack flow for the index. true boost function(arr, str, int) => float A custom boost function used when indexing contents to the index. The function has this signature: Function(words[], term, index) => Float. It has 3 parameters where you get an array of all words, the current term and the current index where the term is placed in the word array. You can apply your own calculation e.g. the occurrences of a term and return this factor (<1 means relevance is lowered, >1 means relevance is increased). Note: this feature is currently limited by using the tokenizer \"strict\" only. null Language-specific Options and Encoding: charset Charset Payload String (key) Provide a custom charset payload or pass one of the keys of built-in charsets. \"latin\" language Language Payload String (key) Provide a custom language payload or pass in language shorthand flag (ISO-3166) of built-in languages. null encode false \"default\" \"simple\" \"balance\" \"advanced\" \"extra\" function(str) => [words] The encoding type. Choose one of the built-ins or pass a custom encoding function. \"default\" stemmer false String Function false filter false String Function false matcher false String Function false Additional Options for Document Indexes: worker Boolean Enable/Disable and set count of running worker threads. false document Document Descriptor Includes definitions for the document index and storage. Context Options Option Values Description Default resolution Number Sets the scoring resolution for the context (default: 1). 1 depth false Number Enable/Disable contextual indexing and also sets contextual distance of relevance. Depth is the maximum number of words/tokens away a term to be considered as relevant. 1 bidirectional Boolean Sets the scoring resolution (default: 9). true Document Options Option Values Description Default id String \"id\"\" tag false String \"tag\" index String Array<String> Array<Object> store Boolean String Array<String> false Charset Options Option Values Description Default split false RegExp String The rule to split words when using non-custom tokenizer (built-ins e.g. \"forward\"). Use a string/char or use a regular expression (default: /\\W+/). /[\\W_]+/ rtl Boolean Enables Right-To-Left encoding. false encode function(str) => [words] The custom encoding function. /lang/latin/default.js Language Options Option Values Description stemmer false String Function Disable or pass in language shorthand flag (ISO-3166) or a custom object. filter false String Function Disable or pass in language shorthand flag (ISO-3166) or a custom array. matcher false String Function Disable or pass in language shorthand flag (ISO-3166) or a custom array. Search Options Option Values Description Default limit number Sets the limit of results. 100 offset number Apply offset (skip items). 0 suggest Boolean Enables suggestions in results. false Document Search Options Additionally, to the Index search options above. Option Values Description Default index String Array<String> Array<Object> Sets the document fields which should be searched. When no field is set, all fields will be searched. Custom options per field are also supported. tag String Array<String> Sets the document fields which should be searched. When no field is set, all fields will be searched. Custom options per field are also supported. false enrich Boolean Enrich IDs from the results with the corresponding documents. false bool \"and\" \"or\" Sets the used logical operator when searching through multiple fields or tags. \"or\" Tokenizer (Prefix Search) Tokenizer affects the required memory also as query time and flexibility of partial matches. Try to choose the most upper of these tokenizer which fits your needs: Option Description Example Memory Factor (n = length of word) \"strict\" index whole words foobar * 1 \"forward\" incrementally index words in forward direction foobar foobar * n \"reverse\" incrementally index words in both directions foobar foobar * 2n - 1 \"full\" index every possible combination foobar foobar * n * (n - 1) Encoders Encoding affects the required memory also as query time and phonetic matches. Try to choose the most upper of these encoders which fits your needs, or pass in a custom encoder: Option Description False-Positives Compression false Turn off encoding no 0% \"default\" Case in-sensitive encoding no 0% \"simple\" Case in-sensitive encoding Charset normalizations no ~ 3% \"balance\" Case in-sensitive encoding Charset normalizations Literal transformations no ~ 30% \"advanced\" Case in-sensitive encoding Charset normalizations Literal transformations Phonetic normalizations no ~ 40% \"extra\" Case in-sensitive encoding Charset normalizations Literal transformations Phonetic normalizations Soundex transformations yes ~ 65% function() Pass custom encoding via function(string):[words] Usage Create a new index var index = new Index(); Create a new index and choosing one of the presets: var index = new Index(\"performance\"); Create a new index with custom options: var index = new Index({ charset: \"latin:extra\", tokenize: \"reverse\", resolution: 9 }); Create a new index and extend a preset with custom options: var index = new FlexSearch({ preset: \"memory\", tokenize: \"forward\", resolution: 5 }); See all available custom options. Add text item to an index Every content which should be added to the index needs an ID. When your content has no ID, then you need to create one by passing an index or count or something else as an ID (a value from type number is highly recommended). Those IDs are unique references to a given content. This is important when you update or adding over content through existing IDs. When referencing is not a concern, you can simply use something simple like count++. Index.add(id, string) index.add(0, \"John Doe\"); Search items Index.search(string | options, <limit>, <options>) index.search(\"John\"); Limit the result: index.search(\"John\", 10); Check existence of already indexed IDs You can check if an ID was already indexed by: if(index.contain(1)){ console.log(\"ID is already in index\"); } Async You can call each method in its async version, e.g. index.addAsync or index.searchAsync. You can assign callbacks to each async function: index.addAsync(id, content, function(){ console.log(\"Task Done\"); }); index.searchAsync(query, function(result){ console.log(\"Results: \", result); }); Or do not pass a callback function and getting back a Promise instead: index.addAsync(id, content).then(function(){ console.log(\"Task Done\"); }); index.searchAsync(query).then(function(result){ console.log(\"Results: \", result); }); Or use async and await: async function add(){ await index.addAsync(id, content); console.log(\"Task Done\"); } async function search(){ const results = await index.searchAsync(query); console.log(\"Results: \", result); } Append Contents You can append contents to an existing index like: index.append(id, content); This will not overwrite the old indexed contents as it will do when perform index.update(id, content). Keep in mind that index.add(id, content) will also perform \"update\" under the hood when the id was already being indexed. Appended contents will have their own context and also their own full resolution. Therefore, the relevance isn't being stacked but gets its own context. Let us take this example: index.add(0, \"some index\"); index.append(0, \"some appended content\"); index.add(1, \"some text\"); index.append(1, \"index appended content\"); When you query index.search(\"index\") then you will get index id 1 as the first entry in the result, because the context starts from zero for the appended data (isn't stacked to the old context) and here \"index\" is the first term. If you didn't want this behavior than just use the standard index.add(id, content) and provide the full length of content. Update item from an index Index.update(id, string) index.update(0, \"Max Miller\"); Remove item from an index Index.remove(id) index.remove(0); Add custom tokenizer A tokenizer split words/terms into components or partials. Define a private custom tokenizer during creation/initialization: var index = new FlexSearch({ tokenize: function(str){ return str.split(/\\s-\\//g); } }); The tokenizer function gets a string as a parameter and has to return an array of strings representing a word or term. In some languages every char is a term and also not separated via whitespaces. Add language-specific stemmer and/or filter Stemmer: several linguistic mutations of the same word (e.g. \"run\" and \"running\") Filter: a blacklist of words to be filtered out from indexing at all (e.g. \"and\", \"to\" or \"be\") Assign a private custom stemmer or filter during creation/initialization: var index = new FlexSearch({ stemmer: { // object {key: replacement} \"ational\": \"ate\", \"tional\": \"tion\", \"enci\": \"ence\", \"ing\": \"\" }, filter: [ // array blacklist \"in\", \"into\", \"is\", \"isn't\", \"it\", \"it's\" ] }); Using a custom filter, e.g.: var index = new FlexSearch({ filter: function(value){ // just add values with length > 1 to the index return value.length > 1; } }); Or assign stemmer/filters globally to a language: Stemmer are passed as a object (key-value-pair), filter as an array. FlexSearch.registerLanguage(\"us\", { stemmer: { /* ... */ }, filter: [ /* ... */ ] }); Or use some pre-defined stemmer or filter of your preferred languages: <html> <head> <script src=\"js/flexsearch.bundle.js\"></script> <script src=\"js/lang/en.min.js\"></script> <script src=\"js/lang/de.min.js\"></script> </head> ... Now you can assign built-in stemmer during creation/initialization: var index_en = new FlexSearch.Index({ language: \"en\" }); var index_de = new FlexSearch.Index({ language: \"de\" }); In Node.js all built-in language packs files are available: const { Index } = require(\"flexsearch\"); var index_en = new Index({ language: \"en\" }); Right-To-Left Support Set the tokenizer at least to \"reverse\" or \"full\" when using RTL. Just set the field \"rtl\" to true and use a compatible tokenizer: var index = new Index({ encode: str => str.toLowerCase().split(/[^a-z]+/), tokenize: \"reverse\", rtl: true }); CJK Word Break (Chinese, Japanese, Korean) Set a custom tokenizer which fits your needs, e.g.: var index = FlexSearch.create({ encode: str => str.replace(/[\\x00-\\x7F]/g, \"\").split(\"\") }); You can also pass a custom encoder function to apply some linguistic transformations. index.add(0, \"一个单词\"); var results = index.search(\"单词\"); Index Documents (Field-Search) The Document Descriptor Assuming our document has a data structure like this: { \"id\": 0, \"content\": \"some text\" } Old syntax FlexSearch v0.6.3 (not supported anymore!): const index = new Document({ doc: { id: \"id\", field: [\"content\"] } }); The document descriptor has slightly changed, there is no field branch anymore, instead just apply one level higher, so key becomes a main member of options. For the new syntax the field \"doc\" was renamed to document and the field \"field\" was renamed to index: const index = new Document({ document: { id: \"id\", index: [\"content\"] } }); index.add({ id: 0, content: \"some text\" }); The field id describes where the ID or unique key lives inside your documents. The default key gets the value id by default when not passed, so you can shorten the example from above to: const index = new Document({ document: { index: [\"content\"] } }); The member index has a list of fields which you want to be indexed from your documents. When just selecting one field, then you can pass a string. When also using default key id then this shortens to just: const index = new Document({ document: \"content\" }); index.add({ id: 0, content: \"some text\" }); Assuming you have several fields, you can add multiple fields to the index: var docs = [{ id: 0, title: \"Title A\", content: \"Body A\" },{ id: 1, title: \"Title B\", content: \"Body B\" }]; const index = new Document({ id: \"id\", index: [\"title\", \"content\"] }); You can pass custom options for each field: const index = new Document({ id: \"id\", index: [{ field: \"title\", tokenize: \"forward\", optimize: true, resolution: 9 },{ field: \"content\", tokenize: \"strict\", optimize: true, resolution: 5, minlength: 3, context: { depth: 1, resolution: 3 } }] }); Field options gets inherited when also global options was passed, e.g.: const index = new Document({ tokenize: \"strict\", optimize: true, resolution: 9, document: { id: \"id\", index:[{ field: \"title\", tokenize: \"forward\" },{ field: \"content\", minlength: 3, context: { depth: 1, resolution: 3 } }] } }); Note: The context options from the field \"content\" also gets inherited by the corresponding field options, whereas this field options was inherited by the global option. Nested Data Fields (Complex Objects) Assume the document array looks more complex (has nested branches etc.), e.g.: { \"record\": { \"id\": 0, \"title\": \"some title\", \"content\": { \"header\": \"some text\", \"footer\": \"some text\" } } } Then use the colon separated notation root:child:child to define hierarchy within the document descriptor: const index = new Document({ document: { id: \"record:id\", index: [ \"record:title\", \"record:content:header\", \"record:content:footer\" ] } }); Just add fields you want to query against. Do not add fields to the index, you just need in the result (but did not query against). For this purpose you can store documents independently of its index (read below). When you want to query through a field you have to pass the exact key of the field you have defined in the doc as a field name (with colon syntax): index.search(query, { index: [ \"record:title\", \"record:content:header\", \"record:content:footer\" ] }); Same as: index.search(query, [ \"record:title\", \"record:content:header\", \"record:content:footer\" ]); Using field-specific options: index.search([{ field: \"record:title\", query: \"some query\", limit: 100, suggest: true },{ field: \"record:title\", query: \"some other query\", limit: 100, suggest: true }]); You can perform a search through the same field with different queries. When passing field-specific options you need to provide the full configuration for each field. They get not inherited like the document descriptor. Complex Documents You need to follow 2 rules for your documents: The document cannot start with an Array at the root index. This will introduce sequential data and isn't supported yet. See below for a workaround for such data. [ // <-- not allowed as document start! { \"id\": 0, \"title\": \"title\" } ] The id can't be nested inside an array (also none of the parent fields can't be an array). This will introduce sequential data and isn't supported yet. See below for a workaround for such data. { \"records\": [ // <-- not allowed when ID or tag lives inside! { \"id\": 0, \"title\": \"title\" } ] } Here an example for a supported complex document: { \"meta\": { \"tag\": \"cat\", \"id\": 0 }, \"contents\": [ { \"body\": { \"title\": \"some title\", \"footer\": \"some text\" }, \"keywords\": [\"some\", \"key\", \"words\"] }, { \"body\": { \"title\": \"some title\", \"footer\": \"some text\" }, \"keywords\": [\"some\", \"key\", \"words\"] } ] } The corresponding document descriptor (when all fields should be indexed) looks like: const index = new Document({ document: { id: \"meta:id\", tag: \"meta:tag\", index: [ \"contents[]:body:title\", \"contents[]:body:footer\", \"contents[]:keywords\" ] } }); Again, when searching you have to use the same colon-separated-string from your field definition. index.search(query, { index: \"contents[]:body:title\" }); Not Supported Documents (Sequential Data) This example breaks both rules from above: [ // <-- not allowed as document start! { \"tag\": \"cat\", \"records\": [ // <-- not allowed when ID or tag lives inside! { \"id\": 0, \"body\": { \"title\": \"some title\", \"footer\": \"some text\" }, \"keywords\": [\"some\", \"key\", \"words\"] }, { \"id\": 1, \"body\": { \"title\": \"some title\", \"footer\": \"some text\" }, \"keywords\": [\"some\", \"key\", \"words\"] } ] } ] You need to apply some kind of structure normalization. A workaround to such a data structure looks like this: const index = new Document({ document: { id: \"record:id\", tag: \"tag\", index: [ \"record:body:title\", \"record:body:footer\", \"record:body:keywords\" ] } }); function add(sequential_data){ for(let x = 0, data; x < sequential_data.length; x++){ data = sequential_data[x]; for(let y = 0, record; y < data.records.length; y++){ record = data.records[y]; index.add({ id: record.id, tag: data.tag, record: record }); } } } // now just use add() helper method as usual: add([{ // sequential structured data // take the data example above }]); You can skip the first loop when your document data has just one index as the outer array. Add/Update/Remove Documents to/from the Index Just pass the document array (or a single object) to the index: index.add(docs); Update index with a single object or an array of objects: index.update({ data:{ id: 0, title: \"Foo\", body: { content: \"Bar\" } } }); Remove a single object or an array of objects from the index: index.remove(docs); When the id is known, you can also simply remove by (faster): index.remove(id); Join / Append Arrays On the complex example above, the field keywords is an array but here the markup did not have brackets like keywords[]. That will also detect the array but instead of appending each entry to a new context, the array will be joined into on large string and added to the index. The difference of both kinds of adding array contents is the relevance when searching. When adding each item of an array via append() to its own context by using the syntax field[], then the relevance of the last entry concurrent with the first entry. When you left the brackets in the notation, it will join the array to one whitespace-separated string. Here the first entry has the highest relevance, whereas the last entry has the lowest relevance. So assuming the keyword from the example above are pre-sorted by relevance to its popularity, then you want to keep this order (information of relevance). For this purpose do not add brackets to the notation. Otherwise, it would take the entries in a new scoring context (the old order is getting lost). Also you can left bracket notation for better performance and smaller memory footprint. Use it when you did not need the granularity of relevance by the entries. Field-Search Search through all fields: index.search(query); Search through a specific field: index.search(query, { index: \"title\" }); Search through a given set of fields: index.search(query, { index: [\"title\", \"content\"] }); Same as: index.search(query, [\"title\", \"content\"]); Pass custom modifiers and queries to each field: index.search([{ field: \"content\", query: \"some query\", limit: 100, suggest: true },{ field: \"content\", query: \"some other query\", limit: 100, suggest: true }]); You can perform a search through the same field with different queries. See all available field-search options. The Result Set Schema of the result-set: fields[] => { field, result[] => { document }} The first index is an array of fields the query was applied to. Each of this field has a record (object) with 2 properties \"field\" and \"result\". The \"result\" is also an array and includes the result for this specific field. The result could be an array of IDs or as enriched with stored document data. A non-enriched result set now looks like: [{ field: \"title\", result: [0, 1, 2] },{ field: \"content\", result: [3, 4, 5] }] An enriched result set now looks like: [{ field: \"title\", result: [ { id: 0, doc: { /* document */ }}, { id: 1, doc: { /* document */ }}, { id: 2, doc: { /* document */ }} ] },{ field: \"content\", result: [ { id: 3, doc: { /* document */ }}, { id: 4, doc: { /* document */ }}, { id: 5, doc: { /* document */ }} ] }] When using pluck instead of \"field\" you can explicitly select just one field and get back a flat representation: index.search(query, { pluck: \"title\", enrich: true }); [ { id: 0, doc: { /* document */ }}, { id: 1, doc: { /* document */ }}, { id: 2, doc: { /* document */ }} ] This result set is a replacement of \"boolean search\". Instead of applying your bool logic to a nested object, you can apply your logic by yourself on top of the result-set dynamically. This opens hugely capabilities on how you process the results. Therefore, the results from the fields aren't squashed into one result anymore. That keeps some important information, like the name of the field as well as the relevance of each field results which didn't get mixed anymore. A field search will apply a query with the boolean \"or\" logic by default. Each field has its own result to the given query. There is one situation where the bool property is being still supported. When you like to switch the default \"or\" logic from the field search into \"and\", e.g.: index.search(query, { index: [\"title\", \"content\"], bool: \"and\" }); You will just get results which contains the query in both fields. That's it. Tags Like the key for the ID just define the path to the tag: const index = new Document({ document: { id: \"id\", tag: \"tag\", index: \"content\" } }); index.add({ id: 0, tag: \"cat\", content: \"Some content ...\" }); Your data also can have multiple tags as an array: index.add({ id: 1, tag: [\"animal\", \"dog\"], content: \"Some content ...\" }); You can perform a tag-specific search by: index.search(query, { index: \"content\", tag: \"animal\" }); This just gives you result which was tagged with the given tag. Use multiple tags when searching: index.search(query, { index: \"content\", tag: [\"cat\", \"dog\"] }); This gives you result which are tagged with one of the given tag. Multiple tags will apply as the boolean \"or\" by default. It just needs one of the tags to be existing. This is another situation where the bool property is still supported. When you like to switch the default \"or\" logic from the tag search into \"and\", e.g.: index.search(query, { index: \"content\", tag: [\"dog\", \"animal\"], bool: \"and\" }); You will just get results which contains both tags (in this example there is just one records which has the tag \"dog\" and \"animal\"). Tag Search You can also fetch results from one or more tags when no query was passed: index.search({ tag: [\"cat\", \"dog\"] }); In this case the result-set looks like: [{ tag: \"cat\", result: [ /* all cats */ ] },{ tag: \"dog\", result: [ /* all dogs */ ] }] Limit & Offset By default, every query is limited to 100 entries. Unbounded queries leads into issues. You need to set the limit as an option to adjust the size. You can set the limit and the offset for each query: index.search(query, { limit: 20, offset: 100 }); You cannot pre-count the size of the result-set. That's a limit by the design of FlexSearch. When you really need a count of all results you are able to page through, then just assign a high enough limit and get back all results and apply your paging offset manually (this works also on server-side). FlexSearch is fast enough that this isn't an issue. Document Store Only a document index can have a store. You can use a document index instead of a flat index to get this functionality also when only storing ID-content-pairs. You can define independently which fields should be indexed and which fields should be stored. This way you can index fields which should not be included in the search result. Do not use a store when: 1. an array of IDs as the result is good enough, or 2. you already have the contents/documents stored elsewhere (outside the index). When the store attribute was set, you have to include all fields which should be stored explicitly (acts like a whitelist). When the store attribute was not set, the original document is stored as a fallback. This will add the whole original content to the store: const index = new Document({ document: { index: \"content\", store: true } }); index.add({ id: 0, content: \"some text\" }); Access documents from internal store You can get indexed documents from the store: var data = index.get(1); You can update/change store contents directly without changing the index by: index.set(1, data); To update the store and also update the index then just use index.update, index.add or index.append. When you perform a query, weather it is a document index or a flat index, then you will always get back an array of IDs. Optionally you can enrich the query results automatically with stored contents by: index.search(query, { enrich: true }); Your results look now like: [{ id: 0, doc: { /* content from store */ } },{ id: 1, doc: { /* content from store */ } }] Configure Storage (Recommended) This will add just specific fields from a document to the store (the ID isn't necessary to keep in store): const index = new Document({ document: { index: \"content\", store: [\"author\", \"email\"] } }); index.add(id, content); You can configure independently what should being indexed and what should being stored. It is highly recommended to make use of this whenever you can. Here a useful example of configuring doc and store: const index = new Document({ document: { index: \"content\", store: [\"author\", \"email\"] } }); index.add({ id: 0, author: \"Jon Doe\", email: \"john@mail.com\", content: \"Some content for the index ...\" }); You can query through the contents and will get back the stored values instead: index.search(\"some content\", { enrich: true }); Your results are now looking like: [{ field: \"content\", result: [{ id: 0, doc: { author: \"Jon Doe\", email: \"john@mail.com\", } }] }] Both field \"author\" and \"email\" are not indexed. Chaining Simply chain methods like: var index = FlexSearch.create() .addMatcher({'â': 'a'}) .add(0, 'foo') .add(1, 'bar'); index.remove(0).update(1, 'foo').add(2, 'foobar'); Enable Contextual Scoring Create an index and use the default context: var index = new FlexSearch({ tokenize: \"strict\", context: true }); Create an index and apply custom options for the context: var index = new FlexSearch({ tokenize: \"strict\", context: { resolution: 5, depth: 3, bidirectional: true } }); Only the tokenizer \"strict\" is actually supported by the contextual index. The contextual index requires additional amount of memory depending on depth. Auto-Balanced Cache (By Popularity) You need to initialize the cache and its limit during the creation of the index: const index = new Index({ cache: 100 }); const results = index.searchCache(query); A common scenario for using a cache is an autocomplete or instant search when typing. When passing a number as a limit the cache automatically balance stored entries related to their popularity. When just using \"true\" the cache is unbounded and perform actually 2-3 times faster (because the balancer do not have to run). Worker Parallelism (Browser + Node.js) The new worker model from v0.7.0 is divided into \"fields\" from the document (1 worker = 1 field index). This way the worker becomes able to solve tasks (subtasks) completely. The downside of this paradigm is they might not have been perfect balanced in storing contents (fields may have different length of contents). On the other hand there is no indication that balancing the storage gives any advantage (they all require the same amount in total). When using a document index, then just apply the option \"worker\": const index = new Document({ index: [\"tag\", \"name\", \"title\", \"text\"], worker: true }); index.add({ id: 1, tag: \"cat\", name: \"Tom\", title: \"some\", text: \"some\" }).add({ id: 2, tag: \"dog\", name: \"Ben\", title: \"title\", text: \"content\" }).add({ id: 3, tag: \"cat\", name: \"Max\", title: \"to\", text: \"to\" }).add({ id: 4, tag: \"dog\", name: \"Tim\", title: \"index\", text: \"index\" }); Worker 1: { 1: \"cat\", 2: \"dog\", 3: \"cat\", 4: \"dog\" } Worker 2: { 1: \"Tom\", 2: \"Ben\", 3: \"Max\", 4: \"Tim\" } Worker 3: { 1: \"some\", 2: \"title\", 3: \"to\", 4: \"index\" } Worker 4: { 1: \"some\", 2: \"content\", 3: \"to\", 4: \"index\" } When you perform a field search through all fields then this task is being balanced perfectly through all workers, which can solve their subtasks independently. Worker Index Above we have seen that documents will create worker automatically for each field. You can also create a WorkerIndex directly (same like using Index instead of Document). Use as ES6 module: import WorkerIndex from \"./worker/index.js\"; const index = new WorkerIndex(options); index.add(1, \"some\") .add(2, \"content\") .add(3, \"to\") .add(4, \"index\"); Or when bundled version was used instead: var index = new FlexSearch.Worker(options); index.add(1, \"some\") .add(2, \"content\") .add(3, \"to\") .add(4, \"index\"); Such a WorkerIndex works pretty much the same as a created instance of Index. A WorkerIndex only support the async variant of all methods. That means when you call index.search() on a WorkerIndex this will perform also in async the same way as index.searchAsync() will do. Worker Threads (Node.js) The worker model for Node.js is based on \"worker threads\" and works exactly the same way: const { Document } = require(\"flexsearch\"); const index = new Document({ index: [\"tag\", \"name\", \"title\", \"text\"], worker: true }); Or create a single worker instance for a non-document index: const { Worker } = require(\"flexsearch\"); const index = new Worker({ options }); The Worker Async Model (Best Practices) A worker will always perform as async. On a query method call you always should handle the returned promise (e.g. use await) or pass a callback function as the last parameter. const index = new Document({ index: [\"tag\", \"name\", \"title\", \"text\"], worker: true }); All requests and sub-tasks will run in parallel (prioritize \"all tasks completed\"): index.searchAsync(query, callback); index.searchAsync(query, callback); index.searchAsync(query, callback); Also (prioritize \"all tasks completed\"): index.searchAsync(query).then(callback); index.searchAsync(query).then(callback); index.searchAsync(query).then(callback); Or when you have just one callback when all requests are done, simply use Promise.all() which also prioritize \"all tasks completed\": Promise.all([ index.searchAsync(query), index.searchAsync(query), index.searchAsync(query) ]).then(callback); Inside the callback of Promise.all() you will also get an array of results as the first parameter respectively for each query you put into. When using await you can prioritize the order (prioritize \"first task completed\") and solve requests one by one and just process the sub-tasks in parallel: await index.searchAsync(query); await index.searchAsync(query); await index.searchAsync(query); Same for index.add(), index.append(), index.remove() or index.update(). Here there is a special case which isn't disabled by the library, but you need to keep in mind when using Workers. When you call the \"synced\" version on a worker index: index.add(doc); index.add(doc); index.add(doc); // contents aren't indexed yet, // they just queued on the message channel Of course, you can do that but keep in mind that the main thread does not have an additional queue for distributed worker tasks. Running these in a long loop fires content massively to the message channel via worker.postMessage() internally. Luckily the browser and Node.js will handle such incoming tasks for you automatically (as long enough free RAM is available). When using the \"synced\" version on a worker index, the content isn't indexed one line below, because all calls are treated as async by default. When adding/updating/removing large bulks of content to the index (or high frequency), it is recommended to use the async version along with async/await to keep a low memory footprint during long processes. Export / Import Export The export has slightly changed. The export now consist of several smaller parts, instead of just one large bulk. You need to pass a callback function which has 2 arguments \"key\" and \"data\". This callback function is called by each part, e.g.: index.export(function(key, data){ // you need to store both the key and the data! // e.g. use the key for the filename and save your data localStorage.setItem(key, data); }); Exporting data to the localStorage isn't really a good practice, but if size is not a concern than use it if you like. The export primarily exists for the usage in Node.js or to store indexes you want to delegate from a server to the client. The size of the export corresponds to the memory consumption of the library. To reduce export size you have to use a configuration which has less memory footprint (use the table at the bottom to get information about configs and its memory allocation). When your save routine runs asynchronously you have to return a promise: index.export(function(key, data){ return new Promise(function(resolve){ // do the saving as async resolve(); }); }); You cannot export the additional table for the \"fastupdate\" feature. These table exists of references and when stored they fully get serialized and becomes too large. The lib will handle these automatically for you. When importing data, the index automatically disables \"fastupdate\". Import Before you can import data, you need to create your index first. For document indexes provide the same document descriptor you used when export the data. This configuration isn't stored in the export. var index = new Index({ ... }); To import the data just pass a key and data: index.import(key, localStorage.getItem(key)); You need to import every key! Otherwise, your index does not work. You need to store the keys from the export and use this keys for the import (the order of the keys can differ). This is just for demonstration and is not recommended, because you might have other keys in your localStorage which aren't supported as an import: var keys = Object.keys(localStorage); for(let i = 0, key; i < keys.length; i++){ key = keys[i]; index.import(key, localStorage.getItem(key)); } Languages Language-specific definitions are being divided into two groups: Charset encode, type: function(string):string[] rtl, type: boolean Language matcher, type: {string: string} stemmer, type: {string: string} filter, type: string[] The charset contains the encoding logic, the language contains stemmer, stopword filter and matchers. Multiple language definitions can use the same charset encoder. Also this separation let you manage different language definitions for special use cases (e.g. names, cities, dialects/slang, etc.). To fully describe a custom language on the fly you need to pass: const index = FlexSearch({ // mandatory: encode: (content) => [words], // optionally: rtl: false, stemmer: {}, matcher: {}, filter: [] }); When passing no parameter it uses the latin:default schema by default. Field Category Description encode charset The encoder function. Has to return an array of separated words (or an empty string). rtl charset A boolean property which indicates right-to-left encoding. filter language Filter are also known as \"stopwords\", they completely filter out words from being indexed. stemmer language Stemmer removes word endings and is a kind of \"partial normalization\". A word ending just matched when the word length is bigger than the matched partial. matcher language Matcher replaces all occurrences of a given string regardless of its position and is also a kind of \"partial normalization\". 1. Language Packs: ES6 Modules The most simple way to assign charset/language specific encoding via modules is: import charset from \"./dist/module/lang/latin/advanced.js\"; import lang from \"./dist/module/lang/en.js\"; const index = FlexSearch({ charset: charset, lang: lang }); Just import the default export by each module and assign them accordingly. The full qualified example from above is: import { encode, rtl } from \"./dist/module/lang/latin/advanced.js\"; import { stemmer, filter, matcher } from \"./dist/module/lang/en.js\"; const index = FlexSearch({ encode: encode, rtl: rtl, stemmer: stemmer, matcher: matcher, filter: filter }); The example above is the standard interface which is at least exported from each charset/language. You can also define the encoder directly and left all other options: import simple from \"./dist/module/lang/latin/simple.js\"; const index = FlexSearch({ encode: simple }); Available Latin Encoders default simple balance advanced extra You can assign a charset by passing the charset during initialization, e.g. charset: \"latin\" for the default charset encoder or charset: \"latin:soundex\" for a encoder variant. Dialect / Slang Language definitions (especially matchers) also could be used to normalize dialect and slang of a specific language. 2. Language Packs: ES5 (Language Packs) You need to make the charset and/or language definitions available by: All charset definitions are included in the flexsearch.bundle.js build by default, but no language-specific definitions are included You can load packages located in /dist/lang/ (files refers to languages, folders are charsets) You can make a custom build When loading language packs, make sure that the library was loaded before: <script src=\"dist/flexsearch.light.js\"></script> <script src=\"dist/lang/latin/default.min.js\"></script> <script src=\"dist/lang/en.min.js\"></script> When using the full \"bundle\" version the built-in latin encoders are already included and you just have to load the language file: <script src=\"dist/flexsearch.bundle.js\"></script> <script src=\"dist/lang/en.min.js\"></script> Because you loading packs as external packages (non-ES6-modules) you have to initialize them by shortcuts: const index = FlexSearch({ charset: \"latin:soundex\", lang: \"en\" }); Use the charset:variant notation to assign charset and its variants. When just passing the charset without a variant will automatically resolve as charset:default. You can also override existing definitions, e.g.: const index = FlexSearch({ charset: \"latin\", lang: \"en\", matcher: {} }); Passed definitions will not extend default definitions, they will replace them. When you like to extend a definition just create a new language file and put in all the logic. Encoder Variants It is pretty straight forward when using an encoder variant: <script src=\"dist/flexsearch.light.js\"></script> <script src=\"dist/lang/latin/advanced.min.js\"></script> <script src=\"dist/lang/latin/extra.min.js\"></script> <script src=\"dist/lang/en.min.js\"></script> When using the full \"bundle\" version the built-in latin encoders are already included and you just have to load the language file: <script src=\"dist/flexsearch.bundle.js\"></script> <script src=\"dist/lang/en.min.js\"></script> const index_advanced = FlexSearch({ charset: \"latin:advanced\" }); const index_extra = FlexSearch({ charset: \"latin:extra\" }); Partial Tokenizer In FlexSearch you can't provide your own partial tokenizer, because it is a direct dependency to the core unit. The built-in tokenizer of FlexSearch splits each word into fragments by different patterns: strict (supports contextual index) forward reverse (including forward) full Language Processing Pipeline This is the default pipeline provided by FlexSearch: Custom Pipeline At first take a look into the default pipeline in src/common.js. It is very simple and straight forward. The pipeline will process as some sort of inversion of control, the final encoder implementation has to handle charset and also language specific transformations. This workaround has left over from many tests. Inject the default pipeline by e.g.: this.pipeline( /* string: */ str.toLowerCase(), /* normalize: */ false, /* split: */ split, /* collapse: */ false ); Use the pipeline schema from above to understand the iteration and the difference of pre-encoding and post-encoding. Stemmer and matchers needs to be applied after charset normalization but before language transformations, filters also. Here is a good example of extending pipelines: src/lang/latin/extra.js → src/lang/latin/advanced.js → src/lang/latin/simple.js. How to contribute? Search for your language in src/lang/, if it exists you can extend or provide variants (like dialect/slang). If the language doesn't exist create a new file and check if any of the existing charsets (e.g. latin) fits to your language. When no charset exist, you need to provide a charset as a base for the language. A new charset should provide at least: encode A function which normalize the charset of a passed text content (remove special chars, lingual transformations, etc.) and returns an array of separated words. Also stemmer, matcher or stopword filter needs to be applied here. When the language has no words make sure to provide something similar, e.g. each chinese sign could also be a \"word\". Don't return the whole text content without split. rtl A boolean flag which indicates right-to-left encoding Basically the charset needs just to provide an encoder function along with an indicator for right-to-left encoding: export function encode(str){ return [str] } export const rtl = false; Encoder Matching Comparison Reference String: \"Björn-Phillipp Mayer\" Query default simple advanced extra björn yes yes yes yes björ yes yes yes yes bjorn no yes yes yes bjoern no no yes yes philipp no no yes yes filip no no yes yes björnphillip no yes yes yes meier no no yes yes björn meier no no yes yes meier fhilip no no yes yes byorn mair no no no yes (false positives) no no no yes Memory Allocation The book \"Gulliver's Travels Swift Jonathan 1726\" was fully indexed for the examples below. The most memory-optimized meaningful setting will allocate just 1.2 Mb for the whole book indexed! This is probably the most tiny memory footprint you will get from a search library. import { encode } from \"./lang/latin/extra.js\"; index = new Index({ encode: encode, tokenize: \"strict\", optimize: true, resolution: 1, minlength: 3, fastupdate: false, context: false }); Memory Consumption The book \"Gulliver's Travels\" (Swift Jonathan 1726) was completely indexed for this test: Compare Impact of Memory Allocation by default a lexical index is very small: depth: 0, bidirectional: 0, resolution: 3, minlength: 0 => 2.1 Mb a higher resolution will increase the memory allocation: depth: 0, bidirectional: 0, resolution: 9, minlength: 0 => 2.9 Mb using the contextual index will increase the memory allocation: depth: 1, bidirectional: 0, resolution: 9, minlength: 0 => 12.5 Mb a higher contextual depth will increase the memory allocation: depth: 2, bidirectional: 0, resolution: 9, minlength: 0 => 21.5 Mb a higher minlength will decrease memory allocation: depth: 2, bidirectional: 0, resolution: 9, minlength: 3 => 19.0 Mb using bidirectional will decrease memory allocation: depth: 2, bidirectional: 1, resolution: 9, minlength: 3 => 17.9 Mb enable the option \"fastupdate\" will increase memory allocation: depth: 2, bidirectional: 1, resolution: 9, minlength: 3 => 6.3 Mb Full Comparison Table Every search library is constantly in competition with these 4 properties: Memory Allocation Performance Matching Capabilities Relevance Order (Scoring) FlexSearch provides you many parameters you can use to adjust the optimal balance for your specific use-case. Modifier Memory Impact * Performance Impact ** Matching Impact ** Scoring Impact ** resolution +1 (per level) +1 (per level) 0 +2 (per level) depth +4 (per level) -1 (per level) -10 + depth +10 minlength -2 (per level) +2 (per level) -3 (per level) +2 (per level) bidirectional -2 0 +3 -1 fastupdate +1 +10 (update, remove) 0 0 optimize: true -7 -1 0 -3 encoder: \"icase\" 0 0 0 0 encoder: \"simple\" -2 -1 +2 0 encoder: \"advanced\" -3 -2 +4 0 encoder: \"extra\" -5 -5 +6 0 encoder: \"soundex\" -6 -2 +8 0 tokenize: \"strict\" 0 0 0 0 tokenize: \"forward\" +3 -2 +5 0 tokenize: \"reverse\" +5 -4 +7 0 tokenize: \"full\" +8 -5 +10 0 document index +3 (per field) -1 (per field) 0 0 document tags +1 (per tag) -1 (per tag) 0 0 store: true +5 (per document) 0 0 0 store: [fields] +1 (per field) 0 0 0 cache: true +10 +10 0 0 cache: 100 +1 +9 0 0 type of ids: number 0 0 0 0 type of ids: string +3 -3 0 0 * range from -10 to 10, lower is better (-10 => big decrease, 0 => unchanged, +10 => big increase) ** range from -10 to 10, higher is better Presets memory (primary optimize for memory) performance (primary optimize for performance) match (primary optimize for matching) score (primary optimize for scoring) default (the default balanced profile) These profiles are covering standard use cases. It is recommended to apply custom configuration instead of using profiles to get the best out for your situation. Every profile could be optimized further to its specific task, e.g. extreme performance optimized configuration or extreme memory and so on. You can pass a preset during creation/initialization of the index. Best Practices Use numeric IDs It is recommended to use numeric id values as reference when adding content to the index. The byte length of passed ids influences the memory consumption significantly. If this is not possible you should consider to use a index table and map the ids with indexes, this becomes important especially when using contextual indexes on a large amount of content. Split Complexity Whenever you can, try to divide content by categories and add them to its own index, e.g.: var action = new FlexSearch(); var adventure = new FlexSearch(); var comedy = new FlexSearch(); This way you can also provide different settings for each category. This is actually the fastest way to perform a fuzzy search. To make this workaround more extendable you can use a short helper: var index = {}; function add(id, cat, content){ (index[cat] || ( index[cat] = new FlexSearch )).add(id, content); } function search(cat, query){ return index[cat] ? index[cat].search(query) : []; } Add content to the index: add(1, \"action\", \"Movie Title\"); add(2, \"adventure\", \"Movie Title\"); add(3, \"comedy\", \"Movie Title\"); Perform queries: var results = search(\"action\", \"movie title\"); // --> [1] Split indexes by categories improves performance significantly. Copyright 2018-2021 Nextapps GmbH Released under the Apache 2.0 License"
  },
  "docfx_template/styles/node_modules/@types/flexsearch/README.html": {
    "href": "docfx_template/styles/node_modules/@types/flexsearch/README.html",
    "title": "Installation",
    "keywords": "Installation npm install --save @types/flexsearch Summary This package contains type definitions for flexsearch (https://github.com/nextapps-de/flexsearch/). Details Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/flexsearch. Additional Details Last updated: Thu, 14 Sep 2023 15:26:41 GMT Dependencies: none Global values: none Credits These definitions were written by LOSSES Don."
  },
  "docfx_template/styles/node_modules/flexsearch/CHANGELOG.html": {
    "href": "docfx_template/styles/node_modules/flexsearch/CHANGELOG.html",
    "title": "Changelog",
    "keywords": "Changelog v0.7.0 Bidirectional Context (the order of words can now vary, does not increase memory when using bidirectional context) New memory-friendly strategy for indexes (switchable, saves up to 50% of memory for each index, slightly decrease performance) Better scoring calculation (one of the biggest concerns of the old implementation was that the order of arrays processed in the intersection has affected the order of relevance in the final result) Fix resolution (the resolution in the old implementation was not fully stretched through the whole range in some cases) Skip words (optionally, automatically skip words from the context chain which are too short) Hugely improves performance of long queries (up to 450x faster!) and also memory allocation (up to 250x less memory) New fast-update strategy (optionally, hugely improves performance of all updates and removals of indexed contents up to 2850x) Improved auto-balanced cache (keep and expire cache by popularity) Append contents to already existing entries (already indexed documents or contents) New method \"contain\" to check if an ID was already indexed Access documents directly from internal store (read/write) Suggestions are hugely improved, falls back from context search all the way down to single term match Document descriptor has now array support (optionally adds array entries via the new append under the hood to provide a unique relevance context for each entry) Document storage handler gets improved Results from document index now grouped by field (this is one of the few bigger breaking changes which needs migrations of your old code) Boolean search has a new concept (use in combination of the new result structure) Node.js Worker Threads Improved default latin encoders New parallelization model and workload distribution Improved Export/Import Tag Search Offset pagination Enhanced Field Search Improved sorting by relevance (score) Added Context Scoring (context index has its own resolution) Enhanced charset normalization Improved bundler (support for inline WebWorker) These features have been removed: Where-Clause Index Information index.info() Paging Cursor (was replaced by offset) Migration Quick Overview The \"async\" options was removed, instead you can call each method in its async version, e.g. index.addAsync or index.searchAsync. Define document fields as object keys is not longer supported due to the unification of all option payloads. A full configuration example for a context-based index: var index = new Index({ tokenize: \"strict\", resolution: 9, minlength: 3, optimize: true, fastupdate: true, cache: 100, context: { depth: 1, resolution: 3, bidirectional: true } }); The resolution could be set also for the contextual index. A full configuration example for a document based index: const index = new Document({ tokenize: \"forward\", optimize: true, resolution: 9, cache: 100, worker: true, document: { id: \"id\", tag: \"tag\", store: [ \"title\", \"content\" ], index: [{ field: \"title\", tokenize: \"forward\", optimize: true, resolution: 9 },{ field: \"content\", tokenize: \"strict\", optimize: true, resolution: 9, minlength: 3, context: { depth: 1, resolution: 3 } }] } }); A full configuration example for a document search: index.search({ enrich: true, bool: \"and\", tag: [\"cat\", \"dog\"], index: [{ field: \"title\", query: \"some query\", limit: 100, suggest: true },{ field: \"content\", query: \"same or other query\", limit: 100, suggest: true }] }); Where Clause Replacement Old Syntax: const result = index.where({ cat: \"comedy\", year: \"2018\" }); Equivalent Syntax (0.7.x): const data = Object.values(index.store); The line above retrieves data from the document store (just useful when not already available in your runtime). const result = data.filter(function(item){ return item.cat === \"comedy\" && item.year === \"2018\"; }); Also considering using the Tag-Search feature, which partially replaces the Where-Clause with a huge performance boost. v0.6.0 Pagination v0.5.3 Logical Operator v0.5.2 Intersect Partial Results v0.5.1 Customizable Scoring Resolution v0.5.0 Where / Find Documents Document Tags Custom Sort v0.4.0 Index Documents (Field-Search) v0.3.6 Right-To-Left Support CJK Word Splitting Support v0.3.5 Promise Support v0.3.4 Export / Import Indexes (Serialize) v0.3.0 Profiler Support"
  },
  "docfx_template/styles/node_modules/flexsearch/README.html": {
    "href": "docfx_template/styles/node_modules/flexsearch/README.html",
    "title": "",
    "keywords": "Web's fastest and most memory-flexible full-text search library with zero dependencies. Basic Start • API Reference • Document Indexes • Using Worker • Changelog FlexSearch v0.7.0 The new version is finally available. FlexSearch v0.7.0 is a modern re-implementation and was newly developed from the ground up. The result is an improvement in every single aspect and covers tons of enhancements and improvements which was collected over the last 3 years. This new version has a good compatibility with the old generation, but it might require some migrations steps in your code. Read the documentation of new features and changes: https://github.com/nextapps-de/flexsearch/blob/master/doc/0.7.0.md Read the documentation of new language encoding features: https://github.com/nextapps-de/flexsearch/blob/master/doc/0.7.0-lang.md When it comes to raw search speed FlexSearch outperforms every single searching library out there and also provides flexible search capabilities like multi-field search, phonetic transformations or partial matching. Depending on the used options it also provides the most memory-efficient index. FlexSearch introduce a new scoring algorithm called \"contextual index\" based on a pre-scored lexical dictionary architecture which actually performs queries up to 1,000,000 times faster compared to other libraries. FlexSearch also provides you a non-blocking asynchronous processing model as well as web workers to perform any updates or queries on the index in parallel through dedicated balanced threads. Supported Platforms: Browser Node.js Library Comparison \"Gulliver's Travels\": Performance Benchmark Scoring Benchmark Memory Consumption Plugins (extern projects): https://github.com/angeloashmore/react-use-flexsearch https://www.gatsbyjs.org/packages/gatsby-plugin-flexsearch/ Get Latest Stable Build (Recommended) Build File CDN flexsearch.bundle.js Download https://rawcdn.githack.com/nextapps-de/flexsearch/0.7.31/dist/flexsearch.bundle.js flexsearch.light.js Download https://rawcdn.githack.com/nextapps-de/flexsearch/0.7.31/dist/flexsearch.light.js flexsearch.compact.js Download https://rawcdn.githack.com/nextapps-de/flexsearch/0.7.31/dist/flexsearch.compact.js flexsearch.es5.js * Download https://rawcdn.githack.com/nextapps-de/flexsearch/0.7.31/dist/flexsearch.es5.js ES6 Modules Download The /dist/module/ folder of this Github repository * The bundle \"flexsearch.es5.js\" includes polyfills for EcmaScript 5 Support. Get Latest (NPM) npm install flexsearch Get Latest Nightly (Do not use for production!) Just exchange the version number from the URLs above with \"master\", e.g.: \"/flexsearch/0.7.31/dist/\" into \"/flexsearch/master/dist\". Compare Web-Bundles The Node.js package includes all features from flexsearch.bundle.js. Feature flexsearch.bundle.js flexsearch.compact.js flexsearch.light.js Presets ✓ ✓ - Async Search ✓ ✓ - Workers (Web + Node.js) ✓ - - Contextual Indexes ✓ ✓ ✓ Index Documents (Field-Search) ✓ ✓ - Document Store ✓ ✓ - Partial Matching ✓ ✓ ✓ Relevance Scoring ✓ ✓ ✓ Auto-Balanced Cache by Popularity ✓ - - Tags ✓ - - Suggestions ✓ ✓ - Phonetic Matching ✓ ✓ - Customizable Charset/Language (Matcher, Encoder, Tokenizer, Stemmer, Filter, Split, RTL) ✓ ✓ ✓ Export / Import Indexes ✓ - - File Size (gzip) 6.8 kb 5.3 kb 2.9 kb Performance Benchmark (Ranking) Run Comparison: Performance Benchmark \"Gulliver's Travels\" Operation per seconds, higher is better, except the test \"Memory\" on which lower is better. Rank Library Memory Query (Single Term) Query (Multi Term) Query (Long) Query (Dupes) Query (Not Found) 1 FlexSearch 17 7084129 1586856 511585 2017142 3202006 2 JSii 27 6564 158149 61290 95098 534109 3 Wade 424 20471 78780 16693 225824 213754 4 JS Search 193 8221 64034 10377 95830 167605 5 Elasticlunr.js 646 5412 7573 2865 23786 13982 6 BulkSearch 1021 3069 3141 3333 3265 21825569 7 MiniSearch 24348 4406 10945 72 39989 17624 8 bm25 15719 1429 789 366 884 1823 9 Lunr.js 2219 255 271 272 266 267 10 FuzzySearch 157373 53 38 15 32 43 11 Fuse 7641904 6 2 1 2 3 Contextual Search Note: This feature is disabled by default because of its extended memory usage. Read here get more information about and how to enable. FlexSearch introduce a new scoring mechanism called Contextual Search which was invented by Thomas Wilkerling, the author of this library. A Contextual Search incredibly boost up queries to a complete new level but also requires some additional memory (depending on depth). The basic idea of this concept is to limit relevance by its context instead of calculating relevance through the whole distance of its corresponding document. This way contextual search also improves the results of relevance-based queries on a large amount of text data. Load Library There are 3 types of indexes: Index is a flat high performance index which stores id-content-pairs. Worker / WorkerIndex is also a flat index which stores id-content-pairs but runs in background as a dedicated worker thread. Document is multi-field index which can store complex JSON documents (could also exist of worker indexes). The most of you probably need just one of them according to your scenario. ES6 Modules (Browser): import Index from \"./index.js\"; import Document from \"./document.js\"; import WorkerIndex from \"./worker/index.js\"; const index = new Index(options); const document = new Document(options); const worker = new WorkerIndex(options); Bundle (Browser) <html> <head> <script src=\"js/flexsearch.bundle.js\"></script> </head> ... Or via CDN: <script src=\"https://cdn.jsdelivr.net/gh/nextapps-de/flexsearch@0.7.31/dist/flexsearch.bundle.js\"></script> AMD: var FlexSearch = require(\"./flexsearch.js\"); Load one of the builds from the folder dist within your html as a script and use as follows: var index = new FlexSearch.Index(options); var document = new FlexSearch.Document(options); var worker = new FlexSearch.Worker(options); Node.js npm install flexsearch In your code include as follows: const { Index, Document, Worker } = require(\"flexsearch\"); const index = new Index(options); const document = new Document(options); const worker = new Worker(options); Basic Usage and Variants index.add(id, text); index.search(text); index.search(text, limit); index.search(text, options); index.search(text, limit, options); index.search(options); document.add(doc); document.add(id, doc); document.search(text); document.search(text, limit); document.search(text, options); document.search(text, limit, options); document.search(options); worker.add(id, text); worker.search(text); worker.search(text, limit); worker.search(text, options); worker.search(text, limit, options); worker.search(text, limit, options, callback); worker.search(options); The worker inherits from type Index and does not inherit from type Document. Therefore, a WorkerIndex basically works like a standard FlexSearch Index. Worker-Support in documents needs to be enabled by just passing the appropriate option during creation { worker: true }. Every method called on a Worker index is treated as async. You will get back a Promise or you can provide a callback function as the last parameter alternatively. API Overview Global methods: FlexSearch.registerCharset(name, charset) FlexSearch.registerLanguage(name, language) Index methods: Index.add(id, string) * Index.append(id, string) * Index.update(id, string) * Index.remove(id) * Index.search(string, <limit>, <options>) * Index.search(options) * async Index.export(handler) async Index.import(key, data) WorkerIndex methods: async Index.add(id, string) async Index.append(id, string) async Index.update(id, string) async Index.remove(id) async Index.search(string, <limit>, <options>) async Index.search(options) async Index.export(handler) (WIP) async Index.import(key, data) (WIP) Document methods: Document.add(<id>, document) * Document.append(<id>, document) * Document.update(<id>, document) * Document.remove(id || document) * Document.search(string, <limit>, <options>) * Document.search(options) * async Document.export(handler) async Document.import(key, data) * For each of those methods there exist an asynchronous equivalent: Async Version: async .addAsync( ... , <callback>) async .appendAsync( ... , <callback>) async .updateAsync( ... , <callback>) async .removeAsync( ... , <callback>) async .searchAsync( ... , <callback>) Async methods will return a Promise, alternatively you can pass a callback function as the last parameter. Methods export and also import are always async as well as every method you call on a Worker-based Index. Options FlexSearch is highly customizable. Make use of the right options can really improve your results as well as memory economy and query time. Index Options Option Values Description Default preset \"memory\" \"performance\" \"match\" \"score\" \"default\" The configuration profile as a shortcut or as a base for your custom settings. \"default\" tokenize \"strict\" \"forward\" \"reverse\" \"full\" The indexing mode (tokenizer). Choose one of the built-ins or pass a custom tokenizer function. \"strict\" cache Boolean Number Enable/Disable and/or set capacity of cached entries. When passing a number as a limit the cache automatically balance stored entries related to their popularity. Note: When just using \"true\" the cache has no limits and growth unbounded. false resolution Number Sets the scoring resolution (default: 9). 9 context Boolean Context Options Enable/Disable contextual indexing. When passing \"true\" as value it will take the default values for the context. false optimize Boolean When enabled it uses a memory-optimized stack flow for the index. true boost function(arr, str, int) => float A custom boost function used when indexing contents to the index. The function has this signature: Function(words[], term, index) => Float. It has 3 parameters where you get an array of all words, the current term and the current index where the term is placed in the word array. You can apply your own calculation e.g. the occurrences of a term and return this factor (<1 means relevance is lowered, >1 means relevance is increased). Note: this feature is currently limited by using the tokenizer \"strict\" only. null Language-specific Options and Encoding: charset Charset Payload String (key) Provide a custom charset payload or pass one of the keys of built-in charsets. \"latin\" language Language Payload String (key) Provide a custom language payload or pass in language shorthand flag (ISO-3166) of built-in languages. null encode false \"default\" \"simple\" \"balance\" \"advanced\" \"extra\" function(str) => [words] The encoding type. Choose one of the built-ins or pass a custom encoding function. \"default\" stemmer false String Function false filter false String Function false matcher false String Function false Additional Options for Document Indexes: worker Boolean Enable/Disable and set count of running worker threads. false document Document Descriptor Includes definitions for the document index and storage. Context Options Option Values Description Default resolution Number Sets the scoring resolution for the context (default: 1). 1 depth false Number Enable/Disable contextual indexing and also sets contextual distance of relevance. Depth is the maximum number of words/tokens away a term to be considered as relevant. 1 bidirectional Boolean Sets the scoring resolution (default: 9). true Document Options Option Values Description Default id String \"id\"\" tag false String \"tag\" index String Array<String> Array<Object> store Boolean String Array<String> false Charset Options Option Values Description Default split false RegExp String The rule to split words when using non-custom tokenizer (built-ins e.g. \"forward\"). Use a string/char or use a regular expression (default: /\\W+/). /[\\W_]+/ rtl Boolean Enables Right-To-Left encoding. false encode function(str) => [words] The custom encoding function. /lang/latin/default.js Language Options Option Values Description stemmer false String Function Disable or pass in language shorthand flag (ISO-3166) or a custom object. filter false String Function Disable or pass in language shorthand flag (ISO-3166) or a custom array. matcher false String Function Disable or pass in language shorthand flag (ISO-3166) or a custom array. Search Options Option Values Description Default limit number Sets the limit of results. 100 offset number Apply offset (skip items). 0 suggest Boolean Enables suggestions in results. false Document Search Options Additionally, to the Index search options above. Option Values Description Default index String Array<String> Array<Object> Sets the document fields which should be searched. When no field is set, all fields will be searched. Custom options per field are also supported. tag String Array<String> Sets the document fields which should be searched. When no field is set, all fields will be searched. Custom options per field are also supported. false enrich Boolean Enrich IDs from the results with the corresponding documents. false bool \"and\" \"or\" Sets the used logical operator when searching through multiple fields or tags. \"or\" Tokenizer (Prefix Search) Tokenizer affects the required memory also as query time and flexibility of partial matches. Try to choose the most upper of these tokenizer which fits your needs: Option Description Example Memory Factor (n = length of word) \"strict\" index whole words foobar * 1 \"forward\" incrementally index words in forward direction foobar foobar * n \"reverse\" incrementally index words in both directions foobar foobar * 2n - 1 \"full\" index every possible combination foobar foobar * n * (n - 1) Encoders Encoding affects the required memory also as query time and phonetic matches. Try to choose the most upper of these encoders which fits your needs, or pass in a custom encoder: Option Description False-Positives Compression false Turn off encoding no 0% \"default\" Case in-sensitive encoding no 0% \"simple\" Case in-sensitive encoding Charset normalizations no ~ 3% \"balance\" Case in-sensitive encoding Charset normalizations Literal transformations no ~ 30% \"advanced\" Case in-sensitive encoding Charset normalizations Literal transformations Phonetic normalizations no ~ 40% \"extra\" Case in-sensitive encoding Charset normalizations Literal transformations Phonetic normalizations Soundex transformations yes ~ 65% function() Pass custom encoding via function(string):[words] Usage Create a new index var index = new Index(); Create a new index and choosing one of the presets: var index = new Index(\"performance\"); Create a new index with custom options: var index = new Index({ charset: \"latin:extra\", tokenize: \"reverse\", resolution: 9 }); Create a new index and extend a preset with custom options: var index = new FlexSearch({ preset: \"memory\", tokenize: \"forward\", resolution: 5 }); See all available custom options. Add text item to an index Every content which should be added to the index needs an ID. When your content has no ID, then you need to create one by passing an index or count or something else as an ID (a value from type number is highly recommended). Those IDs are unique references to a given content. This is important when you update or adding over content through existing IDs. When referencing is not a concern, you can simply use something simple like count++. Index.add(id, string) index.add(0, \"John Doe\"); Search items Index.search(string | options, <limit>, <options>) index.search(\"John\"); Limit the result: index.search(\"John\", 10); Check existence of already indexed IDs You can check if an ID was already indexed by: if(index.contain(1)){ console.log(\"ID is already in index\"); } Async You can call each method in its async version, e.g. index.addAsync or index.searchAsync. You can assign callbacks to each async function: index.addAsync(id, content, function(){ console.log(\"Task Done\"); }); index.searchAsync(query, function(result){ console.log(\"Results: \", result); }); Or do not pass a callback function and getting back a Promise instead: index.addAsync(id, content).then(function(){ console.log(\"Task Done\"); }); index.searchAsync(query).then(function(result){ console.log(\"Results: \", result); }); Or use async and await: async function add(){ await index.addAsync(id, content); console.log(\"Task Done\"); } async function search(){ const results = await index.searchAsync(query); console.log(\"Results: \", result); } Append Contents You can append contents to an existing index like: index.append(id, content); This will not overwrite the old indexed contents as it will do when perform index.update(id, content). Keep in mind that index.add(id, content) will also perform \"update\" under the hood when the id was already being indexed. Appended contents will have their own context and also their own full resolution. Therefore, the relevance isn't being stacked but gets its own context. Let us take this example: index.add(0, \"some index\"); index.append(0, \"some appended content\"); index.add(1, \"some text\"); index.append(1, \"index appended content\"); When you query index.search(\"index\") then you will get index id 1 as the first entry in the result, because the context starts from zero for the appended data (isn't stacked to the old context) and here \"index\" is the first term. If you didn't want this behavior than just use the standard index.add(id, content) and provide the full length of content. Update item from an index Index.update(id, string) index.update(0, \"Max Miller\"); Remove item from an index Index.remove(id) index.remove(0); Add custom tokenizer A tokenizer split words/terms into components or partials. Define a private custom tokenizer during creation/initialization: var index = new FlexSearch({ tokenize: function(str){ return str.split(/\\s-\\//g); } }); The tokenizer function gets a string as a parameter and has to return an array of strings representing a word or term. In some languages every char is a term and also not separated via whitespaces. Add language-specific stemmer and/or filter Stemmer: several linguistic mutations of the same word (e.g. \"run\" and \"running\") Filter: a blacklist of words to be filtered out from indexing at all (e.g. \"and\", \"to\" or \"be\") Assign a private custom stemmer or filter during creation/initialization: var index = new FlexSearch({ stemmer: { // object {key: replacement} \"ational\": \"ate\", \"tional\": \"tion\", \"enci\": \"ence\", \"ing\": \"\" }, filter: [ // array blacklist \"in\", \"into\", \"is\", \"isn't\", \"it\", \"it's\" ] }); Using a custom filter, e.g.: var index = new FlexSearch({ filter: function(value){ // just add values with length > 1 to the index return value.length > 1; } }); Or assign stemmer/filters globally to a language: Stemmer are passed as a object (key-value-pair), filter as an array. FlexSearch.registerLanguage(\"us\", { stemmer: { /* ... */ }, filter: [ /* ... */ ] }); Or use some pre-defined stemmer or filter of your preferred languages: <html> <head> <script src=\"js/flexsearch.bundle.js\"></script> <script src=\"js/lang/en.min.js\"></script> <script src=\"js/lang/de.min.js\"></script> </head> ... Now you can assign built-in stemmer during creation/initialization: var index_en = new FlexSearch.Index({ language: \"en\" }); var index_de = new FlexSearch.Index({ language: \"de\" }); In Node.js all built-in language packs files are available: const { Index } = require(\"flexsearch\"); var index_en = new Index({ language: \"en\" }); Right-To-Left Support Set the tokenizer at least to \"reverse\" or \"full\" when using RTL. Just set the field \"rtl\" to true and use a compatible tokenizer: var index = new Index({ encode: str => str.toLowerCase().split(/[^a-z]+/), tokenize: \"reverse\", rtl: true }); CJK Word Break (Chinese, Japanese, Korean) Set a custom tokenizer which fits your needs, e.g.: var index = FlexSearch.create({ encode: str => str.replace(/[\\x00-\\x7F]/g, \"\").split(\"\") }); You can also pass a custom encoder function to apply some linguistic transformations. index.add(0, \"一个单词\"); var results = index.search(\"单词\"); Index Documents (Field-Search) The Document Descriptor Assuming our document has a data structure like this: { \"id\": 0, \"content\": \"some text\" } Old syntax FlexSearch v0.6.3 (not supported anymore!): const index = new Document({ doc: { id: \"id\", field: [\"content\"] } }); The document descriptor has slightly changed, there is no field branch anymore, instead just apply one level higher, so key becomes a main member of options. For the new syntax the field \"doc\" was renamed to document and the field \"field\" was renamed to index: const index = new Document({ document: { id: \"id\", index: [\"content\"] } }); index.add({ id: 0, content: \"some text\" }); The field id describes where the ID or unique key lives inside your documents. The default key gets the value id by default when not passed, so you can shorten the example from above to: const index = new Document({ document: { index: [\"content\"] } }); The member index has a list of fields which you want to be indexed from your documents. When just selecting one field, then you can pass a string. When also using default key id then this shortens to just: const index = new Document({ document: \"content\" }); index.add({ id: 0, content: \"some text\" }); Assuming you have several fields, you can add multiple fields to the index: var docs = [{ id: 0, title: \"Title A\", content: \"Body A\" },{ id: 1, title: \"Title B\", content: \"Body B\" }]; const index = new Document({ id: \"id\", index: [\"title\", \"content\"] }); You can pass custom options for each field: const index = new Document({ id: \"id\", index: [{ field: \"title\", tokenize: \"forward\", optimize: true, resolution: 9 },{ field: \"content\", tokenize: \"strict\", optimize: true, resolution: 5, minlength: 3, context: { depth: 1, resolution: 3 } }] }); Field options gets inherited when also global options was passed, e.g.: const index = new Document({ tokenize: \"strict\", optimize: true, resolution: 9, document: { id: \"id\", index:[{ field: \"title\", tokenize: \"forward\" },{ field: \"content\", minlength: 3, context: { depth: 1, resolution: 3 } }] } }); Note: The context options from the field \"content\" also gets inherited by the corresponding field options, whereas this field options was inherited by the global option. Nested Data Fields (Complex Objects) Assume the document array looks more complex (has nested branches etc.), e.g.: { \"record\": { \"id\": 0, \"title\": \"some title\", \"content\": { \"header\": \"some text\", \"footer\": \"some text\" } } } Then use the colon separated notation root:child:child to define hierarchy within the document descriptor: const index = new Document({ document: { id: \"record:id\", index: [ \"record:title\", \"record:content:header\", \"record:content:footer\" ] } }); Just add fields you want to query against. Do not add fields to the index, you just need in the result (but did not query against). For this purpose you can store documents independently of its index (read below). When you want to query through a field you have to pass the exact key of the field you have defined in the doc as a field name (with colon syntax): index.search(query, { index: [ \"record:title\", \"record:content:header\", \"record:content:footer\" ] }); Same as: index.search(query, [ \"record:title\", \"record:content:header\", \"record:content:footer\" ]); Using field-specific options: index.search([{ field: \"record:title\", query: \"some query\", limit: 100, suggest: true },{ field: \"record:title\", query: \"some other query\", limit: 100, suggest: true }]); You can perform a search through the same field with different queries. When passing field-specific options you need to provide the full configuration for each field. They get not inherited like the document descriptor. Complex Documents You need to follow 2 rules for your documents: The document cannot start with an Array at the root index. This will introduce sequential data and isn't supported yet. See below for a workaround for such data. [ // <-- not allowed as document start! { \"id\": 0, \"title\": \"title\" } ] The id can't be nested inside an array (also none of the parent fields can't be an array). This will introduce sequential data and isn't supported yet. See below for a workaround for such data. { \"records\": [ // <-- not allowed when ID or tag lives inside! { \"id\": 0, \"title\": \"title\" } ] } Here an example for a supported complex document: { \"meta\": { \"tag\": \"cat\", \"id\": 0 }, \"contents\": [ { \"body\": { \"title\": \"some title\", \"footer\": \"some text\" }, \"keywords\": [\"some\", \"key\", \"words\"] }, { \"body\": { \"title\": \"some title\", \"footer\": \"some text\" }, \"keywords\": [\"some\", \"key\", \"words\"] } ] } The corresponding document descriptor (when all fields should be indexed) looks like: const index = new Document({ document: { id: \"meta:id\", tag: \"meta:tag\", index: [ \"contents[]:body:title\", \"contents[]:body:footer\", \"contents[]:keywords\" ] } }); Again, when searching you have to use the same colon-separated-string from your field definition. index.search(query, { index: \"contents[]:body:title\" }); Not Supported Documents (Sequential Data) This example breaks both rules from above: [ // <-- not allowed as document start! { \"tag\": \"cat\", \"records\": [ // <-- not allowed when ID or tag lives inside! { \"id\": 0, \"body\": { \"title\": \"some title\", \"footer\": \"some text\" }, \"keywords\": [\"some\", \"key\", \"words\"] }, { \"id\": 1, \"body\": { \"title\": \"some title\", \"footer\": \"some text\" }, \"keywords\": [\"some\", \"key\", \"words\"] } ] } ] You need to apply some kind of structure normalization. A workaround to such a data structure looks like this: const index = new Document({ document: { id: \"record:id\", tag: \"tag\", index: [ \"record:body:title\", \"record:body:footer\", \"record:body:keywords\" ] } }); function add(sequential_data){ for(let x = 0, data; x < sequential_data.length; x++){ data = sequential_data[x]; for(let y = 0, record; y < data.records.length; y++){ record = data.records[y]; index.add({ id: record.id, tag: data.tag, record: record }); } } } // now just use add() helper method as usual: add([{ // sequential structured data // take the data example above }]); You can skip the first loop when your document data has just one index as the outer array. Add/Update/Remove Documents to/from the Index Just pass the document array (or a single object) to the index: index.add(docs); Update index with a single object or an array of objects: index.update({ data:{ id: 0, title: \"Foo\", body: { content: \"Bar\" } } }); Remove a single object or an array of objects from the index: index.remove(docs); When the id is known, you can also simply remove by (faster): index.remove(id); Join / Append Arrays On the complex example above, the field keywords is an array but here the markup did not have brackets like keywords[]. That will also detect the array but instead of appending each entry to a new context, the array will be joined into on large string and added to the index. The difference of both kinds of adding array contents is the relevance when searching. When adding each item of an array via append() to its own context by using the syntax field[], then the relevance of the last entry concurrent with the first entry. When you left the brackets in the notation, it will join the array to one whitespace-separated string. Here the first entry has the highest relevance, whereas the last entry has the lowest relevance. So assuming the keyword from the example above are pre-sorted by relevance to its popularity, then you want to keep this order (information of relevance). For this purpose do not add brackets to the notation. Otherwise, it would take the entries in a new scoring context (the old order is getting lost). Also you can left bracket notation for better performance and smaller memory footprint. Use it when you did not need the granularity of relevance by the entries. Field-Search Search through all fields: index.search(query); Search through a specific field: index.search(query, { index: \"title\" }); Search through a given set of fields: index.search(query, { index: [\"title\", \"content\"] }); Same as: index.search(query, [\"title\", \"content\"]); Pass custom modifiers and queries to each field: index.search([{ field: \"content\", query: \"some query\", limit: 100, suggest: true },{ field: \"content\", query: \"some other query\", limit: 100, suggest: true }]); You can perform a search through the same field with different queries. See all available field-search options. The Result Set Schema of the result-set: fields[] => { field, result[] => { document }} The first index is an array of fields the query was applied to. Each of this field has a record (object) with 2 properties \"field\" and \"result\". The \"result\" is also an array and includes the result for this specific field. The result could be an array of IDs or as enriched with stored document data. A non-enriched result set now looks like: [{ field: \"title\", result: [0, 1, 2] },{ field: \"content\", result: [3, 4, 5] }] An enriched result set now looks like: [{ field: \"title\", result: [ { id: 0, doc: { /* document */ }}, { id: 1, doc: { /* document */ }}, { id: 2, doc: { /* document */ }} ] },{ field: \"content\", result: [ { id: 3, doc: { /* document */ }}, { id: 4, doc: { /* document */ }}, { id: 5, doc: { /* document */ }} ] }] When using pluck instead of \"field\" you can explicitly select just one field and get back a flat representation: index.search(query, { pluck: \"title\", enrich: true }); [ { id: 0, doc: { /* document */ }}, { id: 1, doc: { /* document */ }}, { id: 2, doc: { /* document */ }} ] This result set is a replacement of \"boolean search\". Instead of applying your bool logic to a nested object, you can apply your logic by yourself on top of the result-set dynamically. This opens hugely capabilities on how you process the results. Therefore, the results from the fields aren't squashed into one result anymore. That keeps some important information, like the name of the field as well as the relevance of each field results which didn't get mixed anymore. A field search will apply a query with the boolean \"or\" logic by default. Each field has its own result to the given query. There is one situation where the bool property is being still supported. When you like to switch the default \"or\" logic from the field search into \"and\", e.g.: index.search(query, { index: [\"title\", \"content\"], bool: \"and\" }); You will just get results which contains the query in both fields. That's it. Tags Like the key for the ID just define the path to the tag: const index = new Document({ document: { id: \"id\", tag: \"tag\", index: \"content\" } }); index.add({ id: 0, tag: \"cat\", content: \"Some content ...\" }); Your data also can have multiple tags as an array: index.add({ id: 1, tag: [\"animal\", \"dog\"], content: \"Some content ...\" }); You can perform a tag-specific search by: index.search(query, { index: \"content\", tag: \"animal\" }); This just gives you result which was tagged with the given tag. Use multiple tags when searching: index.search(query, { index: \"content\", tag: [\"cat\", \"dog\"] }); This gives you result which are tagged with one of the given tag. Multiple tags will apply as the boolean \"or\" by default. It just needs one of the tags to be existing. This is another situation where the bool property is still supported. When you like to switch the default \"or\" logic from the tag search into \"and\", e.g.: index.search(query, { index: \"content\", tag: [\"dog\", \"animal\"], bool: \"and\" }); You will just get results which contains both tags (in this example there is just one records which has the tag \"dog\" and \"animal\"). Tag Search You can also fetch results from one or more tags when no query was passed: index.search({ tag: [\"cat\", \"dog\"] }); In this case the result-set looks like: [{ tag: \"cat\", result: [ /* all cats */ ] },{ tag: \"dog\", result: [ /* all dogs */ ] }] Limit & Offset By default, every query is limited to 100 entries. Unbounded queries leads into issues. You need to set the limit as an option to adjust the size. You can set the limit and the offset for each query: index.search(query, { limit: 20, offset: 100 }); You cannot pre-count the size of the result-set. That's a limit by the design of FlexSearch. When you really need a count of all results you are able to page through, then just assign a high enough limit and get back all results and apply your paging offset manually (this works also on server-side). FlexSearch is fast enough that this isn't an issue. Document Store Only a document index can have a store. You can use a document index instead of a flat index to get this functionality also when only storing ID-content-pairs. You can define independently which fields should be indexed and which fields should be stored. This way you can index fields which should not be included in the search result. Do not use a store when: 1. an array of IDs as the result is good enough, or 2. you already have the contents/documents stored elsewhere (outside the index). When the store attribute was set, you have to include all fields which should be stored explicitly (acts like a whitelist). When the store attribute was not set, the original document is stored as a fallback. This will add the whole original content to the store: const index = new Document({ document: { index: \"content\", store: true } }); index.add({ id: 0, content: \"some text\" }); Access documents from internal store You can get indexed documents from the store: var data = index.get(1); You can update/change store contents directly without changing the index by: index.set(1, data); To update the store and also update the index then just use index.update, index.add or index.append. When you perform a query, weather it is a document index or a flat index, then you will always get back an array of IDs. Optionally you can enrich the query results automatically with stored contents by: index.search(query, { enrich: true }); Your results look now like: [{ id: 0, doc: { /* content from store */ } },{ id: 1, doc: { /* content from store */ } }] Configure Storage (Recommended) This will add just specific fields from a document to the store (the ID isn't necessary to keep in store): const index = new Document({ document: { index: \"content\", store: [\"author\", \"email\"] } }); index.add(id, content); You can configure independently what should being indexed and what should being stored. It is highly recommended to make use of this whenever you can. Here a useful example of configuring doc and store: const index = new Document({ document: { index: \"content\", store: [\"author\", \"email\"] } }); index.add({ id: 0, author: \"Jon Doe\", email: \"john@mail.com\", content: \"Some content for the index ...\" }); You can query through the contents and will get back the stored values instead: index.search(\"some content\", { enrich: true }); Your results are now looking like: [{ field: \"content\", result: [{ id: 0, doc: { author: \"Jon Doe\", email: \"john@mail.com\", } }] }] Both field \"author\" and \"email\" are not indexed. Chaining Simply chain methods like: var index = FlexSearch.create() .addMatcher({'â': 'a'}) .add(0, 'foo') .add(1, 'bar'); index.remove(0).update(1, 'foo').add(2, 'foobar'); Enable Contextual Scoring Create an index and use the default context: var index = new FlexSearch({ tokenize: \"strict\", context: true }); Create an index and apply custom options for the context: var index = new FlexSearch({ tokenize: \"strict\", context: { resolution: 5, depth: 3, bidirectional: true } }); Only the tokenizer \"strict\" is actually supported by the contextual index. The contextual index requires additional amount of memory depending on depth. Auto-Balanced Cache (By Popularity) You need to initialize the cache and its limit during the creation of the index: const index = new Index({ cache: 100 }); const results = index.searchCache(query); A common scenario for using a cache is an autocomplete or instant search when typing. When passing a number as a limit the cache automatically balance stored entries related to their popularity. When just using \"true\" the cache is unbounded and perform actually 2-3 times faster (because the balancer do not have to run). Worker Parallelism (Browser + Node.js) The new worker model from v0.7.0 is divided into \"fields\" from the document (1 worker = 1 field index). This way the worker becomes able to solve tasks (subtasks) completely. The downside of this paradigm is they might not have been perfect balanced in storing contents (fields may have different length of contents). On the other hand there is no indication that balancing the storage gives any advantage (they all require the same amount in total). When using a document index, then just apply the option \"worker\": const index = new Document({ index: [\"tag\", \"name\", \"title\", \"text\"], worker: true }); index.add({ id: 1, tag: \"cat\", name: \"Tom\", title: \"some\", text: \"some\" }).add({ id: 2, tag: \"dog\", name: \"Ben\", title: \"title\", text: \"content\" }).add({ id: 3, tag: \"cat\", name: \"Max\", title: \"to\", text: \"to\" }).add({ id: 4, tag: \"dog\", name: \"Tim\", title: \"index\", text: \"index\" }); Worker 1: { 1: \"cat\", 2: \"dog\", 3: \"cat\", 4: \"dog\" } Worker 2: { 1: \"Tom\", 2: \"Ben\", 3: \"Max\", 4: \"Tim\" } Worker 3: { 1: \"some\", 2: \"title\", 3: \"to\", 4: \"index\" } Worker 4: { 1: \"some\", 2: \"content\", 3: \"to\", 4: \"index\" } When you perform a field search through all fields then this task is being balanced perfectly through all workers, which can solve their subtasks independently. Worker Index Above we have seen that documents will create worker automatically for each field. You can also create a WorkerIndex directly (same like using Index instead of Document). Use as ES6 module: import WorkerIndex from \"./worker/index.js\"; const index = new WorkerIndex(options); index.add(1, \"some\") .add(2, \"content\") .add(3, \"to\") .add(4, \"index\"); Or when bundled version was used instead: var index = new FlexSearch.Worker(options); index.add(1, \"some\") .add(2, \"content\") .add(3, \"to\") .add(4, \"index\"); Such a WorkerIndex works pretty much the same as a created instance of Index. A WorkerIndex only support the async variant of all methods. That means when you call index.search() on a WorkerIndex this will perform also in async the same way as index.searchAsync() will do. Worker Threads (Node.js) The worker model for Node.js is based on \"worker threads\" and works exactly the same way: const { Document } = require(\"flexsearch\"); const index = new Document({ index: [\"tag\", \"name\", \"title\", \"text\"], worker: true }); Or create a single worker instance for a non-document index: const { Worker } = require(\"flexsearch\"); const index = new Worker({ options }); The Worker Async Model (Best Practices) A worker will always perform as async. On a query method call you always should handle the returned promise (e.g. use await) or pass a callback function as the last parameter. const index = new Document({ index: [\"tag\", \"name\", \"title\", \"text\"], worker: true }); All requests and sub-tasks will run in parallel (prioritize \"all tasks completed\"): index.searchAsync(query, callback); index.searchAsync(query, callback); index.searchAsync(query, callback); Also (prioritize \"all tasks completed\"): index.searchAsync(query).then(callback); index.searchAsync(query).then(callback); index.searchAsync(query).then(callback); Or when you have just one callback when all requests are done, simply use Promise.all() which also prioritize \"all tasks completed\": Promise.all([ index.searchAsync(query), index.searchAsync(query), index.searchAsync(query) ]).then(callback); Inside the callback of Promise.all() you will also get an array of results as the first parameter respectively for each query you put into. When using await you can prioritize the order (prioritize \"first task completed\") and solve requests one by one and just process the sub-tasks in parallel: await index.searchAsync(query); await index.searchAsync(query); await index.searchAsync(query); Same for index.add(), index.append(), index.remove() or index.update(). Here there is a special case which isn't disabled by the library, but you need to keep in mind when using Workers. When you call the \"synced\" version on a worker index: index.add(doc); index.add(doc); index.add(doc); // contents aren't indexed yet, // they just queued on the message channel Of course, you can do that but keep in mind that the main thread does not have an additional queue for distributed worker tasks. Running these in a long loop fires content massively to the message channel via worker.postMessage() internally. Luckily the browser and Node.js will handle such incoming tasks for you automatically (as long enough free RAM is available). When using the \"synced\" version on a worker index, the content isn't indexed one line below, because all calls are treated as async by default. When adding/updating/removing large bulks of content to the index (or high frequency), it is recommended to use the async version along with async/await to keep a low memory footprint during long processes. Export / Import Export The export has slightly changed. The export now consist of several smaller parts, instead of just one large bulk. You need to pass a callback function which has 2 arguments \"key\" and \"data\". This callback function is called by each part, e.g.: index.export(function(key, data){ // you need to store both the key and the data! // e.g. use the key for the filename and save your data localStorage.setItem(key, data); }); Exporting data to the localStorage isn't really a good practice, but if size is not a concern than use it if you like. The export primarily exists for the usage in Node.js or to store indexes you want to delegate from a server to the client. The size of the export corresponds to the memory consumption of the library. To reduce export size you have to use a configuration which has less memory footprint (use the table at the bottom to get information about configs and its memory allocation). When your save routine runs asynchronously you have to return a promise: index.export(function(key, data){ return new Promise(function(resolve){ // do the saving as async resolve(); }); }); You cannot export the additional table for the \"fastupdate\" feature. These table exists of references and when stored they fully get serialized and becomes too large. The lib will handle these automatically for you. When importing data, the index automatically disables \"fastupdate\". Import Before you can import data, you need to create your index first. For document indexes provide the same document descriptor you used when export the data. This configuration isn't stored in the export. var index = new Index({ ... }); To import the data just pass a key and data: index.import(key, localStorage.getItem(key)); You need to import every key! Otherwise, your index does not work. You need to store the keys from the export and use this keys for the import (the order of the keys can differ). This is just for demonstration and is not recommended, because you might have other keys in your localStorage which aren't supported as an import: var keys = Object.keys(localStorage); for(let i = 0, key; i < keys.length; i++){ key = keys[i]; index.import(key, localStorage.getItem(key)); } Languages Language-specific definitions are being divided into two groups: Charset encode, type: function(string):string[] rtl, type: boolean Language matcher, type: {string: string} stemmer, type: {string: string} filter, type: string[] The charset contains the encoding logic, the language contains stemmer, stopword filter and matchers. Multiple language definitions can use the same charset encoder. Also this separation let you manage different language definitions for special use cases (e.g. names, cities, dialects/slang, etc.). To fully describe a custom language on the fly you need to pass: const index = FlexSearch({ // mandatory: encode: (content) => [words], // optionally: rtl: false, stemmer: {}, matcher: {}, filter: [] }); When passing no parameter it uses the latin:default schema by default. Field Category Description encode charset The encoder function. Has to return an array of separated words (or an empty string). rtl charset A boolean property which indicates right-to-left encoding. filter language Filter are also known as \"stopwords\", they completely filter out words from being indexed. stemmer language Stemmer removes word endings and is a kind of \"partial normalization\". A word ending just matched when the word length is bigger than the matched partial. matcher language Matcher replaces all occurrences of a given string regardless of its position and is also a kind of \"partial normalization\". 1. Language Packs: ES6 Modules The most simple way to assign charset/language specific encoding via modules is: import charset from \"./dist/module/lang/latin/advanced.js\"; import lang from \"./dist/module/lang/en.js\"; const index = FlexSearch({ charset: charset, lang: lang }); Just import the default export by each module and assign them accordingly. The full qualified example from above is: import { encode, rtl } from \"./dist/module/lang/latin/advanced.js\"; import { stemmer, filter, matcher } from \"./dist/module/lang/en.js\"; const index = FlexSearch({ encode: encode, rtl: rtl, stemmer: stemmer, matcher: matcher, filter: filter }); The example above is the standard interface which is at least exported from each charset/language. You can also define the encoder directly and left all other options: import simple from \"./dist/module/lang/latin/simple.js\"; const index = FlexSearch({ encode: simple }); Available Latin Encoders default simple balance advanced extra You can assign a charset by passing the charset during initialization, e.g. charset: \"latin\" for the default charset encoder or charset: \"latin:soundex\" for a encoder variant. Dialect / Slang Language definitions (especially matchers) also could be used to normalize dialect and slang of a specific language. 2. Language Packs: ES5 (Language Packs) You need to make the charset and/or language definitions available by: All charset definitions are included in the flexsearch.bundle.js build by default, but no language-specific definitions are included You can load packages located in /dist/lang/ (files refers to languages, folders are charsets) You can make a custom build When loading language packs, make sure that the library was loaded before: <script src=\"dist/flexsearch.light.js\"></script> <script src=\"dist/lang/latin/default.min.js\"></script> <script src=\"dist/lang/en.min.js\"></script> When using the full \"bundle\" version the built-in latin encoders are already included and you just have to load the language file: <script src=\"dist/flexsearch.bundle.js\"></script> <script src=\"dist/lang/en.min.js\"></script> Because you loading packs as external packages (non-ES6-modules) you have to initialize them by shortcuts: const index = FlexSearch({ charset: \"latin:soundex\", lang: \"en\" }); Use the charset:variant notation to assign charset and its variants. When just passing the charset without a variant will automatically resolve as charset:default. You can also override existing definitions, e.g.: const index = FlexSearch({ charset: \"latin\", lang: \"en\", matcher: {} }); Passed definitions will not extend default definitions, they will replace them. When you like to extend a definition just create a new language file and put in all the logic. Encoder Variants It is pretty straight forward when using an encoder variant: <script src=\"dist/flexsearch.light.js\"></script> <script src=\"dist/lang/latin/advanced.min.js\"></script> <script src=\"dist/lang/latin/extra.min.js\"></script> <script src=\"dist/lang/en.min.js\"></script> When using the full \"bundle\" version the built-in latin encoders are already included and you just have to load the language file: <script src=\"dist/flexsearch.bundle.js\"></script> <script src=\"dist/lang/en.min.js\"></script> const index_advanced = FlexSearch({ charset: \"latin:advanced\" }); const index_extra = FlexSearch({ charset: \"latin:extra\" }); Partial Tokenizer In FlexSearch you can't provide your own partial tokenizer, because it is a direct dependency to the core unit. The built-in tokenizer of FlexSearch splits each word into fragments by different patterns: strict (supports contextual index) forward reverse (including forward) full Language Processing Pipeline This is the default pipeline provided by FlexSearch: Custom Pipeline At first take a look into the default pipeline in src/common.js. It is very simple and straight forward. The pipeline will process as some sort of inversion of control, the final encoder implementation has to handle charset and also language specific transformations. This workaround has left over from many tests. Inject the default pipeline by e.g.: this.pipeline( /* string: */ str.toLowerCase(), /* normalize: */ false, /* split: */ split, /* collapse: */ false ); Use the pipeline schema from above to understand the iteration and the difference of pre-encoding and post-encoding. Stemmer and matchers needs to be applied after charset normalization but before language transformations, filters also. Here is a good example of extending pipelines: src/lang/latin/extra.js → src/lang/latin/advanced.js → src/lang/latin/simple.js. How to contribute? Search for your language in src/lang/, if it exists you can extend or provide variants (like dialect/slang). If the language doesn't exist create a new file and check if any of the existing charsets (e.g. latin) fits to your language. When no charset exist, you need to provide a charset as a base for the language. A new charset should provide at least: encode A function which normalize the charset of a passed text content (remove special chars, lingual transformations, etc.) and returns an array of separated words. Also stemmer, matcher or stopword filter needs to be applied here. When the language has no words make sure to provide something similar, e.g. each chinese sign could also be a \"word\". Don't return the whole text content without split. rtl A boolean flag which indicates right-to-left encoding Basically the charset needs just to provide an encoder function along with an indicator for right-to-left encoding: export function encode(str){ return [str] } export const rtl = false; Encoder Matching Comparison Reference String: \"Björn-Phillipp Mayer\" Query default simple advanced extra björn yes yes yes yes björ yes yes yes yes bjorn no yes yes yes bjoern no no yes yes philipp no no yes yes filip no no yes yes björnphillip no yes yes yes meier no no yes yes björn meier no no yes yes meier fhilip no no yes yes byorn mair no no no yes (false positives) no no no yes Memory Allocation The book \"Gulliver's Travels Swift Jonathan 1726\" was fully indexed for the examples below. The most memory-optimized meaningful setting will allocate just 1.2 Mb for the whole book indexed! This is probably the most tiny memory footprint you will get from a search library. import { encode } from \"./lang/latin/extra.js\"; index = new Index({ encode: encode, tokenize: \"strict\", optimize: true, resolution: 1, minlength: 3, fastupdate: false, context: false }); Memory Consumption The book \"Gulliver's Travels\" (Swift Jonathan 1726) was completely indexed for this test: Compare Impact of Memory Allocation by default a lexical index is very small: depth: 0, bidirectional: 0, resolution: 3, minlength: 0 => 2.1 Mb a higher resolution will increase the memory allocation: depth: 0, bidirectional: 0, resolution: 9, minlength: 0 => 2.9 Mb using the contextual index will increase the memory allocation: depth: 1, bidirectional: 0, resolution: 9, minlength: 0 => 12.5 Mb a higher contextual depth will increase the memory allocation: depth: 2, bidirectional: 0, resolution: 9, minlength: 0 => 21.5 Mb a higher minlength will decrease memory allocation: depth: 2, bidirectional: 0, resolution: 9, minlength: 3 => 19.0 Mb using bidirectional will decrease memory allocation: depth: 2, bidirectional: 1, resolution: 9, minlength: 3 => 17.9 Mb enable the option \"fastupdate\" will increase memory allocation: depth: 2, bidirectional: 1, resolution: 9, minlength: 3 => 6.3 Mb Full Comparison Table Every search library is constantly in competition with these 4 properties: Memory Allocation Performance Matching Capabilities Relevance Order (Scoring) FlexSearch provides you many parameters you can use to adjust the optimal balance for your specific use-case. Modifier Memory Impact * Performance Impact ** Matching Impact ** Scoring Impact ** resolution +1 (per level) +1 (per level) 0 +2 (per level) depth +4 (per level) -1 (per level) -10 + depth +10 minlength -2 (per level) +2 (per level) -3 (per level) +2 (per level) bidirectional -2 0 +3 -1 fastupdate +1 +10 (update, remove) 0 0 optimize: true -7 -1 0 -3 encoder: \"icase\" 0 0 0 0 encoder: \"simple\" -2 -1 +2 0 encoder: \"advanced\" -3 -2 +4 0 encoder: \"extra\" -5 -5 +6 0 encoder: \"soundex\" -6 -2 +8 0 tokenize: \"strict\" 0 0 0 0 tokenize: \"forward\" +3 -2 +5 0 tokenize: \"reverse\" +5 -4 +7 0 tokenize: \"full\" +8 -5 +10 0 document index +3 (per field) -1 (per field) 0 0 document tags +1 (per tag) -1 (per tag) 0 0 store: true +5 (per document) 0 0 0 store: [fields] +1 (per field) 0 0 0 cache: true +10 +10 0 0 cache: 100 +1 +9 0 0 type of ids: number 0 0 0 0 type of ids: string +3 -3 0 0 * range from -10 to 10, lower is better (-10 => big decrease, 0 => unchanged, +10 => big increase) ** range from -10 to 10, higher is better Presets memory (primary optimize for memory) performance (primary optimize for performance) match (primary optimize for matching) score (primary optimize for scoring) default (the default balanced profile) These profiles are covering standard use cases. It is recommended to apply custom configuration instead of using profiles to get the best out for your situation. Every profile could be optimized further to its specific task, e.g. extreme performance optimized configuration or extreme memory and so on. You can pass a preset during creation/initialization of the index. Best Practices Use numeric IDs It is recommended to use numeric id values as reference when adding content to the index. The byte length of passed ids influences the memory consumption significantly. If this is not possible you should consider to use a index table and map the ids with indexes, this becomes important especially when using contextual indexes on a large amount of content. Split Complexity Whenever you can, try to divide content by categories and add them to its own index, e.g.: var action = new FlexSearch(); var adventure = new FlexSearch(); var comedy = new FlexSearch(); This way you can also provide different settings for each category. This is actually the fastest way to perform a fuzzy search. To make this workaround more extendable you can use a short helper: var index = {}; function add(id, cat, content){ (index[cat] || ( index[cat] = new FlexSearch )).add(id, content); } function search(cat, query){ return index[cat] ? index[cat].search(query) : []; } Add content to the index: add(1, \"action\", \"Movie Title\"); add(2, \"adventure\", \"Movie Title\"); add(3, \"comedy\", \"Movie Title\"); Perform queries: var results = search(\"action\", \"movie title\"); // --> [1] Split indexes by categories improves performance significantly. Copyright 2018-2021 Nextapps GmbH Released under the Apache 2.0 License"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welkom bij de Monta documentatie",
    "keywords": "Welkom bij de Monta documentatie Algemeen Beschrijving van de algemene werking en mogelijkheden van het systeem. Algemeen Operations Beschrijving van de operaties van het systeem. Operaties Updates Beschrijving van de updates van het systeem. Updates Probleemoplossing Beschrijving van de probleemoplossing van het systeem. Troubleshoot"
  },
  "node_modules/flexsearch/CHANGELOG.html": {
    "href": "node_modules/flexsearch/CHANGELOG.html",
    "title": "Changelog",
    "keywords": "Changelog v0.7.0 Bidirectional Context (the order of words can now vary, does not increase memory when using bidirectional context) New memory-friendly strategy for indexes (switchable, saves up to 50% of memory for each index, slightly decrease performance) Better scoring calculation (one of the biggest concerns of the old implementation was that the order of arrays processed in the intersection has affected the order of relevance in the final result) Fix resolution (the resolution in the old implementation was not fully stretched through the whole range in some cases) Skip words (optionally, automatically skip words from the context chain which are too short) Hugely improves performance of long queries (up to 450x faster!) and also memory allocation (up to 250x less memory) New fast-update strategy (optionally, hugely improves performance of all updates and removals of indexed contents up to 2850x) Improved auto-balanced cache (keep and expire cache by popularity) Append contents to already existing entries (already indexed documents or contents) New method \"contain\" to check if an ID was already indexed Access documents directly from internal store (read/write) Suggestions are hugely improved, falls back from context search all the way down to single term match Document descriptor has now array support (optionally adds array entries via the new append under the hood to provide a unique relevance context for each entry) Document storage handler gets improved Results from document index now grouped by field (this is one of the few bigger breaking changes which needs migrations of your old code) Boolean search has a new concept (use in combination of the new result structure) Node.js Worker Threads Improved default latin encoders New parallelization model and workload distribution Improved Export/Import Tag Search Offset pagination Enhanced Field Search Improved sorting by relevance (score) Added Context Scoring (context index has its own resolution) Enhanced charset normalization Improved bundler (support for inline WebWorker) These features have been removed: Where-Clause Index Information index.info() Paging Cursor (was replaced by offset) Migration Quick Overview The \"async\" options was removed, instead you can call each method in its async version, e.g. index.addAsync or index.searchAsync. Define document fields as object keys is not longer supported due to the unification of all option payloads. A full configuration example for a context-based index: var index = new Index({ tokenize: \"strict\", resolution: 9, minlength: 3, optimize: true, fastupdate: true, cache: 100, context: { depth: 1, resolution: 3, bidirectional: true } }); The resolution could be set also for the contextual index. A full configuration example for a document based index: const index = new Document({ tokenize: \"forward\", optimize: true, resolution: 9, cache: 100, worker: true, document: { id: \"id\", tag: \"tag\", store: [ \"title\", \"content\" ], index: [{ field: \"title\", tokenize: \"forward\", optimize: true, resolution: 9 },{ field: \"content\", tokenize: \"strict\", optimize: true, resolution: 9, minlength: 3, context: { depth: 1, resolution: 3 } }] } }); A full configuration example for a document search: index.search({ enrich: true, bool: \"and\", tag: [\"cat\", \"dog\"], index: [{ field: \"title\", query: \"some query\", limit: 100, suggest: true },{ field: \"content\", query: \"same or other query\", limit: 100, suggest: true }] }); Where Clause Replacement Old Syntax: const result = index.where({ cat: \"comedy\", year: \"2018\" }); Equivalent Syntax (0.7.x): const data = Object.values(index.store); The line above retrieves data from the document store (just useful when not already available in your runtime). const result = data.filter(function(item){ return item.cat === \"comedy\" && item.year === \"2018\"; }); Also considering using the Tag-Search feature, which partially replaces the Where-Clause with a huge performance boost. v0.6.0 Pagination v0.5.3 Logical Operator v0.5.2 Intersect Partial Results v0.5.1 Customizable Scoring Resolution v0.5.0 Where / Find Documents Document Tags Custom Sort v0.4.0 Index Documents (Field-Search) v0.3.6 Right-To-Left Support CJK Word Splitting Support v0.3.5 Promise Support v0.3.4 Export / Import Indexes (Serialize) v0.3.0 Profiler Support"
  },
  "node_modules/flexsearch/README.html": {
    "href": "node_modules/flexsearch/README.html",
    "title": "",
    "keywords": "Web's fastest and most memory-flexible full-text search library with zero dependencies. Basic Start • API Reference • Document Indexes • Using Worker • Changelog FlexSearch v0.7.0 The new version is finally available. FlexSearch v0.7.0 is a modern re-implementation and was newly developed from the ground up. The result is an improvement in every single aspect and covers tons of enhancements and improvements which was collected over the last 3 years. This new version has a good compatibility with the old generation, but it might require some migrations steps in your code. Read the documentation of new features and changes: https://github.com/nextapps-de/flexsearch/blob/master/doc/0.7.0.md Read the documentation of new language encoding features: https://github.com/nextapps-de/flexsearch/blob/master/doc/0.7.0-lang.md When it comes to raw search speed FlexSearch outperforms every single searching library out there and also provides flexible search capabilities like multi-field search, phonetic transformations or partial matching. Depending on the used options it also provides the most memory-efficient index. FlexSearch introduce a new scoring algorithm called \"contextual index\" based on a pre-scored lexical dictionary architecture which actually performs queries up to 1,000,000 times faster compared to other libraries. FlexSearch also provides you a non-blocking asynchronous processing model as well as web workers to perform any updates or queries on the index in parallel through dedicated balanced threads. Supported Platforms: Browser Node.js Library Comparison \"Gulliver's Travels\": Performance Benchmark Scoring Benchmark Memory Consumption Plugins (extern projects): https://github.com/angeloashmore/react-use-flexsearch https://www.gatsbyjs.org/packages/gatsby-plugin-flexsearch/ Get Latest Stable Build (Recommended) Build File CDN flexsearch.bundle.js Download https://rawcdn.githack.com/nextapps-de/flexsearch/0.7.31/dist/flexsearch.bundle.js flexsearch.light.js Download https://rawcdn.githack.com/nextapps-de/flexsearch/0.7.31/dist/flexsearch.light.js flexsearch.compact.js Download https://rawcdn.githack.com/nextapps-de/flexsearch/0.7.31/dist/flexsearch.compact.js flexsearch.es5.js * Download https://rawcdn.githack.com/nextapps-de/flexsearch/0.7.31/dist/flexsearch.es5.js ES6 Modules Download The /dist/module/ folder of this Github repository * The bundle \"flexsearch.es5.js\" includes polyfills for EcmaScript 5 Support. Get Latest (NPM) npm install flexsearch Get Latest Nightly (Do not use for production!) Just exchange the version number from the URLs above with \"master\", e.g.: \"/flexsearch/0.7.31/dist/\" into \"/flexsearch/master/dist\". Compare Web-Bundles The Node.js package includes all features from flexsearch.bundle.js. Feature flexsearch.bundle.js flexsearch.compact.js flexsearch.light.js Presets ✓ ✓ - Async Search ✓ ✓ - Workers (Web + Node.js) ✓ - - Contextual Indexes ✓ ✓ ✓ Index Documents (Field-Search) ✓ ✓ - Document Store ✓ ✓ - Partial Matching ✓ ✓ ✓ Relevance Scoring ✓ ✓ ✓ Auto-Balanced Cache by Popularity ✓ - - Tags ✓ - - Suggestions ✓ ✓ - Phonetic Matching ✓ ✓ - Customizable Charset/Language (Matcher, Encoder, Tokenizer, Stemmer, Filter, Split, RTL) ✓ ✓ ✓ Export / Import Indexes ✓ - - File Size (gzip) 6.8 kb 5.3 kb 2.9 kb Performance Benchmark (Ranking) Run Comparison: Performance Benchmark \"Gulliver's Travels\" Operation per seconds, higher is better, except the test \"Memory\" on which lower is better. Rank Library Memory Query (Single Term) Query (Multi Term) Query (Long) Query (Dupes) Query (Not Found) 1 FlexSearch 17 7084129 1586856 511585 2017142 3202006 2 JSii 27 6564 158149 61290 95098 534109 3 Wade 424 20471 78780 16693 225824 213754 4 JS Search 193 8221 64034 10377 95830 167605 5 Elasticlunr.js 646 5412 7573 2865 23786 13982 6 BulkSearch 1021 3069 3141 3333 3265 21825569 7 MiniSearch 24348 4406 10945 72 39989 17624 8 bm25 15719 1429 789 366 884 1823 9 Lunr.js 2219 255 271 272 266 267 10 FuzzySearch 157373 53 38 15 32 43 11 Fuse 7641904 6 2 1 2 3 Contextual Search Note: This feature is disabled by default because of its extended memory usage. Read here get more information about and how to enable. FlexSearch introduce a new scoring mechanism called Contextual Search which was invented by Thomas Wilkerling, the author of this library. A Contextual Search incredibly boost up queries to a complete new level but also requires some additional memory (depending on depth). The basic idea of this concept is to limit relevance by its context instead of calculating relevance through the whole distance of its corresponding document. This way contextual search also improves the results of relevance-based queries on a large amount of text data. Load Library There are 3 types of indexes: Index is a flat high performance index which stores id-content-pairs. Worker / WorkerIndex is also a flat index which stores id-content-pairs but runs in background as a dedicated worker thread. Document is multi-field index which can store complex JSON documents (could also exist of worker indexes). The most of you probably need just one of them according to your scenario. ES6 Modules (Browser): import Index from \"./index.js\"; import Document from \"./document.js\"; import WorkerIndex from \"./worker/index.js\"; const index = new Index(options); const document = new Document(options); const worker = new WorkerIndex(options); Bundle (Browser) <html> <head> <script src=\"js/flexsearch.bundle.js\"></script> </head> ... Or via CDN: <script src=\"https://cdn.jsdelivr.net/gh/nextapps-de/flexsearch@0.7.31/dist/flexsearch.bundle.js\"></script> AMD: var FlexSearch = require(\"./flexsearch.js\"); Load one of the builds from the folder dist within your html as a script and use as follows: var index = new FlexSearch.Index(options); var document = new FlexSearch.Document(options); var worker = new FlexSearch.Worker(options); Node.js npm install flexsearch In your code include as follows: const { Index, Document, Worker } = require(\"flexsearch\"); const index = new Index(options); const document = new Document(options); const worker = new Worker(options); Basic Usage and Variants index.add(id, text); index.search(text); index.search(text, limit); index.search(text, options); index.search(text, limit, options); index.search(options); document.add(doc); document.add(id, doc); document.search(text); document.search(text, limit); document.search(text, options); document.search(text, limit, options); document.search(options); worker.add(id, text); worker.search(text); worker.search(text, limit); worker.search(text, options); worker.search(text, limit, options); worker.search(text, limit, options, callback); worker.search(options); The worker inherits from type Index and does not inherit from type Document. Therefore, a WorkerIndex basically works like a standard FlexSearch Index. Worker-Support in documents needs to be enabled by just passing the appropriate option during creation { worker: true }. Every method called on a Worker index is treated as async. You will get back a Promise or you can provide a callback function as the last parameter alternatively. API Overview Global methods: FlexSearch.registerCharset(name, charset) FlexSearch.registerLanguage(name, language) Index methods: Index.add(id, string) * Index.append(id, string) * Index.update(id, string) * Index.remove(id) * Index.search(string, <limit>, <options>) * Index.search(options) * async Index.export(handler) async Index.import(key, data) WorkerIndex methods: async Index.add(id, string) async Index.append(id, string) async Index.update(id, string) async Index.remove(id) async Index.search(string, <limit>, <options>) async Index.search(options) async Index.export(handler) (WIP) async Index.import(key, data) (WIP) Document methods: Document.add(<id>, document) * Document.append(<id>, document) * Document.update(<id>, document) * Document.remove(id || document) * Document.search(string, <limit>, <options>) * Document.search(options) * async Document.export(handler) async Document.import(key, data) * For each of those methods there exist an asynchronous equivalent: Async Version: async .addAsync( ... , <callback>) async .appendAsync( ... , <callback>) async .updateAsync( ... , <callback>) async .removeAsync( ... , <callback>) async .searchAsync( ... , <callback>) Async methods will return a Promise, alternatively you can pass a callback function as the last parameter. Methods export and also import are always async as well as every method you call on a Worker-based Index. Options FlexSearch is highly customizable. Make use of the right options can really improve your results as well as memory economy and query time. Index Options Option Values Description Default preset \"memory\" \"performance\" \"match\" \"score\" \"default\" The configuration profile as a shortcut or as a base for your custom settings. \"default\" tokenize \"strict\" \"forward\" \"reverse\" \"full\" The indexing mode (tokenizer). Choose one of the built-ins or pass a custom tokenizer function. \"strict\" cache Boolean Number Enable/Disable and/or set capacity of cached entries. When passing a number as a limit the cache automatically balance stored entries related to their popularity. Note: When just using \"true\" the cache has no limits and growth unbounded. false resolution Number Sets the scoring resolution (default: 9). 9 context Boolean Context Options Enable/Disable contextual indexing. When passing \"true\" as value it will take the default values for the context. false optimize Boolean When enabled it uses a memory-optimized stack flow for the index. true boost function(arr, str, int) => float A custom boost function used when indexing contents to the index. The function has this signature: Function(words[], term, index) => Float. It has 3 parameters where you get an array of all words, the current term and the current index where the term is placed in the word array. You can apply your own calculation e.g. the occurrences of a term and return this factor (<1 means relevance is lowered, >1 means relevance is increased). Note: this feature is currently limited by using the tokenizer \"strict\" only. null Language-specific Options and Encoding: charset Charset Payload String (key) Provide a custom charset payload or pass one of the keys of built-in charsets. \"latin\" language Language Payload String (key) Provide a custom language payload or pass in language shorthand flag (ISO-3166) of built-in languages. null encode false \"default\" \"simple\" \"balance\" \"advanced\" \"extra\" function(str) => [words] The encoding type. Choose one of the built-ins or pass a custom encoding function. \"default\" stemmer false String Function false filter false String Function false matcher false String Function false Additional Options for Document Indexes: worker Boolean Enable/Disable and set count of running worker threads. false document Document Descriptor Includes definitions for the document index and storage. Context Options Option Values Description Default resolution Number Sets the scoring resolution for the context (default: 1). 1 depth false Number Enable/Disable contextual indexing and also sets contextual distance of relevance. Depth is the maximum number of words/tokens away a term to be considered as relevant. 1 bidirectional Boolean Sets the scoring resolution (default: 9). true Document Options Option Values Description Default id String \"id\"\" tag false String \"tag\" index String Array<String> Array<Object> store Boolean String Array<String> false Charset Options Option Values Description Default split false RegExp String The rule to split words when using non-custom tokenizer (built-ins e.g. \"forward\"). Use a string/char or use a regular expression (default: /\\W+/). /[\\W_]+/ rtl Boolean Enables Right-To-Left encoding. false encode function(str) => [words] The custom encoding function. /lang/latin/default.js Language Options Option Values Description stemmer false String Function Disable or pass in language shorthand flag (ISO-3166) or a custom object. filter false String Function Disable or pass in language shorthand flag (ISO-3166) or a custom array. matcher false String Function Disable or pass in language shorthand flag (ISO-3166) or a custom array. Search Options Option Values Description Default limit number Sets the limit of results. 100 offset number Apply offset (skip items). 0 suggest Boolean Enables suggestions in results. false Document Search Options Additionally, to the Index search options above. Option Values Description Default index String Array<String> Array<Object> Sets the document fields which should be searched. When no field is set, all fields will be searched. Custom options per field are also supported. tag String Array<String> Sets the document fields which should be searched. When no field is set, all fields will be searched. Custom options per field are also supported. false enrich Boolean Enrich IDs from the results with the corresponding documents. false bool \"and\" \"or\" Sets the used logical operator when searching through multiple fields or tags. \"or\" Tokenizer (Prefix Search) Tokenizer affects the required memory also as query time and flexibility of partial matches. Try to choose the most upper of these tokenizer which fits your needs: Option Description Example Memory Factor (n = length of word) \"strict\" index whole words foobar * 1 \"forward\" incrementally index words in forward direction foobar foobar * n \"reverse\" incrementally index words in both directions foobar foobar * 2n - 1 \"full\" index every possible combination foobar foobar * n * (n - 1) Encoders Encoding affects the required memory also as query time and phonetic matches. Try to choose the most upper of these encoders which fits your needs, or pass in a custom encoder: Option Description False-Positives Compression false Turn off encoding no 0% \"default\" Case in-sensitive encoding no 0% \"simple\" Case in-sensitive encoding Charset normalizations no ~ 3% \"balance\" Case in-sensitive encoding Charset normalizations Literal transformations no ~ 30% \"advanced\" Case in-sensitive encoding Charset normalizations Literal transformations Phonetic normalizations no ~ 40% \"extra\" Case in-sensitive encoding Charset normalizations Literal transformations Phonetic normalizations Soundex transformations yes ~ 65% function() Pass custom encoding via function(string):[words] Usage Create a new index var index = new Index(); Create a new index and choosing one of the presets: var index = new Index(\"performance\"); Create a new index with custom options: var index = new Index({ charset: \"latin:extra\", tokenize: \"reverse\", resolution: 9 }); Create a new index and extend a preset with custom options: var index = new FlexSearch({ preset: \"memory\", tokenize: \"forward\", resolution: 5 }); See all available custom options. Add text item to an index Every content which should be added to the index needs an ID. When your content has no ID, then you need to create one by passing an index or count or something else as an ID (a value from type number is highly recommended). Those IDs are unique references to a given content. This is important when you update or adding over content through existing IDs. When referencing is not a concern, you can simply use something simple like count++. Index.add(id, string) index.add(0, \"John Doe\"); Search items Index.search(string | options, <limit>, <options>) index.search(\"John\"); Limit the result: index.search(\"John\", 10); Check existence of already indexed IDs You can check if an ID was already indexed by: if(index.contain(1)){ console.log(\"ID is already in index\"); } Async You can call each method in its async version, e.g. index.addAsync or index.searchAsync. You can assign callbacks to each async function: index.addAsync(id, content, function(){ console.log(\"Task Done\"); }); index.searchAsync(query, function(result){ console.log(\"Results: \", result); }); Or do not pass a callback function and getting back a Promise instead: index.addAsync(id, content).then(function(){ console.log(\"Task Done\"); }); index.searchAsync(query).then(function(result){ console.log(\"Results: \", result); }); Or use async and await: async function add(){ await index.addAsync(id, content); console.log(\"Task Done\"); } async function search(){ const results = await index.searchAsync(query); console.log(\"Results: \", result); } Append Contents You can append contents to an existing index like: index.append(id, content); This will not overwrite the old indexed contents as it will do when perform index.update(id, content). Keep in mind that index.add(id, content) will also perform \"update\" under the hood when the id was already being indexed. Appended contents will have their own context and also their own full resolution. Therefore, the relevance isn't being stacked but gets its own context. Let us take this example: index.add(0, \"some index\"); index.append(0, \"some appended content\"); index.add(1, \"some text\"); index.append(1, \"index appended content\"); When you query index.search(\"index\") then you will get index id 1 as the first entry in the result, because the context starts from zero for the appended data (isn't stacked to the old context) and here \"index\" is the first term. If you didn't want this behavior than just use the standard index.add(id, content) and provide the full length of content. Update item from an index Index.update(id, string) index.update(0, \"Max Miller\"); Remove item from an index Index.remove(id) index.remove(0); Add custom tokenizer A tokenizer split words/terms into components or partials. Define a private custom tokenizer during creation/initialization: var index = new FlexSearch({ tokenize: function(str){ return str.split(/\\s-\\//g); } }); The tokenizer function gets a string as a parameter and has to return an array of strings representing a word or term. In some languages every char is a term and also not separated via whitespaces. Add language-specific stemmer and/or filter Stemmer: several linguistic mutations of the same word (e.g. \"run\" and \"running\") Filter: a blacklist of words to be filtered out from indexing at all (e.g. \"and\", \"to\" or \"be\") Assign a private custom stemmer or filter during creation/initialization: var index = new FlexSearch({ stemmer: { // object {key: replacement} \"ational\": \"ate\", \"tional\": \"tion\", \"enci\": \"ence\", \"ing\": \"\" }, filter: [ // array blacklist \"in\", \"into\", \"is\", \"isn't\", \"it\", \"it's\" ] }); Using a custom filter, e.g.: var index = new FlexSearch({ filter: function(value){ // just add values with length > 1 to the index return value.length > 1; } }); Or assign stemmer/filters globally to a language: Stemmer are passed as a object (key-value-pair), filter as an array. FlexSearch.registerLanguage(\"us\", { stemmer: { /* ... */ }, filter: [ /* ... */ ] }); Or use some pre-defined stemmer or filter of your preferred languages: <html> <head> <script src=\"js/flexsearch.bundle.js\"></script> <script src=\"js/lang/en.min.js\"></script> <script src=\"js/lang/de.min.js\"></script> </head> ... Now you can assign built-in stemmer during creation/initialization: var index_en = new FlexSearch.Index({ language: \"en\" }); var index_de = new FlexSearch.Index({ language: \"de\" }); In Node.js all built-in language packs files are available: const { Index } = require(\"flexsearch\"); var index_en = new Index({ language: \"en\" }); Right-To-Left Support Set the tokenizer at least to \"reverse\" or \"full\" when using RTL. Just set the field \"rtl\" to true and use a compatible tokenizer: var index = new Index({ encode: str => str.toLowerCase().split(/[^a-z]+/), tokenize: \"reverse\", rtl: true }); CJK Word Break (Chinese, Japanese, Korean) Set a custom tokenizer which fits your needs, e.g.: var index = FlexSearch.create({ encode: str => str.replace(/[\\x00-\\x7F]/g, \"\").split(\"\") }); You can also pass a custom encoder function to apply some linguistic transformations. index.add(0, \"一个单词\"); var results = index.search(\"单词\"); Index Documents (Field-Search) The Document Descriptor Assuming our document has a data structure like this: { \"id\": 0, \"content\": \"some text\" } Old syntax FlexSearch v0.6.3 (not supported anymore!): const index = new Document({ doc: { id: \"id\", field: [\"content\"] } }); The document descriptor has slightly changed, there is no field branch anymore, instead just apply one level higher, so key becomes a main member of options. For the new syntax the field \"doc\" was renamed to document and the field \"field\" was renamed to index: const index = new Document({ document: { id: \"id\", index: [\"content\"] } }); index.add({ id: 0, content: \"some text\" }); The field id describes where the ID or unique key lives inside your documents. The default key gets the value id by default when not passed, so you can shorten the example from above to: const index = new Document({ document: { index: [\"content\"] } }); The member index has a list of fields which you want to be indexed from your documents. When just selecting one field, then you can pass a string. When also using default key id then this shortens to just: const index = new Document({ document: \"content\" }); index.add({ id: 0, content: \"some text\" }); Assuming you have several fields, you can add multiple fields to the index: var docs = [{ id: 0, title: \"Title A\", content: \"Body A\" },{ id: 1, title: \"Title B\", content: \"Body B\" }]; const index = new Document({ id: \"id\", index: [\"title\", \"content\"] }); You can pass custom options for each field: const index = new Document({ id: \"id\", index: [{ field: \"title\", tokenize: \"forward\", optimize: true, resolution: 9 },{ field: \"content\", tokenize: \"strict\", optimize: true, resolution: 5, minlength: 3, context: { depth: 1, resolution: 3 } }] }); Field options gets inherited when also global options was passed, e.g.: const index = new Document({ tokenize: \"strict\", optimize: true, resolution: 9, document: { id: \"id\", index:[{ field: \"title\", tokenize: \"forward\" },{ field: \"content\", minlength: 3, context: { depth: 1, resolution: 3 } }] } }); Note: The context options from the field \"content\" also gets inherited by the corresponding field options, whereas this field options was inherited by the global option. Nested Data Fields (Complex Objects) Assume the document array looks more complex (has nested branches etc.), e.g.: { \"record\": { \"id\": 0, \"title\": \"some title\", \"content\": { \"header\": \"some text\", \"footer\": \"some text\" } } } Then use the colon separated notation root:child:child to define hierarchy within the document descriptor: const index = new Document({ document: { id: \"record:id\", index: [ \"record:title\", \"record:content:header\", \"record:content:footer\" ] } }); Just add fields you want to query against. Do not add fields to the index, you just need in the result (but did not query against). For this purpose you can store documents independently of its index (read below). When you want to query through a field you have to pass the exact key of the field you have defined in the doc as a field name (with colon syntax): index.search(query, { index: [ \"record:title\", \"record:content:header\", \"record:content:footer\" ] }); Same as: index.search(query, [ \"record:title\", \"record:content:header\", \"record:content:footer\" ]); Using field-specific options: index.search([{ field: \"record:title\", query: \"some query\", limit: 100, suggest: true },{ field: \"record:title\", query: \"some other query\", limit: 100, suggest: true }]); You can perform a search through the same field with different queries. When passing field-specific options you need to provide the full configuration for each field. They get not inherited like the document descriptor. Complex Documents You need to follow 2 rules for your documents: The document cannot start with an Array at the root index. This will introduce sequential data and isn't supported yet. See below for a workaround for such data. [ // <-- not allowed as document start! { \"id\": 0, \"title\": \"title\" } ] The id can't be nested inside an array (also none of the parent fields can't be an array). This will introduce sequential data and isn't supported yet. See below for a workaround for such data. { \"records\": [ // <-- not allowed when ID or tag lives inside! { \"id\": 0, \"title\": \"title\" } ] } Here an example for a supported complex document: { \"meta\": { \"tag\": \"cat\", \"id\": 0 }, \"contents\": [ { \"body\": { \"title\": \"some title\", \"footer\": \"some text\" }, \"keywords\": [\"some\", \"key\", \"words\"] }, { \"body\": { \"title\": \"some title\", \"footer\": \"some text\" }, \"keywords\": [\"some\", \"key\", \"words\"] } ] } The corresponding document descriptor (when all fields should be indexed) looks like: const index = new Document({ document: { id: \"meta:id\", tag: \"meta:tag\", index: [ \"contents[]:body:title\", \"contents[]:body:footer\", \"contents[]:keywords\" ] } }); Again, when searching you have to use the same colon-separated-string from your field definition. index.search(query, { index: \"contents[]:body:title\" }); Not Supported Documents (Sequential Data) This example breaks both rules from above: [ // <-- not allowed as document start! { \"tag\": \"cat\", \"records\": [ // <-- not allowed when ID or tag lives inside! { \"id\": 0, \"body\": { \"title\": \"some title\", \"footer\": \"some text\" }, \"keywords\": [\"some\", \"key\", \"words\"] }, { \"id\": 1, \"body\": { \"title\": \"some title\", \"footer\": \"some text\" }, \"keywords\": [\"some\", \"key\", \"words\"] } ] } ] You need to apply some kind of structure normalization. A workaround to such a data structure looks like this: const index = new Document({ document: { id: \"record:id\", tag: \"tag\", index: [ \"record:body:title\", \"record:body:footer\", \"record:body:keywords\" ] } }); function add(sequential_data){ for(let x = 0, data; x < sequential_data.length; x++){ data = sequential_data[x]; for(let y = 0, record; y < data.records.length; y++){ record = data.records[y]; index.add({ id: record.id, tag: data.tag, record: record }); } } } // now just use add() helper method as usual: add([{ // sequential structured data // take the data example above }]); You can skip the first loop when your document data has just one index as the outer array. Add/Update/Remove Documents to/from the Index Just pass the document array (or a single object) to the index: index.add(docs); Update index with a single object or an array of objects: index.update({ data:{ id: 0, title: \"Foo\", body: { content: \"Bar\" } } }); Remove a single object or an array of objects from the index: index.remove(docs); When the id is known, you can also simply remove by (faster): index.remove(id); Join / Append Arrays On the complex example above, the field keywords is an array but here the markup did not have brackets like keywords[]. That will also detect the array but instead of appending each entry to a new context, the array will be joined into on large string and added to the index. The difference of both kinds of adding array contents is the relevance when searching. When adding each item of an array via append() to its own context by using the syntax field[], then the relevance of the last entry concurrent with the first entry. When you left the brackets in the notation, it will join the array to one whitespace-separated string. Here the first entry has the highest relevance, whereas the last entry has the lowest relevance. So assuming the keyword from the example above are pre-sorted by relevance to its popularity, then you want to keep this order (information of relevance). For this purpose do not add brackets to the notation. Otherwise, it would take the entries in a new scoring context (the old order is getting lost). Also you can left bracket notation for better performance and smaller memory footprint. Use it when you did not need the granularity of relevance by the entries. Field-Search Search through all fields: index.search(query); Search through a specific field: index.search(query, { index: \"title\" }); Search through a given set of fields: index.search(query, { index: [\"title\", \"content\"] }); Same as: index.search(query, [\"title\", \"content\"]); Pass custom modifiers and queries to each field: index.search([{ field: \"content\", query: \"some query\", limit: 100, suggest: true },{ field: \"content\", query: \"some other query\", limit: 100, suggest: true }]); You can perform a search through the same field with different queries. See all available field-search options. The Result Set Schema of the result-set: fields[] => { field, result[] => { document }} The first index is an array of fields the query was applied to. Each of this field has a record (object) with 2 properties \"field\" and \"result\". The \"result\" is also an array and includes the result for this specific field. The result could be an array of IDs or as enriched with stored document data. A non-enriched result set now looks like: [{ field: \"title\", result: [0, 1, 2] },{ field: \"content\", result: [3, 4, 5] }] An enriched result set now looks like: [{ field: \"title\", result: [ { id: 0, doc: { /* document */ }}, { id: 1, doc: { /* document */ }}, { id: 2, doc: { /* document */ }} ] },{ field: \"content\", result: [ { id: 3, doc: { /* document */ }}, { id: 4, doc: { /* document */ }}, { id: 5, doc: { /* document */ }} ] }] When using pluck instead of \"field\" you can explicitly select just one field and get back a flat representation: index.search(query, { pluck: \"title\", enrich: true }); [ { id: 0, doc: { /* document */ }}, { id: 1, doc: { /* document */ }}, { id: 2, doc: { /* document */ }} ] This result set is a replacement of \"boolean search\". Instead of applying your bool logic to a nested object, you can apply your logic by yourself on top of the result-set dynamically. This opens hugely capabilities on how you process the results. Therefore, the results from the fields aren't squashed into one result anymore. That keeps some important information, like the name of the field as well as the relevance of each field results which didn't get mixed anymore. A field search will apply a query with the boolean \"or\" logic by default. Each field has its own result to the given query. There is one situation where the bool property is being still supported. When you like to switch the default \"or\" logic from the field search into \"and\", e.g.: index.search(query, { index: [\"title\", \"content\"], bool: \"and\" }); You will just get results which contains the query in both fields. That's it. Tags Like the key for the ID just define the path to the tag: const index = new Document({ document: { id: \"id\", tag: \"tag\", index: \"content\" } }); index.add({ id: 0, tag: \"cat\", content: \"Some content ...\" }); Your data also can have multiple tags as an array: index.add({ id: 1, tag: [\"animal\", \"dog\"], content: \"Some content ...\" }); You can perform a tag-specific search by: index.search(query, { index: \"content\", tag: \"animal\" }); This just gives you result which was tagged with the given tag. Use multiple tags when searching: index.search(query, { index: \"content\", tag: [\"cat\", \"dog\"] }); This gives you result which are tagged with one of the given tag. Multiple tags will apply as the boolean \"or\" by default. It just needs one of the tags to be existing. This is another situation where the bool property is still supported. When you like to switch the default \"or\" logic from the tag search into \"and\", e.g.: index.search(query, { index: \"content\", tag: [\"dog\", \"animal\"], bool: \"and\" }); You will just get results which contains both tags (in this example there is just one records which has the tag \"dog\" and \"animal\"). Tag Search You can also fetch results from one or more tags when no query was passed: index.search({ tag: [\"cat\", \"dog\"] }); In this case the result-set looks like: [{ tag: \"cat\", result: [ /* all cats */ ] },{ tag: \"dog\", result: [ /* all dogs */ ] }] Limit & Offset By default, every query is limited to 100 entries. Unbounded queries leads into issues. You need to set the limit as an option to adjust the size. You can set the limit and the offset for each query: index.search(query, { limit: 20, offset: 100 }); You cannot pre-count the size of the result-set. That's a limit by the design of FlexSearch. When you really need a count of all results you are able to page through, then just assign a high enough limit and get back all results and apply your paging offset manually (this works also on server-side). FlexSearch is fast enough that this isn't an issue. Document Store Only a document index can have a store. You can use a document index instead of a flat index to get this functionality also when only storing ID-content-pairs. You can define independently which fields should be indexed and which fields should be stored. This way you can index fields which should not be included in the search result. Do not use a store when: 1. an array of IDs as the result is good enough, or 2. you already have the contents/documents stored elsewhere (outside the index). When the store attribute was set, you have to include all fields which should be stored explicitly (acts like a whitelist). When the store attribute was not set, the original document is stored as a fallback. This will add the whole original content to the store: const index = new Document({ document: { index: \"content\", store: true } }); index.add({ id: 0, content: \"some text\" }); Access documents from internal store You can get indexed documents from the store: var data = index.get(1); You can update/change store contents directly without changing the index by: index.set(1, data); To update the store and also update the index then just use index.update, index.add or index.append. When you perform a query, weather it is a document index or a flat index, then you will always get back an array of IDs. Optionally you can enrich the query results automatically with stored contents by: index.search(query, { enrich: true }); Your results look now like: [{ id: 0, doc: { /* content from store */ } },{ id: 1, doc: { /* content from store */ } }] Configure Storage (Recommended) This will add just specific fields from a document to the store (the ID isn't necessary to keep in store): const index = new Document({ document: { index: \"content\", store: [\"author\", \"email\"] } }); index.add(id, content); You can configure independently what should being indexed and what should being stored. It is highly recommended to make use of this whenever you can. Here a useful example of configuring doc and store: const index = new Document({ document: { index: \"content\", store: [\"author\", \"email\"] } }); index.add({ id: 0, author: \"Jon Doe\", email: \"john@mail.com\", content: \"Some content for the index ...\" }); You can query through the contents and will get back the stored values instead: index.search(\"some content\", { enrich: true }); Your results are now looking like: [{ field: \"content\", result: [{ id: 0, doc: { author: \"Jon Doe\", email: \"john@mail.com\", } }] }] Both field \"author\" and \"email\" are not indexed. Chaining Simply chain methods like: var index = FlexSearch.create() .addMatcher({'â': 'a'}) .add(0, 'foo') .add(1, 'bar'); index.remove(0).update(1, 'foo').add(2, 'foobar'); Enable Contextual Scoring Create an index and use the default context: var index = new FlexSearch({ tokenize: \"strict\", context: true }); Create an index and apply custom options for the context: var index = new FlexSearch({ tokenize: \"strict\", context: { resolution: 5, depth: 3, bidirectional: true } }); Only the tokenizer \"strict\" is actually supported by the contextual index. The contextual index requires additional amount of memory depending on depth. Auto-Balanced Cache (By Popularity) You need to initialize the cache and its limit during the creation of the index: const index = new Index({ cache: 100 }); const results = index.searchCache(query); A common scenario for using a cache is an autocomplete or instant search when typing. When passing a number as a limit the cache automatically balance stored entries related to their popularity. When just using \"true\" the cache is unbounded and perform actually 2-3 times faster (because the balancer do not have to run). Worker Parallelism (Browser + Node.js) The new worker model from v0.7.0 is divided into \"fields\" from the document (1 worker = 1 field index). This way the worker becomes able to solve tasks (subtasks) completely. The downside of this paradigm is they might not have been perfect balanced in storing contents (fields may have different length of contents). On the other hand there is no indication that balancing the storage gives any advantage (they all require the same amount in total). When using a document index, then just apply the option \"worker\": const index = new Document({ index: [\"tag\", \"name\", \"title\", \"text\"], worker: true }); index.add({ id: 1, tag: \"cat\", name: \"Tom\", title: \"some\", text: \"some\" }).add({ id: 2, tag: \"dog\", name: \"Ben\", title: \"title\", text: \"content\" }).add({ id: 3, tag: \"cat\", name: \"Max\", title: \"to\", text: \"to\" }).add({ id: 4, tag: \"dog\", name: \"Tim\", title: \"index\", text: \"index\" }); Worker 1: { 1: \"cat\", 2: \"dog\", 3: \"cat\", 4: \"dog\" } Worker 2: { 1: \"Tom\", 2: \"Ben\", 3: \"Max\", 4: \"Tim\" } Worker 3: { 1: \"some\", 2: \"title\", 3: \"to\", 4: \"index\" } Worker 4: { 1: \"some\", 2: \"content\", 3: \"to\", 4: \"index\" } When you perform a field search through all fields then this task is being balanced perfectly through all workers, which can solve their subtasks independently. Worker Index Above we have seen that documents will create worker automatically for each field. You can also create a WorkerIndex directly (same like using Index instead of Document). Use as ES6 module: import WorkerIndex from \"./worker/index.js\"; const index = new WorkerIndex(options); index.add(1, \"some\") .add(2, \"content\") .add(3, \"to\") .add(4, \"index\"); Or when bundled version was used instead: var index = new FlexSearch.Worker(options); index.add(1, \"some\") .add(2, \"content\") .add(3, \"to\") .add(4, \"index\"); Such a WorkerIndex works pretty much the same as a created instance of Index. A WorkerIndex only support the async variant of all methods. That means when you call index.search() on a WorkerIndex this will perform also in async the same way as index.searchAsync() will do. Worker Threads (Node.js) The worker model for Node.js is based on \"worker threads\" and works exactly the same way: const { Document } = require(\"flexsearch\"); const index = new Document({ index: [\"tag\", \"name\", \"title\", \"text\"], worker: true }); Or create a single worker instance for a non-document index: const { Worker } = require(\"flexsearch\"); const index = new Worker({ options }); The Worker Async Model (Best Practices) A worker will always perform as async. On a query method call you always should handle the returned promise (e.g. use await) or pass a callback function as the last parameter. const index = new Document({ index: [\"tag\", \"name\", \"title\", \"text\"], worker: true }); All requests and sub-tasks will run in parallel (prioritize \"all tasks completed\"): index.searchAsync(query, callback); index.searchAsync(query, callback); index.searchAsync(query, callback); Also (prioritize \"all tasks completed\"): index.searchAsync(query).then(callback); index.searchAsync(query).then(callback); index.searchAsync(query).then(callback); Or when you have just one callback when all requests are done, simply use Promise.all() which also prioritize \"all tasks completed\": Promise.all([ index.searchAsync(query), index.searchAsync(query), index.searchAsync(query) ]).then(callback); Inside the callback of Promise.all() you will also get an array of results as the first parameter respectively for each query you put into. When using await you can prioritize the order (prioritize \"first task completed\") and solve requests one by one and just process the sub-tasks in parallel: await index.searchAsync(query); await index.searchAsync(query); await index.searchAsync(query); Same for index.add(), index.append(), index.remove() or index.update(). Here there is a special case which isn't disabled by the library, but you need to keep in mind when using Workers. When you call the \"synced\" version on a worker index: index.add(doc); index.add(doc); index.add(doc); // contents aren't indexed yet, // they just queued on the message channel Of course, you can do that but keep in mind that the main thread does not have an additional queue for distributed worker tasks. Running these in a long loop fires content massively to the message channel via worker.postMessage() internally. Luckily the browser and Node.js will handle such incoming tasks for you automatically (as long enough free RAM is available). When using the \"synced\" version on a worker index, the content isn't indexed one line below, because all calls are treated as async by default. When adding/updating/removing large bulks of content to the index (or high frequency), it is recommended to use the async version along with async/await to keep a low memory footprint during long processes. Export / Import Export The export has slightly changed. The export now consist of several smaller parts, instead of just one large bulk. You need to pass a callback function which has 2 arguments \"key\" and \"data\". This callback function is called by each part, e.g.: index.export(function(key, data){ // you need to store both the key and the data! // e.g. use the key for the filename and save your data localStorage.setItem(key, data); }); Exporting data to the localStorage isn't really a good practice, but if size is not a concern than use it if you like. The export primarily exists for the usage in Node.js or to store indexes you want to delegate from a server to the client. The size of the export corresponds to the memory consumption of the library. To reduce export size you have to use a configuration which has less memory footprint (use the table at the bottom to get information about configs and its memory allocation). When your save routine runs asynchronously you have to return a promise: index.export(function(key, data){ return new Promise(function(resolve){ // do the saving as async resolve(); }); }); You cannot export the additional table for the \"fastupdate\" feature. These table exists of references and when stored they fully get serialized and becomes too large. The lib will handle these automatically for you. When importing data, the index automatically disables \"fastupdate\". Import Before you can import data, you need to create your index first. For document indexes provide the same document descriptor you used when export the data. This configuration isn't stored in the export. var index = new Index({ ... }); To import the data just pass a key and data: index.import(key, localStorage.getItem(key)); You need to import every key! Otherwise, your index does not work. You need to store the keys from the export and use this keys for the import (the order of the keys can differ). This is just for demonstration and is not recommended, because you might have other keys in your localStorage which aren't supported as an import: var keys = Object.keys(localStorage); for(let i = 0, key; i < keys.length; i++){ key = keys[i]; index.import(key, localStorage.getItem(key)); } Languages Language-specific definitions are being divided into two groups: Charset encode, type: function(string):string[] rtl, type: boolean Language matcher, type: {string: string} stemmer, type: {string: string} filter, type: string[] The charset contains the encoding logic, the language contains stemmer, stopword filter and matchers. Multiple language definitions can use the same charset encoder. Also this separation let you manage different language definitions for special use cases (e.g. names, cities, dialects/slang, etc.). To fully describe a custom language on the fly you need to pass: const index = FlexSearch({ // mandatory: encode: (content) => [words], // optionally: rtl: false, stemmer: {}, matcher: {}, filter: [] }); When passing no parameter it uses the latin:default schema by default. Field Category Description encode charset The encoder function. Has to return an array of separated words (or an empty string). rtl charset A boolean property which indicates right-to-left encoding. filter language Filter are also known as \"stopwords\", they completely filter out words from being indexed. stemmer language Stemmer removes word endings and is a kind of \"partial normalization\". A word ending just matched when the word length is bigger than the matched partial. matcher language Matcher replaces all occurrences of a given string regardless of its position and is also a kind of \"partial normalization\". 1. Language Packs: ES6 Modules The most simple way to assign charset/language specific encoding via modules is: import charset from \"./dist/module/lang/latin/advanced.js\"; import lang from \"./dist/module/lang/en.js\"; const index = FlexSearch({ charset: charset, lang: lang }); Just import the default export by each module and assign them accordingly. The full qualified example from above is: import { encode, rtl } from \"./dist/module/lang/latin/advanced.js\"; import { stemmer, filter, matcher } from \"./dist/module/lang/en.js\"; const index = FlexSearch({ encode: encode, rtl: rtl, stemmer: stemmer, matcher: matcher, filter: filter }); The example above is the standard interface which is at least exported from each charset/language. You can also define the encoder directly and left all other options: import simple from \"./dist/module/lang/latin/simple.js\"; const index = FlexSearch({ encode: simple }); Available Latin Encoders default simple balance advanced extra You can assign a charset by passing the charset during initialization, e.g. charset: \"latin\" for the default charset encoder or charset: \"latin:soundex\" for a encoder variant. Dialect / Slang Language definitions (especially matchers) also could be used to normalize dialect and slang of a specific language. 2. Language Packs: ES5 (Language Packs) You need to make the charset and/or language definitions available by: All charset definitions are included in the flexsearch.bundle.js build by default, but no language-specific definitions are included You can load packages located in /dist/lang/ (files refers to languages, folders are charsets) You can make a custom build When loading language packs, make sure that the library was loaded before: <script src=\"dist/flexsearch.light.js\"></script> <script src=\"dist/lang/latin/default.min.js\"></script> <script src=\"dist/lang/en.min.js\"></script> When using the full \"bundle\" version the built-in latin encoders are already included and you just have to load the language file: <script src=\"dist/flexsearch.bundle.js\"></script> <script src=\"dist/lang/en.min.js\"></script> Because you loading packs as external packages (non-ES6-modules) you have to initialize them by shortcuts: const index = FlexSearch({ charset: \"latin:soundex\", lang: \"en\" }); Use the charset:variant notation to assign charset and its variants. When just passing the charset without a variant will automatically resolve as charset:default. You can also override existing definitions, e.g.: const index = FlexSearch({ charset: \"latin\", lang: \"en\", matcher: {} }); Passed definitions will not extend default definitions, they will replace them. When you like to extend a definition just create a new language file and put in all the logic. Encoder Variants It is pretty straight forward when using an encoder variant: <script src=\"dist/flexsearch.light.js\"></script> <script src=\"dist/lang/latin/advanced.min.js\"></script> <script src=\"dist/lang/latin/extra.min.js\"></script> <script src=\"dist/lang/en.min.js\"></script> When using the full \"bundle\" version the built-in latin encoders are already included and you just have to load the language file: <script src=\"dist/flexsearch.bundle.js\"></script> <script src=\"dist/lang/en.min.js\"></script> const index_advanced = FlexSearch({ charset: \"latin:advanced\" }); const index_extra = FlexSearch({ charset: \"latin:extra\" }); Partial Tokenizer In FlexSearch you can't provide your own partial tokenizer, because it is a direct dependency to the core unit. The built-in tokenizer of FlexSearch splits each word into fragments by different patterns: strict (supports contextual index) forward reverse (including forward) full Language Processing Pipeline This is the default pipeline provided by FlexSearch: Custom Pipeline At first take a look into the default pipeline in src/common.js. It is very simple and straight forward. The pipeline will process as some sort of inversion of control, the final encoder implementation has to handle charset and also language specific transformations. This workaround has left over from many tests. Inject the default pipeline by e.g.: this.pipeline( /* string: */ str.toLowerCase(), /* normalize: */ false, /* split: */ split, /* collapse: */ false ); Use the pipeline schema from above to understand the iteration and the difference of pre-encoding and post-encoding. Stemmer and matchers needs to be applied after charset normalization but before language transformations, filters also. Here is a good example of extending pipelines: src/lang/latin/extra.js → src/lang/latin/advanced.js → src/lang/latin/simple.js. How to contribute? Search for your language in src/lang/, if it exists you can extend or provide variants (like dialect/slang). If the language doesn't exist create a new file and check if any of the existing charsets (e.g. latin) fits to your language. When no charset exist, you need to provide a charset as a base for the language. A new charset should provide at least: encode A function which normalize the charset of a passed text content (remove special chars, lingual transformations, etc.) and returns an array of separated words. Also stemmer, matcher or stopword filter needs to be applied here. When the language has no words make sure to provide something similar, e.g. each chinese sign could also be a \"word\". Don't return the whole text content without split. rtl A boolean flag which indicates right-to-left encoding Basically the charset needs just to provide an encoder function along with an indicator for right-to-left encoding: export function encode(str){ return [str] } export const rtl = false; Encoder Matching Comparison Reference String: \"Björn-Phillipp Mayer\" Query default simple advanced extra björn yes yes yes yes björ yes yes yes yes bjorn no yes yes yes bjoern no no yes yes philipp no no yes yes filip no no yes yes björnphillip no yes yes yes meier no no yes yes björn meier no no yes yes meier fhilip no no yes yes byorn mair no no no yes (false positives) no no no yes Memory Allocation The book \"Gulliver's Travels Swift Jonathan 1726\" was fully indexed for the examples below. The most memory-optimized meaningful setting will allocate just 1.2 Mb for the whole book indexed! This is probably the most tiny memory footprint you will get from a search library. import { encode } from \"./lang/latin/extra.js\"; index = new Index({ encode: encode, tokenize: \"strict\", optimize: true, resolution: 1, minlength: 3, fastupdate: false, context: false }); Memory Consumption The book \"Gulliver's Travels\" (Swift Jonathan 1726) was completely indexed for this test: Compare Impact of Memory Allocation by default a lexical index is very small: depth: 0, bidirectional: 0, resolution: 3, minlength: 0 => 2.1 Mb a higher resolution will increase the memory allocation: depth: 0, bidirectional: 0, resolution: 9, minlength: 0 => 2.9 Mb using the contextual index will increase the memory allocation: depth: 1, bidirectional: 0, resolution: 9, minlength: 0 => 12.5 Mb a higher contextual depth will increase the memory allocation: depth: 2, bidirectional: 0, resolution: 9, minlength: 0 => 21.5 Mb a higher minlength will decrease memory allocation: depth: 2, bidirectional: 0, resolution: 9, minlength: 3 => 19.0 Mb using bidirectional will decrease memory allocation: depth: 2, bidirectional: 1, resolution: 9, minlength: 3 => 17.9 Mb enable the option \"fastupdate\" will increase memory allocation: depth: 2, bidirectional: 1, resolution: 9, minlength: 3 => 6.3 Mb Full Comparison Table Every search library is constantly in competition with these 4 properties: Memory Allocation Performance Matching Capabilities Relevance Order (Scoring) FlexSearch provides you many parameters you can use to adjust the optimal balance for your specific use-case. Modifier Memory Impact * Performance Impact ** Matching Impact ** Scoring Impact ** resolution +1 (per level) +1 (per level) 0 +2 (per level) depth +4 (per level) -1 (per level) -10 + depth +10 minlength -2 (per level) +2 (per level) -3 (per level) +2 (per level) bidirectional -2 0 +3 -1 fastupdate +1 +10 (update, remove) 0 0 optimize: true -7 -1 0 -3 encoder: \"icase\" 0 0 0 0 encoder: \"simple\" -2 -1 +2 0 encoder: \"advanced\" -3 -2 +4 0 encoder: \"extra\" -5 -5 +6 0 encoder: \"soundex\" -6 -2 +8 0 tokenize: \"strict\" 0 0 0 0 tokenize: \"forward\" +3 -2 +5 0 tokenize: \"reverse\" +5 -4 +7 0 tokenize: \"full\" +8 -5 +10 0 document index +3 (per field) -1 (per field) 0 0 document tags +1 (per tag) -1 (per tag) 0 0 store: true +5 (per document) 0 0 0 store: [fields] +1 (per field) 0 0 0 cache: true +10 +10 0 0 cache: 100 +1 +9 0 0 type of ids: number 0 0 0 0 type of ids: string +3 -3 0 0 * range from -10 to 10, lower is better (-10 => big decrease, 0 => unchanged, +10 => big increase) ** range from -10 to 10, higher is better Presets memory (primary optimize for memory) performance (primary optimize for performance) match (primary optimize for matching) score (primary optimize for scoring) default (the default balanced profile) These profiles are covering standard use cases. It is recommended to apply custom configuration instead of using profiles to get the best out for your situation. Every profile could be optimized further to its specific task, e.g. extreme performance optimized configuration or extreme memory and so on. You can pass a preset during creation/initialization of the index. Best Practices Use numeric IDs It is recommended to use numeric id values as reference when adding content to the index. The byte length of passed ids influences the memory consumption significantly. If this is not possible you should consider to use a index table and map the ids with indexes, this becomes important especially when using contextual indexes on a large amount of content. Split Complexity Whenever you can, try to divide content by categories and add them to its own index, e.g.: var action = new FlexSearch(); var adventure = new FlexSearch(); var comedy = new FlexSearch(); This way you can also provide different settings for each category. This is actually the fastest way to perform a fuzzy search. To make this workaround more extendable you can use a short helper: var index = {}; function add(id, cat, content){ (index[cat] || ( index[cat] = new FlexSearch )).add(id, content); } function search(cat, query){ return index[cat] ? index[cat].search(query) : []; } Add content to the index: add(1, \"action\", \"Movie Title\"); add(2, \"adventure\", \"Movie Title\"); add(3, \"comedy\", \"Movie Title\"); Perform queries: var results = search(\"action\", \"movie title\"); // --> [1] Split indexes by categories improves performance significantly. Copyright 2018-2021 Nextapps GmbH Released under the Apache 2.0 License"
  }
}